<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="baidu-site-verification" content="5IfwMCE5hH" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.jiezi19971225.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录编程学习路上的点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Jiez19971225‘s Blog">
<meta property="og:url" content="http://www.jiezi19971225.cn/page/7/index.html">
<meta property="og:site_name" content="Jiez19971225‘s Blog">
<meta property="og:description" content="记录编程学习路上的点滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiezi19971225">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.jiezi19971225.cn/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jiez19971225‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiez19971225‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做自己爱做的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%A6%E5%81%8F%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%A6%E5%81%8F%E6%A0%91/" class="post-title-link" itemprop="url">左偏树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-11 18:46:05" itemprop="dateCreated datePublished" datetime="2019-05-11T18:46:05+00:00">2019-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">992(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">4(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最后一篇以前写的文章了，</p>
<p>左偏树是一种实现简单的可并堆，可以在 logn 的复杂度下面完成优先队列的插入，删除，合并操作。</p>
<p>这就是一颗左偏树啦 蓝色是该节点的 dist</p>
<p><img src="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%A6%E5%81%8F%E6%A0%91/左偏树.png" alt="左偏树"></p>
<p>结构体定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,v;<span class="comment">//左右子树，距离和键值</span></span><br><span class="line">    <span class="built_in">Node</span>()&#123;</span><br><span class="line">        l=r=v=d=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义左偏树的外界点为，一个左子树为空或者一个右子树为空的结点，结点的 dist 为它到它子树内外节点的最短距离。一个左偏树在满足堆的性质的前提下还应该满足它的右子树的 dist 不大于它的左子树的 dist。由此，我们可以得出其他一些性质。</p>
<p>当前结点的 dist 为右子树 dist 的长度+1<br>若左偏树根节点的 dist 为一定值，则节点数最少的左偏树是一颗完全二叉树，并且为满二叉树<br>由上一条性质，可以知道根节点 dist 为 n 的左偏树，最少含有 2n+1−12n+1−1 个结点<br>一个有 n 个结点的左偏树，根节点距离最大为|log2（n+1）|−1|log2（n+1）|−1<br>左偏树的操作（最大堆）</p>
<p>递归合并<br>如果有一颗树为空，返回另一棵树<br>否则，就将根节点键值较大树的右子树和根节点键值较小树合并<br>如果合并后破坏了左偏树的性质（左子树 dist&lt;右子树 dist）<br>交换根节点的左右子树<br>更新根节点的 dist 值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].v&lt;node[y].v)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].r=<span class="built_in">merge</span>(node[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(node[node[x].l].d&lt;node[node[x].r].d)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(node[x].l,node[x].r);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].d=node[node[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入<br>相当于和只有一个结点的树合并</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    node[cnt].v=v;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(x,cnt);<span class="comment">//返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node[x].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(node[x].l,node[x].r);<span class="comment">//返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作都以左偏树堆顶的编号代表这一刻左偏树<br>例题 hdu1512 左偏树加并查集的模版题，今年省赛的热身赛就是这题来着，当时乱搞搞出来了（数据太弱），重新用左偏树写一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[maxn],pqroot[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,v;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;</span><br><span class="line">        l=r=v=d=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        l=r=d=<span class="number">0</span>;</span><br><span class="line">        v/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].v&lt;node[y].v)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].r=<span class="built_in">merge</span>(node[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(node[node[x].l].d&lt;node[node[x].r].d)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(node[x].l,node[x].r);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].d=node[node[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(node[x].l,node[x].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==p[x]?x:x=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p[x]=y;</span><br><span class="line">    pqroot[y]=root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">        <span class="built_in">memset</span>(pqroot,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pqroot));</span><br><span class="line">        node[<span class="number">0</span>].d=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">            pqroot[i]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1,p2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p1,&amp;p2);</span><br><span class="line">            <span class="keyword">int</span> s1=<span class="built_in">find</span>(p1),s2=<span class="built_in">find</span>(p2);</span><br><span class="line">            <span class="keyword">if</span>(s1!=s2)&#123;</span><br><span class="line">                <span class="keyword">int</span> pqroot1=pqroot[s1],pqroot2=pqroot[s2];</span><br><span class="line">                <span class="keyword">int</span> newroot1=<span class="built_in">pop</span>(pqroot1);</span><br><span class="line">                <span class="keyword">int</span> newroot2=<span class="built_in">pop</span>(pqroot2);</span><br><span class="line">                node[pqroot1].<span class="built_in">fight</span>();</span><br><span class="line">                node[pqroot2].<span class="built_in">fight</span>();</span><br><span class="line">                newroot1=<span class="built_in">merge</span>(newroot1,pqroot1);</span><br><span class="line">                newroot2=<span class="built_in">merge</span>(newroot2,pqroot2);</span><br><span class="line">                <span class="keyword">int</span> newpqroot=<span class="built_in">merge</span>(newroot1,newroot2);</span><br><span class="line">                <span class="built_in">uset</span>(s1,s2,newpqroot);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,node[newpqroot].v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并查集维护一个当前集合内优先队列的根节点 pqroot，合并的时候注意根的相关操作就 OK 了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/" class="post-title-link" itemprop="url">差分约束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-11 18:44:49" itemprop="dateCreated datePublished" datetime="2019-05-11T18:44:49+00:00">2019-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">728(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">3(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这还是一篇以前写的文章。</p>
<p>差分约束问题是一类出一些形如 x-y&lt;=b 不等式的约束，问你是否满足有解的问题，这类问题竟然可以转换成图论里的最短路径问题，下面开始详细介绍下<br>比如给出三个不等式,b-a&lt;=k1,c-b&lt;=k2,c-a&lt;=k3,求出 c-a 的最大值,我们可以把 a,b,c 转换成三个点，k1，k2，k3 是边上的权，如图<br>由题我们可以得知，这个有向图中，由题 b-a&lt;=k1,c-b&lt;=k2,得出 c-a&lt;=k1+k2,因此比较 k1+k2 和 k3 的大小，求出最小的就是 c-a 的最大值了<br>根据以上的解法，我们可能会猜到求解过程实际就是求从 a 到 c 的最短路径，没错的….简单的说就是从 a 到 c 沿着某条路径后把所有权值和 k 求出就是 c -a&lt;=k 的一个<br>推广的不等式约束，既然这样，满足题目的肯定是最小的 k，也就是从 a 到 c 最短距离<br>再看 a - b &lt;= k1，b - c &lt;= k2， c-1 &lt;= k3， 那么有 k1+k2+k3&gt;=0，因此若图中存在负环，就说明不存在满足条件的解<br>判断图中是否存在负环 可以使用 dfs 形式的 spfa 算法，使用一个 vis 数组 值为 1 表示当前正在递归栈中的点，因为点可能多次入栈，需要注意回溯时处理。<br>洛谷 P1993   使用了超级源点的思想，将图中的所有点与超级源点连一条权值为 0 的边，对结果没有影响，但方便了问题的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> to,<span class="keyword">int</span> w)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;to = to,<span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line">vector&lt;node&gt; gra[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(<span class="built_in">node</span>(b,c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(dist[to]&gt;dist[x]+gra[x][i].w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[to] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            dist[to]=dist[x]+gra[x][i].w;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">spfa</span>(to);</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to] = <span class="number">0</span>;<span class="comment">// 回溯的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fill</span>(dist,dist+maxn,inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b,c;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,-c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/11/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/" class="post-title-link" itemprop="url">图论基础之图中找环</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-11 18:35:20" itemprop="dateCreated datePublished" datetime="2019-05-11T18:35:20+00:00">2019-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">1.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">6(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于有向图而言 可以使用拓扑排序的方式找出图中的环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> du[maxn];<span class="comment">//入度</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    du[b]++;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[temp].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = gra[temp][i];</span><br><span class="line">            du[to]--;</span><br><span class="line">            <span class="keyword">if</span>(!du[to])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图 可以采用并查集的方式，在读边的时候，如果两个顶点在同一个集合中，说明构成了环，这时令这两个顶点作为起点和终点，深搜一下输出路径即可</p>
<p>蓝桥杯 2017 国赛 c++b 组 t4 找环</p>
<p>题意：</p>
<p>编号为 1 到 n 的 n 个点，以及 n-1 条边构成一棵树。现在在树上加上一条边，这样就构成了一个含环的图了。请你找出该环上的结点，从小到大输出这些结点编号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e+7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x]==x?x:p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    p[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    gra[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    gra[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,e;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> path[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">            path[to] = x;<span class="comment">// 记录路径</span></span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(to == e)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(path));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> aa = <span class="built_in">find</span>(a),bb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(aa!=bb)&#123;</span><br><span class="line">            <span class="built_in">unit</span>(a,b);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 说明构成了环</span></span><br><span class="line">            s = a,e = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(s);</span><br><span class="line">    <span class="keyword">int</span> temp = e;</span><br><span class="line">    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">while</span>(path[temp])&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path[temp]);</span><br><span class="line">        temp = path[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以采用深搜的方式，首先需要了解</p>
<p>在图的遍历中，往往设置了一个标记数组 vis 来记录顶点是否被访问过。但有些时候需要改变 vis 值的意义。令 vis 具有 3 种值并表示 3 种不同含义</p>
<p>vis = 0,表示该顶点没没有被访问<br>vis = 1,表示该顶点已经被访问，但其子孙后代还没被访问完，也就没从该点返回<br>vis = 2,，表示该顶点已经被访问，其子孙后代也已经访问完，也已经从该顶点返回<br>可以 vis 的 3 种值表示的是一种顺序关系和时间关系</p>
<p>《算法导论》334 页有这 4 种边的准确定义</p>
<p><img src="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/边的定义.png" alt="边的定义"></p>
<p>DFS 过程中，对于一条边 u-&gt;v<br>vis[v] = 0,说明 v 还没被访问，v 是首次被发现，u-&gt;v 是一条树边<br>vis[v] = 1,说明 v 已经被访问，但其子孙后代还没有被访问完（正在访问中），而 u 又指向 v，说明 u 就是 v 的子孙后代，u-&gt;v 是一条后向边，因此后向边又称返祖边，<br>vis[v] = 2,说明 v 已经被访问，其子孙后代也已经全部访问完，u-&gt;v 这条边可能是一条横叉边，或者前向边</p>
<p>注意：树边，后向边，前向边，都有祖先，后裔的关系，但横叉边没有，u-&gt;v 为横叉边，说明在这棵 DFS 树中，它们不是祖先后裔的关系它们可能是兄弟关系，堂兄弟关系，甚至更远的关系，如果是 dfs 森林的话，u 和 v 甚至可以在不同的树上</p>
<p>对于无向图而言，只存在树边和返祖边，当发现一条返祖边时，说明找到了环，这时输出所有 vis[i] = 1 的节点即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    gra[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">()</span></span>&#123;  <span class="comment">// 找环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(to!= p &amp;&amp; vis[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">findp</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/04/22/misc/%E5%82%BB%E9%80%BC%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/22/misc/%E5%82%BB%E9%80%BC%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">傻逼记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-22 02:01:20" itemprop="dateCreated datePublished" datetime="2019-04-22T02:01:20+00:00">2019-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">543(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>昨天新买的笔记本到了，折腾了一下午安装 windows 下的软件，尝试了把自己装了 archlinux 移动固态接到笔电上，提示找不到分区 UUID。因为之前一直接在台式用，所以 fstab 上有台式机硬盘的记录，于是换上台式进 arch，把 fstab 里台式的分区都注释了（伏笔）。折腾一番可以进系统了，输完账号密码后，黑屏，是的它黑屏了。<br>开始猜测是显卡驱动的问题，切到字符 tty，安装上 amd 的显卡驱动，重启，依然不行。之后就是漫长的百度与谷歌时间。gnome 桌面是跟着教程安装的，一直以来都是 gdm 启动，所以我对于 X11 的启动过程基本是一窍不通。尝试使用 startx 手动启动，发现 root 可以进入，自己的用户进去就是黑屏。网上的一些方案有删除 gnome 插件，检查 PATH 设置，检查.Xauthority 文件权限，我都尝试了。更令我不能理解的是我换回台式机，它也黑屏了，我只好把自己对系统作的更改一条一条还原。这时看到网上一条评论说 X11 启动会读取用户目录下.x 目录下配置文件，既然 root 能进说明驱动啥的都没问题啊，可能就是配置文件的问题。我看了一下，arch 下没有.x 文件夹，不过在.config 文件下有很多 gnome 的文件夹。我突然想到自己之前因为空间不足，把用户目录下的.cache 和.config 都挂载硬盘的另一个分区上了。cd 到挂载目录，ls 显示目录为空。果然人一傻逼起来是没有救的，看了一下 fstab，果然那个分区的挂载注释掉了。修改之后重启，一切正常，此时已经是夜里 2 点钟。<br>谨以此记录一下我因为傻逼而浪费掉的 4 个小时的人生。<br>另如果想要在移动存储设备上安装 linux，务必参考官方 wiki<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/Installing_Arch_Linux_on_a_USB_key">在 USB 设备上安装 Arch Linux</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/04/20/%E7%AE%97%E6%B3%95/leetcodeP11-ContainerWithMostWater/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/20/%E7%AE%97%E6%B3%95/leetcodeP11-ContainerWithMostWater/" class="post-title-link" itemprop="url">leetcodeP11-ContainerWithMostWater</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-20 19:39:45" itemprop="dateCreated datePublished" datetime="2019-04-20T19:39:45+00:00">2019-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">403(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题以前做过，但是忘记怎么做的了。第一次交了一个双重循环的暴力。查看题解一下就明白了正确的贪心算法。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 N 个非负的正整数 a1,a2,a3,…an，每个代表了坐标轴上的一个点(i，ai)。n 条垂直的线连接点和 x 轴，要求找出两条线，让它们和 x 轴组成的容器的容积最大。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>正解是用两点逼近的算法。首先容器的高度是由最短的那条线决定的。<br>维护一个变量记录最大容积。记录所取的两端的端点位置，每次计算当前情况的容积，并更新最大容积。之后更新较短的那条线的端点位置(一定是更新较短的端点位置，否则容积一定小于当前容积，因为只有宽度减小)，更新方法为向另一端的方向遍历直到遇到一条比当前线高度高的线（比当前线高度低的线组成的容积一定小于当前情况的容积）。</p>
<p>以下是代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        minHeight := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            minHeight = height[left]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeight = height[right]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newArea := (right - left) * minHeight</span><br><span class="line">        <span class="keyword">if</span> newArea &gt; res &#123;</span><br><span class="line">            res = newArea</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            newLeft := left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> newLeft &lt; right &amp;&amp; height[newLeft] &lt; height[left] &#123;</span><br><span class="line">                newLeft = newLeft + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            left = newLeft</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newRight := right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> newRight &gt; left &amp;&amp; height[newRight] &lt; height[right] &#123;</span><br><span class="line">                newRight = newRight - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            right = newRight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">docker学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-05 15:37:07" itemprop="dateCreated datePublished" datetime="2019-04-05T15:37:07+00:00">2019-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">3.9k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">14(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>强烈推荐这个博主的系列文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011541946/category_8605832.html">docker 基础</a></p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>docker images 显示出所有的镜像<br>docker tag 给镜像打 tag eg docker tag unbuntu myubuntu:last<br>docker inspect 查看镜像信息<br>docker history 显示 layer 基础信息<br>docker search —filter=is-automated=true nginx<br>docker rmi [-f 强行删除] 镜像 tag/镜像 ID 删除镜像 当镜像有容器在运行时，会提示无法删除。当不加 tag 时默认为 latest<br>docker commit [OPTIONS]</p>
<ul>
<li>-a —author 作者信息</li>
<li>-c —change = [] 提交的时候执行 dockerfile 指令</li>
<li>-m —message 提交信息</li>
<li>-p —pause=true 提交时暂停容器运行</li>
</ul>
<p>docker commit -a “xxx” -m “xxx” [容器名称 容器 id] 镜像名称 基于已有镜像的容器创建<br>docekr create [options] 镜像名 新建一个容器 此时容器处于停止状态<br>docker run [option] 镜像名 新建一个容器 并且容器处于运行状态</p>
<ul>
<li>-P 暴露在 Dockerfile 中 Expose 的端口</li>
<li>-idt -i 让容器标准输入打开 -d 创建后台守护进程 -t 给 docker 分配一个伪终端</li>
<li>—name 命名容器</li>
<li>docker run -d -P —name web -v /src/webapp:/opt/webapp:ro [镜像 id 镜像名称] 容器名称 运行程序</li>
<li>docker run -it -v /dbdata —name dbdata ubuntu 创建数据卷容器</li>
<li>docker run -it —volumes-from dbdata —name db1 ubuntu 共享数据卷</li>
<li>docker run -d -P —name web —link db:db 镜像名 程序名 —link name:alias</li>
</ul>
<p>docker start 容器名或容器 ID<br>docker restart 容器名或者容器 ID 先将一个运行态的容器先停止，然后重新启动它<br>docker attach 容器名称或容器 ID 所有窗口会同步显示，当有一个窗口阻塞的时候，其他窗口也会阻塞<br>docker exec -it 容器名或容器 id /bin/bash<br>docker rm 删除处于终止或者退出状态的容器<br>docker top 镜像名 查看镜像内的进程<br>docker logs 镜像名 获取容器的日志</p>
<h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>可以查看这本 Gitbook <a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/image/dockerfile/copy.html">Docker 从入门到实践</a> 以下记录一些我不熟悉的知识点，便于复习</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：<br>VOLUME [“&lt;路径 1&gt;”, “&lt;路径 2&gt;”…]<br>VOLUME &lt;路径&gt;<br>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据<br>VOLUME /data<br>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。<br>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令</p>
<p>docker volume prune 清理无主的数据卷</p>
<h2 id="如何修改已存在容器的配置"><a href="#如何修改已存在容器的配置" class="headerlink" title="如何修改已存在容器的配置"></a>如何修改已存在容器的配置</h2><p>直接修改 /var/lib/docker/contains/[container_hash]/ 目录下的 config.v2.json 和 hostconfig.json 文件，修改之后需要重启 docker，再重新启动容器，就生效啦</p>
<h2 id="docker-架构"><a href="#docker-架构" class="headerlink" title="docker 架构"></a>docker 架构</h2><p>docker 采用 C/S 架构，包含客户端和服务端，通过镜像仓库来存储镜像。客户端和服务端可以不在一个机器上，通过 socket 或者 restful api 来进行通信。</p>
<h2 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h2><p>镜像是文件和 meta data 的集合 root filesystem</p>
<p>如一个 centos 的镜像，里面包含一些最精简版的 centos 文件系统，还有其他软件包等。</p>
<p>镜像是分层的，每层都可以添加删除改变文件，变成一个新的 image</p>
<p>不同的 image 可以共享同一层 layer</p>
<p>镜像本身是只读的</p>
<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器通过 image 创建</p>
<p>在 image layer 之上创建了一个 container layer，这个容器层可以读写操作</p>
<p>image 负责 app 的存储和分发，container 负责运行 app</p>
<h3 id="容器的-created-状态"><a href="#容器的-created-状态" class="headerlink" title="容器的 created 状态"></a>容器的 created 状态</h3><p>docker create 只创建容器，但是不启动，docker run 是启动并且创建容器</p>
<p>docker start 可以启动容器</p>
<h2 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h2><p>ADD 功能更强大，会拷贝文件并且解压，COPY 只会拷贝文件</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>一般在宿主机后台运行， dockerd 作为服务端接受来自客户的请求，通过 containerd 具体处理与容器相关的请求。包括创建，运行，删除容器等。</p>
<p>dockerd 为客户端提供 rest api，响应来自客户端的请求，采用模块化的解构，通过专门的 Engine 模块来分发管理各个来自客户端的任务。</p>
<p>docker-proxy 是 dockerd 的子进程，当需要进行容器端口映射时，docker-proxy 完成网络映射配置。</p>
<p>containerd 是 docker 的子进程，提供 gRPC 接口响应来自 dockerd 的请求，对下管理 runC 镜像和容器环境</p>
<p>containerd——shim, containerd 的子进程，作为容器内进程的根进程。</p>
<p>runC 是从 Docker 公司开源的 libcontainer 项目演化而来，。runC 支持 linux 系统中容器相关技术栈。</p>
<p>dockerd 默认监听本地 unix:///var/run/docker.sock 套接字，只允许本地 root 用户或者 docker 用户组成员能访问。</p>
<p>可以通过 -H 选项修改监听方式。</p>
<p>Docker 还支持通过 TLS 认证方式来验证访问。</p>
<p>docker-proxy 只有当启动容器并且开启端口映射才会执行，负责配置容器的端口映射规则。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>默认通过本地的 unix:///var/run/docker.sock 套接字向服务端发出命令。如果服务端没有监听默认地址，需要手动指定。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>namespace 是 linux 内核一个强大特性，利用这一特性，每个容器都可以拥有自己的单独命名空间。运行在其中的应用都像在独立的操作系统环境中一样。命名空间机制保证了容器之间彼此不受影响。</p>
<h3 id="进程命名空间"><a href="#进程命名空间" class="headerlink" title="进程命名空间"></a>进程命名空间</h3><p>Linux 通过进程命名空间管理进程号。对于同一个进程在不同的命名空间中，看到的进程号不同。每个进程命名空间有一套自己的进程号管理方法。进程命名空间是一个父子关系的结构，子空间的进程对于父空间是可见的。新 fork 出来的一个进程，在父命名空间和子命名空间将分别对应不同的进程号。</p>
<p>一般运行一个容器，以 docker run —name test -d ubuntu:18.04 sleep 9999 为例，相关进程关系如下：</p>
<p>docker 服务主进程 dockerd 作为父进程启动了 docker-containerd 进程，docker-containerd 作为父进程启动了 docker-containerd-shim，其作为容器内所有进程的根进程。</p>
<h3 id="IPC-命名空间"><a href="#IPC-命名空间" class="headerlink" title="IPC 命名空间"></a>IPC 命名空间</h3><p>容器内进程交互还是采用了 Linux 常见的进程间交互方法，包括信号量，消息队列和共享内存等方式.PID 命名空间和 IPC 命名空间可以组合起来使用，同一个 IPC 命名空间的进程可以交互，不同空间的进程则无法交互。</p>
<h3 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h3><p>有了进程命名空间，不同命名空间中的进程号可以相互隔离，但是网络端口还是共享本地系统的端口。通过网络命名空间，可以实现网络隔离。一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPV4 和 IPV6 协议栈，IP 路由表，防火墙规则，sockets 等。</p>
<p>docker 采用虚拟网络设备 Virtual Network Device VND 的方式，将不同命名空间的网络设备连接到一起。默认情况下，Docker 在宿主机上创建多个虚拟网桥，如默认的 docker0 网桥，容器中的虚拟网卡通过网桥进行桥接。</p>
<p>docker network ls 可以查看当前系统中的网桥。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker网桥.png" alt="docker网桥"></p>
<p>使用 brctl 工具，可以看到连接到网桥上的虚拟网口信息。每个容器默认分配一个网桥上的虚拟网口，并将 docker0 的 IP 地址设置为默认的网关。容器发起的网络流量通过 宿主机的 iptables 规则进行转发。</p>
<h4 id="虚拟网卡-veth"><a href="#虚拟网卡-veth" class="headerlink" title="虚拟网卡 veth"></a>虚拟网卡 veth</h4><p>这里参考了这篇文章 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/369e50201bce">Linux 网络命名空间</a>，下面简述一下其中的内容。</p>
<p>虚拟网卡成对出现，像一个管道的两端，从这个管道一端的 veth 进去的数会从另一端的 veth 出来，可以用 veth 接口把一个网络命名空间连接到外部的默认命名空间或者 global 命名空间，而物理网卡就存在这些命名空间里。</p>
<p>创建一个网络命名空间，默认包含 lo 回环网络。然后创建一对虚拟网卡，将其中一端 veth1 加入命名空间中，设置该命名空间中的路由，使得找不到目的地址的数据包都通过 veth1 转发。这时就可以 ping 通 host 上的 veth0 网卡了。但是依然不能连接外部网络。</p>
<p>Linux 中 IP 转发的意思是 Linux 主机存在多个网卡的时候，允许一个网卡的数据包转发到另外一张网卡。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.1.1.0/255.255.255.0 -o ens160 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>添加了一条规则到 NAT 表的 POSTROUTING 链中，对于源 IP 地址为 10.1.1.0 网段的数据包，用 ens160 网口的 IP 地址替换并发送。这样在容器中就可以访问外部网络了。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/整个流程.png" alt="整个流程"></p>
<h2 id="两个容器为什么能通信"><a href="#两个容器为什么能通信" class="headerlink" title="两个容器为什么能通信"></a>两个容器为什么能通信</h2><p>只要有容器运行，docker0 接口的状态就从 down 变成了 up。</p>
<p>主机上的 veth 只能和 docker0 通信。容器内的 veth 可以和主机上的配对的 veth 通信。</p>
<p>veth 成对出现，docker0 是多个容器之间能通信的关键。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker容器间通信.png" alt="docker容器间通信"></p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=test2 --link test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure>
<p>当于添加了 DNS 解析，同时 link 是单向的。只能在 test2 通过 test1 ping 通 test1。</p>
<h2 id="none-和-host-网络"><a href="#none-和-host-网络" class="headerlink" title="none 和 host 网络"></a>none 和 host 网络</h2><p>连接到 none 网络</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d test1 --network none busybox /bin/sh</span><br></pre></td></tr></table></figure>
<p>使用 none 模式，没有物理地址和 ip 地址，容器内只有 lo 回环网络，意味着容器不能被其他容器访问。</p>
<p>连接到 host 网络</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d test1 --network host busybox /bin/sh</span><br></pre></td></tr></table></figure>
<p>容器和外层 linux 共享一套网络接口</p>
<h2 id="数据持久化-data-volume"><a href="#数据持久化-data-volume" class="headerlink" title="数据持久化 data volume"></a>数据持久化 data volume</h2><p>在 docker 中，默认数据存储在 container layer，也就是容器层中，因为只有这一层是可读可写的。但这样如果容器关闭了，并且被删除了，数据也就被删除了。docker 为了解决这种问题，出现一种机制。就是把数据转移到外挂或者 mount 的磁盘上。例如把容器里数据，同步到外层 linux 主机磁盘上。这样即使容器被删除了，容器里面数据还是保留在 linux 主机上，下次我们再启动一个容器，配置读取外层 linux 这个外挂的文件系统中数据，这个容器恢复正常服务功能。</p>
<h2 id="VOLUME-的类型"><a href="#VOLUME-的类型" class="headerlink" title="VOLUME 的类型"></a>VOLUME 的类型</h2><p>有两种，第一种是受管理的 data Volume，由 docker 后台自动创建。第二种是绑定挂载的 Volume，具体挂载位置可以由用户指定。</p>
<h2 id="安全防护与配置"><a href="#安全防护与配置" class="headerlink" title="安全防护与配置"></a>安全防护与配置</h2><p>Docker 是基于 Linux 操作系统实现的应用虚拟化。运行在容器内的进程，与运行在本地系统的进程在本质上没有区别。Docker 容器的安全性，很大程度上依赖于 Linux 系统自身。在评估 Linux 安全性上，主要考虑一下几个方面</p>
<ul>
<li>Linux 内核的命名空间机制提供的容器隔离安全</li>
<li>Linux 控制组机制对容器资源的控制能力安全</li>
<li>Linux 内核的能力机制所带来的操作权限安全</li>
<li>Docker 程序本身的抗攻击性</li>
<li>其他安全增强机制对容器安全性的影响</li>
</ul>
<p>从网络架构上来看，所有的容器实际上是通过本地主机的网络接口 docker0 来进行相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>与虚拟机方式相比，通过命名空间来实现的隔离并不那个绝对，运行在容器中的应用可以直接访问系统内核和部分系统文件。因此用户必须保证容器中的应用是安全可信的。</p>
<p>控制组是 Linux 容器机制的另一个关键组件，它负责实现资源的审计和限制。当用户执行 docker run 启动一个 容器的时候，docker 将通过 Linux 相关的调用，在后台为容器创建一个独立的控制组策略集合，该集合将限制容器内应用对资源的消耗。</p>
<p>控制组提供了很多有用的特性，他可以确保各个容器公平地分享主机的内存，cpu，磁盘 IO 等资源，当然，更重要的是，通过控制组可以限制容器对资源的占用，确保了当某个容器对资源消耗过大时，不会影响到本地主机系统和其他容器。</p>
<p>Linux 内核自 2.2 版本起支持能力机制，将权限划分为更加细粒度的操作能力，默认情况下，Docker 启动的容器有严格限制，只允许使用内核的一部分能力。通常，在服务器上会运行一堆特权进程，包括 ssh，cron，syslogd 等，容器与这些进程是不同的，而容器大部分情况下不需要真正的 root 权限，为了加强安全，容器可以禁用一些没必要的权限，包括：</p>
<ul>
<li>完全禁止任何文件挂载操作</li>
<li>禁止直接访问本地主机的套接字</li>
<li>禁止访问一些文件系统的操作</li>
<li>禁止模块加载</li>
</ul>
<h2 id="高级网络功能"><a href="#高级网络功能" class="headerlink" title="高级网络功能"></a>高级网络功能</h2><h3 id="容器内-dns"><a href="#容器内-dns" class="headerlink" title="容器内 dns"></a>容器内 dns</h3><p>docker 服务启动后悔默认启用一个内嵌的 DNS 服务，来自动解析同一个网络中的容器主机名和地址，如果无法解析，则通过容器内的 DNS 相关配置来进行解析。</p>
<p>容器运行时，可以再运行中的容器直接编辑 /etc/hosts /etc/hostname /etc/resolve.conf 文件，但这种改动连 docker commit 也无法保存。</p>
<h3 id="容器访问外部的实现"><a href="#容器访问外部的实现" class="headerlink" title="容器访问外部的实现"></a>容器访问外部的实现</h3><p>假设容器内部的网络地址为 172.17.0.2，本地网络地址为 10.0.2.2。容器要能访问外部网络，需要进行源地址映射（Source NAT），修改为本地系统的 IP 地址 10.0.2.2。</p>
<p>映射是通过 iptables 的源地址伪装操作实现的。 主机 nat 表上的 POSTROUTING 链规则负责网包离开主机前，改写其源地址：</p>
<h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以再 docker run 时候通过 -p 或者 -P 参数来启用。其实也是在本地的 iptable 的 nat 表 中添加相应的规则，将访问外部 IP 地址的包进行目标地址 DNAT，将目标地址修改为容器的 IP 地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络学习笔记之数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 08:14:35" itemprop="dateCreated datePublished" datetime="2019-03-27T08:14:35+00:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">10.4k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">37(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>数据链路层属于计算机网络的底层，使用的信道主要有以下两种类型:</p>
<ul>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播信道。这种信道使用一对多的广播通信方式,因此过程比较复杂。广播信道上连接的主机很多,因此必须使用专用的共享信道协议来协调这些主机的数据发送。<br>本章主要内容是</li>
<li>数据链路层点对点和广播信道的特点，以及这两种信道使用的协议（PPP，CSMA/CD）的特点</li>
<li>数据链路层的三个基本问题：封装成帧，透明传输和差错检测</li>
<li>以太网 mac 层的硬件地址</li>
<li>适配器，转发器，集线器，王巧，以太网交换机的作用和使用场合</li>
</ul>
<h3 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><ul>
<li>链路(link)是一条无源的点到点的物理线路段,中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li>
<li>数据链路(data link) 除了物理线路外,还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上,就构成了数据链路。现在最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/传送帧.png" alt="传送帧"></li>
<li>点对点通信在数据链路层的主要步骤<br><em> 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧
</em> 结点 A 把封装好的帧发给结点 B 的数据链路层 * 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层，否则丢弃该帧<br>数据链路层不考虑物理层之间如何实现比特传输的细节</li>
</ul>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部,然后就构成了一个帧。确定帧的界限。</li>
<li>首部和尾部的一个重要作用就是进行帧定界。</li>
<li>MTU Maximum Transfer Unit 最大传输单元</li>
<li>当数据是可打印的 ASCII 码组成的文本文件时，可以用特殊的帧定界符。控制字符 SOH（start of header）和 EOT （end of transmission），十六进制编码分别为 01 和 04</li>
</ul>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><ul>
<li>由于帧开始和结束使用了专门制定的控制字符，因此，所传输的数据中任何 8 比特的组合一定不允许和帧定界的控制字符的比特编码一样当传输的帧是用文本文件组成的帧时，这种方式没有问题，不用管传送的是什么字符，这种传输就是透明传输。但是当传送的是非 ASCII 的文本文件时，数据中可能会出现恰好和 SOH 和 EOT 一样的二进制数据。</li>
<li>如何解决<ul>
<li>字节填充法<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现数据当中,那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时,就删除其中前面的一个。</li>
<li>字符计数法<br>这种方法是在帧头部中使用一个字符计数字段来标明帧内字符数。例如,发送序列“5 A B C D E 4 U V W X 7 1 2 3 4 4 5 8”表示一共有三个帧,三个帧的长度分别为 5 字节、4 字节和 7 字节。但是这种方法很容易出现定界错误。假如计数值出现传输差错,接收端收到的序列为“5 A B C D E 6 U V W X 7 1 2 3 4 4 5 8”时,则接收端会将第二帧解释为“6 U V W X 7 1”,从而导致因发收双方对帧大小和内容理解不一致而出错。</li>
<li>带字符填充的首尾界符法<br>这种方法是在每一帧的开头加上 ASCII 字符“DLESTX” ,在帧末尾加上 ASCII 字符“DLE ETX” 。例如,假设待发送的数据是 ADLECB ,则在数据链路层封装的帧为:DLE STX ADLECB DLE ETX 如果发送方在数据帧中遇到帧头或者帧尾字符,就采用字符填充法来处理。例如,数据帧有 DLE 字符,就在其前面加一个 DLE。<br>DLE STX A DLE DLE CB DLE ETX</li>
<li>带位填充的首尾标志法(零比特填充法)<br>这种方法是用一个特殊的位模式“01111110”作为帧边界。数据中可能包含“01111110”数据,如何判断?采用零比特填充法使一帧中两个边界字段之间的数据不会出现 6 个连续 1。在发送端,当一串比特流数据中有 5 个连续 1 时,就立即填入一个 0。如此保证数据部分不会出现 6 个连续的 1 在接收帧时,先找到边界字段以确定帧的边界。接着再对比特流进行扫描。每当发现 5 个连续 1 时,就将其后的一个 0 删除,以还原成原来的比特流。</li>
<li>物理层编码违例法<br>物理层编码违例法就是利用物理层信息编码中未用的电信号来作为帧的边界。例如,用曼彻斯特编码,在传输之前,将数据位 1 编码成高-低电平对,数据位 0 编码成低-高电平对。那么高-高电平、低-低电平就可以用作帧的边界。</li>
</ul>
</li>
</ul>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><ul>
<li>误码率 传输错误比特占传输总比特数的比率称为误码率</li>
</ul>
<h5 id="循环冗余检测-CRC"><a href="#循环冗余检测-CRC" class="headerlink" title="循环冗余检测 CRC"></a>循环冗余检测 CRC</h5><ul>
<li>在数据链路层传送的帧中,广泛使用了循环冗余检验 CRC 的检错技术。 在发送端,先把数据划分为组。假定每组 k 个比特。假设待传送的一组数据 M = 101001(现在 k = 6)。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</li>
<li>用二进制的模 2 运算进行 2n 乘 M 的运算,这相当于在 M 后面添加 n 个 0。</li>
<li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P,得出商是 Q 而余数是 R,余数 R 比除数 P 少 1 位,即 R 是 n 位。</li>
<li>模 2 运算是不进位也不借位的运算，在这里等同于异或运算，即有当前位就可以得到该位运算的结果</li>
<li>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。循环冗余检验 CRC 和帧检验序列 FCS 并不等同。CRC 是一种常用的检错方法,而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出,但 CRC 并非用来获得 FCS 的唯一方法。</li>
<li>若得出的余数 R = 0,则判定这个帧没有差错,就接受(accept)。 若余数 R != 0,则判定这个帧有差错,就丢弃。但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。只要经过严格的挑选,并使用位数足够多的除数 P,那么出现检测不到的差错的概率就很小很小。</li>
</ul>
<h5 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h5><p><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/汉明码原理.png" alt="汉明码原理"><br>汉明码(Hamming Code)编码的关键是使用多余的奇偶校验位来识别一位错误。假设信息码共有 n 位,海明码共有 h 位,那么总共的码长为 n + h 位。为能检测出 n + h 位编码，中其中一位的错误,海明码必须能够表示至少 n + h + 1 种状态,其中 n + h 种表示 n + h 位编码中有一位错误,另外还需要 1 种来表示整个编码正确无误。则海明码的长度需要满足下列关系:</p>
<script type="math/tex; mode=display">2^h >= n + h + 1</script><p>把所有 2 的幂次方的数据位标记为奇偶校验位(编号为 1, 2, 4, 8, 16, 32, 64 等的位置)<br>其他数据位用于待编码数据. (编号为 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17 等的位置)<br>每个奇偶校验位的值代表了码字中部分数据位的奇偶性,其所在位置决定了要校验的比特位。<br>位置 1，校验所有二进制最后一位是 1 的位置<br>位置 2，校验所有二进制倒数第二位是 1 的位置<br>位置 4，校验所有二进制倒数第三位是 1 的位置<br>配偶是该位置的数值加上是其要效验的位置和为偶数，可以用异或运算计算。<br>配奇则正好相反。<br>如何得到是哪一位出错了呢？以配偶方式为例，求冗余码的效验和，假设 分别为 1 1 0 0 。正常效验和应当为 0，为 1 说明该位置效验的比特位有一位出现了错误。因此倒数第一位和倒数第二位为 1 的都为 1 的位置出现了错误，这可以唯一确定一个位置，即数据的第三位。</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>在不可靠的信道上实现可靠的数据传输为上层提供一条可靠的逻辑通道。CRC 循环冗余检测只能保证无比特差错，但是可能会出现帧丢失，帧失序等，无法做到无传输差错。</p>
<h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><ul>
<li>在发送完一个帧后,必须暂时保留已发送的帧的副本。数据帧和确认帧都必须进行编号。只要超过了一段时间还没有收到确认,就认为已发送的帧出错或丢失了,因而重传已发送过的帧。这就叫做超时重传。<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
<li>使用上述的确认和重传机制,我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li>
<li>RTT (Round Trip)</li>
<li>停止等待协议不适合发送时延远远小于往返时延的情况</li>
<li>停止等待协议的优点是简单,但缺点是信道利用率低。发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送,这种传输方式可获得很高的信道利用率,<br>这种方式是<strong>流水线传输</strong></li>
</ul>
<h5 id="回退-N-帧"><a href="#回退-N-帧" class="headerlink" title="回退 N 帧"></a>回退 N 帧</h5><ul>
<li>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N(回退 N),表示需要再退回来重传已发送过的 N 个分组。</li>
<li>GBN 协议的接受窗口大小为 1，当收到序号错误的分组，接收方除了丢弃他们，还对最近按序接受的分组进行确认</li>
<li>接收方采用累积确认的方式，对分组 n 的确认，表明接收方已经正确收到分组 n 和之前所有的分组</li>
<li>GBN 协议存在一个缺点:一个分组的差错可能引起大量分组的重传,这些分组可能已经被接收方正确接收了,但由于未按序到达而被丢弃。可设法只重传出现差错的分组。但必须加大接收窗口,以便先收下<br>失序到达但仍然处在接收窗口中的哪些分组,等到所缺分组收齐后再一并送交上层。这就是选择重传 SR(Selective Repeat)协议。</li>
</ul>
<h5 id="数据链路层的可靠传输"><a href="#数据链路层的可靠传输" class="headerlink" title="数据链路层的可靠传输"></a>数据链路层的可靠传输</h5><ul>
<li>实现可靠传输需要付出代价(例如会降低传输效率)。因此,应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。当链路误码率非常低时,在数据链路层可不实现可靠传输,而是由上层协议(例如,<br>运输层的 TCP 协议)来完成。但是在使用无线信道传输数据时,由于信道质量较差,在数据链路层仍需要实现可靠传输(例如使用停止等待协议)。</li>
</ul>
<h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><ul>
<li>现在全世界使用得最多的点对点数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。用户使用拨号电话线接入因特网时,一般都是使用 PPP 协议。</li>
<li>PPP 协议的特点<ul>
<li>简单——这是首要的要求</li>
<li>封装成帧</li>
<li>透明性</li>
<li>多种网络层协议</li>
<li>多种类型链路</li>
<li>差错检测</li>
<li>检测连接状态</li>
</ul>
</li>
<li>PPP 协议的组成<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP (Link Control Protocol)。</li>
<li>网络控制协议 NCP (Network Control Protocol)。</li>
</ul>
</li>
<li>PPP 协议的帧格式<br>标志字段 F = 0x7E (符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110)。地址字段 A 只置为 0xFF。地址字段实际上并不起作用。控制字段 C 通常置为 0x03。PPP 是面向字节的,所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP 协议字段<br>当协议字段为 0x0021 时,PPP 帧的信息字段就是 IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021,则表示这是网络控制数据。</li>
<li>透明传输问题<br>当 PPP 用在同步传输链路时,协议规定采用硬件来完成比特填充(和 HDLC 的做法一样)。当 PPP 用在异步传输时,就使用一种特殊的字符填充法。</li>
<li>PPP 的工作状态<br>当用户拨号接入 ISP 时,路由器的调制解调器对拨号做出确认,并建立一条物理连接。PC 机向路由器发送一系列的 LCP 分组(封装成多个 PPP 帧)。这些分组及其响应选择一些 PPP 参数,和进行网络层配置,NCP 给新接入的 PC 机分配一个临时的 IP 地址,使 PC 机成为因特网上的一个主机。通信完毕时,NCP 释放网络层连接,收回原来分配出去的 IP 地址。接着,LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul>
<li>广播信道可以进行一对多的通信,能很方便且廉价地连接多个邻近的计算机,因此曾经被广泛应用于局域网之中。由于用广播信道连接的计算机共享同一传输媒体,因此使用广播信道的局域网被称为共享式局域网。<br>虽然交换式局域网在有线领域已完全取代了共享式局域网,但无线局域网仍然使用的是共享媒体技术。</li>
</ul>
<h4 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h4><p>媒体访问/接入控制(MAC) Medium Access Control 多点接入、多址访问(Multiple Access)</p>
<ul>
<li>静态划分信道<br>频分多址，码分多址和时分多址，这种固定划分信道的方法很不灵活，对于突发性信道的传输利用率很低，通常在无线网络的物理层使用，而不是在数据链路层中使用。</li>
<li>动态接入控制<br>各站点动态占用信道发送数据，而不是使用预先固定分配好的信道<ul>
<li>随机接入<br>通过所有站点之间的竞争，随机地在信道上发送数据，如果恰巧有两个或者更多的站点在同意时刻发送数据，那么信号在共享媒体上就要发生碰撞，使得这些站点的发送都失败，因此这类协议要解决的关键问题是如何避免冲突以及在发生冲突后如何尽快恢复通信。共享式以太网采用的就是随机接入。</li>
<li>受控接入<br>不能随机的发送信息而必须服从一定的控制，典型代表有集中控制的多点轮询协议和分散的令牌传递协议。集中控制的多点轮训协议有一个主站以循环方式轮询每个站点有无数据发送，只有被轮询到的站点才能发送数据，分散控制的令牌传递协议中各站点是平等的，并连接成一个唤醒网络，令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据。</li>
</ul>
</li>
</ul>
<h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul>
<li>局域网的拓扑有星形网，环形网，总线网，树形网。总线网和树形网用总线两端的匹配电阻消除总线上传播的电磁波信号的能量</li>
</ul>
<h5 id="局域网体系结构"><a href="#局域网体系结构" class="headerlink" title="局域网体系结构"></a>局域网体系结构</h5><ul>
<li>IEEE 802 委员会将局域网的数据链路层拆成了两个子层，即逻辑链路控制 (Logical Link Control) 和 媒体接入控制 (Medium Access Control MAC) 子层。与接入到传输媒体有关的内容都放在 MAC 子层，而 LLC 子层与传输媒体无关，不管采用何种传输媒体和 MAC 子层的局域网，对 LLC 子层来说都是透明的。然而由于以太网在局域网中已经取得了垄断地位，LLC(802.2 标准)已经不再重要。</li>
</ul>
<h5 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h5><ul>
<li>网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (NetworkInterface Card),或“网卡”。</li>
<li>适配器的重要功能:<ul>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。</li>
</ul>
</li>
</ul>
<h5 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h5><ul>
<li>在局域网中,硬件地址又称为物理地址,或 MAC 地址。802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。但鉴于大家都早已习惯了将这种 48 位的“名字”称为“地址”,所以本书也采用这种习惯用法,尽管这种说法并不太严格。</li>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24 位)由厂家自行指派,称为扩展标识符,必须保证生产出的适配器没有重复地址。一个地址块可以生成$2^24$个不同的地址。这种 48 位地址称为 MAC-48,它的通用名称是 EUI-48。“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</li>
<li>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.<br>如果是发往本站的帧则收下,然后再进行其他的处理。<br>否则就将此帧丢弃,不再进行其他的处理。</li>
<li>“发往本站的帧”包括以下三种帧:<br>单播(unicast)帧(一对一)<br>广播(broadcast)帧(一对全体)<br>多播(multicast)帧(一对多)</li>
</ul>
<h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><ul>
<li>以太网的两个标准<br>DIX Ethernet V2。<br>IEEE 的 802.3 标准。<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别,因此可以将 802.3 局域网简称为“以太网”。严格说来,“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</li>
</ul>
<h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA CD 协议"></a>CSMA CD 协议</h4><ul>
<li>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致,因此只有 D 才接收这个数据帧。其他所有的计算机(A, C 和 E)都检测到不是发送给它们的数据帧,因此就丢弃这个数据帧而不能够收下来。具有广播特性的总线上实现了一对一的通信。</li>
<li>采用较为灵活的无连接的工作方式,即不必先建立连接就可以直接发送数据。以太网对发送的数据帧不进行编号,也不要求对方发回确认。 这样做的理由是局域网信道的质量很好,因信道质量产生差错的概率是很<br>小的。</li>
<li>以太网提供的服务是不可靠的交付,即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧,其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传,但以太网并不知道这是一个重传的帧,而是当作一个新的数据帧来发送。</li>
<li>以太网发送数据都使用曼彻斯特编码</li>
<li>CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。<ul>
<li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据,如果有,则暂时不要发送数据,以免发生碰撞。</li>
<li>总线上并没有什么“载波”。因此, “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时,总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。在发生碰撞时,总线上传输的信号产生了严重的失真,无法从中恢复出有用的信息来。每一个正在发送数据的站,一旦发现总线上出现了碰撞,就要立即停止发送,免得继续浪费网络资源,然后等待一段随机时间后再次发送。</li>
<li>关于如何检测信道空闲，站点会持续监听到达该站的信号，如果检测到信号包含数据，则说明在这一段时间内信道不是空闲的</li>
<li>当某个站监听到总线是空闲时,也可能总线并非真正是空闲的。A 向 B 发出的信息,要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息),则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</li>
<li>最先发送数据帧的站,在发送数据帧后至多经过时间 2r (两倍的端到端往返时延)就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2r 称为争用期,或碰撞窗口。经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞。</li>
</ul>
</li>
<li>以太网取 51.2 us 为争用期的长度。对于 10 Mb/s 以太网,在争用期内可发送 512 bit,即 64 字节。以太网在发送数据时,若前 64 字节没有发生冲突,则后续的数据就不会发生冲突。</li>
<li>为保证发送方能检测到所有碰撞,以太网规定了最短有效帧长为 64 字节。如果发生冲突,就一定是在发送的前 64 字节之内,立即中止发送,这时已经发送出去的数据一定小于 64 字节。因此将长度小于 64 字节的帧都视为是由于冲突而异常中止的无效帧。</li>
<li>当发送数据的站一旦发现发生了碰撞时: 立即停止发送数据;再继续发送若干比特的人为干扰信号(jamming signal),以便让所有站点都知道现在已经发生了碰撞。</li>
<li>帧间最小间隔 96 比特时间，站点在发送数据帧之前要等待信道空闲 96 比特时间，这样用于接收方检测一个帧的结束，同时也使得其他所有站点都能有机会争用信道并发送数据</li>
<li>CSMA/CD 的要点如下<ul>
<li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送</li>
<li>若适配器检测到信道空闲 96 比特时间，就发送这个帧。若检测到信道忙，则继续检测并等待信道转换为空闲 96 比特时间，然后发送这个帧</li>
<li>在发送过程中继续检测，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则终止数据的发送，并认为发送干扰信号</li>
<li>在终止发送后，适配器就执行指数退避算法，随机等待 r 倍的 512 比特时间后，返回到步骤 2</li>
</ul>
</li>
</ul>
<h5 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h5><p>go 语言的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRandomRate</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    <span class="keyword">return</span> random.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resend</span><span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    index := k</span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">10</span> &#123;</span><br><span class="line">        index = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    upperBound := <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(index)</span><br><span class="line">    r := random.Intn(upperBound)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d次重传 本次退避 51.2 * %d us\n&quot;</span>, k, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tbeb</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> failRate <span class="keyword">int</span></span><br><span class="line">    k := <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入碰撞几率 0-100&quot;</span>)</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;failRate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> getRandomRate() &lt; failRate &#123;</span><br><span class="line">            k++</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">16</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;重传已经达到16次，丢弃该帧，向上层报告&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;发生碰撞，准备重传&quot;</span>)</span><br><span class="line">            resend(k)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;传送成功，共传输%d次\n&quot;</span>, k)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tbeb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第ｋ次重传，选择 $[0,2^k-1]$中的一个随机数作为倍数，将 2r 乘以该倍数作为退避时间</p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><script type="math/tex; mode=display">a = \frac{r}{t_0}</script><p>其中 2r 是争用期长，即端到端传播时延的两倍，帧长为 L，数据发送速率为 C，$t_0=\frac{L}{C}$是帧发送时间，当 a 趋近于 0 时，表示一发生碰撞就可以检测出来，a 越大，信道利用率越低。</p>
<ul>
<li>当网络覆盖范围越大,既端到端时延越大,信道极限利用率越低,即网络性能越差。另外,端到端时延越大或连接的站点越多,都会导致发生冲突的概率变大,网络性能还会进一步降低。可见,共享式以太网只能作为一种局域网技术。</li>
</ul>
<h4 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h4><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><ul>
<li>集线器是使用电子器件来模拟实际电缆线的工作,因此整个系统仍然像一个传统的以太网那样运行。</li>
<li>使用集线器的以太网在逻辑上仍是一个总线网,各工作站使用的还是 CSMA/CD 协议,并共享逻辑上的总线。</li>
<li>集线器很像一个多接口的转发器,工作在物理层。</li>
</ul>
<h4 id="以太网的帧格式"><a href="#以太网的帧格式" class="headerlink" title="以太网的帧格式"></a>以太网的帧格式</h4><ul>
<li>常用的以太网 MAC 帧格式有两种标准 :<ul>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ul>
</li>
<li>最常用的 MAC 帧是以太网 V2 的格式。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网的帧格式.png" alt="以太网的帧格式"><br><em> 源地址和目的地址的地址指的是 MAC 地址
</em> 类型字段用来表示上层协议的类型<br><em> FCS 是帧检验学列
</em> 如果数据字段的长度小于 46 字节，MAC 子层就会在数据字段的最后加入一个整数字节的填充字段</li>
<li>因为以太网在传输帧的时候，各个帧之间必须有一定的间隙，因此不需要使用帧结束定界符</li>
<li>无效的 MAC 帧<ul>
<li>数据字段的长度与长度字段的值不一致;</li>
<li>帧的长度不是整数个字节;</li>
<li>用收到的帧检验序列 FCS 查出有差错;</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
<li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</li>
</ul>
</li>
</ul>
<h3 id="网桥和以太网交换机"><a href="#网桥和以太网交换机" class="headerlink" title="网桥和以太网交换机"></a>网桥和以太网交换机</h3><h4 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h4><ul>
<li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了局域网覆盖的地理范围。</li>
<li>碰撞域增大了,但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率,那么就不能用集线器将它们互连起<br>来。</li>
<li>由于争用期的限制,并不能无限扩大地理覆盖范围</li>
</ul>
<h4 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h4><ul>
<li>在数据链路层扩展以太网要使用网桥。</li>
<li>网桥工作在数据链路层,它根据 MAC 帧的目的地址对收到的帧进行转发。</li>
<li>网桥具有过滤帧的功能。当网桥收到一个帧时,并不是向所有的接口转发此帧,而是先检查此帧的目的 MAC 地址,然后再确定将该帧转发到哪一个接口</li>
</ul>
<h5 id="使用网桥的好处"><a href="#使用网桥的好处" class="headerlink" title="使用网桥的好处"></a>使用网桥的好处</h5><ul>
<li>过滤通信量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>(由于采用存储转发方式)可互连不同物理层、不同 MAC 子层和不同速率(如 10 Mb/s 和<br>100 Mb/s 以太网)的局域网。</li>
</ul>
<h5 id="使用网桥的缺点"><a href="#使用网桥的缺点" class="headerlink" title="使用网桥的缺点"></a>使用网桥的缺点</h5><ul>
<li>存储转发增加了时延。</li>
<li>在 MAC 子层并没有流量控制功能。</li>
<li>具有不同 MAC 子层的网段桥接在一起时时延更大。</li>
<li>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网,</li>
<li>否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的</li>
<li>广播风暴。</li>
</ul>
<h5 id="网桥和集线器-或转发器-不同"><a href="#网桥和集线器-或转发器-不同" class="headerlink" title="网桥和集线器(或转发器)不同"></a>网桥和集线器(或转发器)不同</h5><ul>
<li>集线器在转发帧时,不对传输媒体进行检测。</li>
<li>网桥在转发帧之前必须执行 CSMA/CD 算法。若在发送过程中出现碰撞,就必须停止发送和进行退避。</li>
</ul>
<h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><ul>
<li>目前使用得最多的网桥是透明网桥(transparent bridge)。“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥,因为网<br>桥对各站来说是看不见的。</li>
<li>透明网桥是一种即插即用设备,其标准是 IEEE 802.1D。</li>
</ul>
<h5 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h5><p>go 语言实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">    port    <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Iptable <span class="keyword">struct</span> &#123;</span><br><span class="line">    records []Record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iptable Iptable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTable</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        <span class="keyword">if</span> record.address == address &#123;</span><br><span class="line">            <span class="keyword">return</span> record.port, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err := errors.New(<span class="string">&quot;没找到记录&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeRecord</span><span class="params">(address <span class="keyword">string</span>, port <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    iptable.records = <span class="built_in">append</span>(iptable.records, Record&#123;port, address&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id  address               port\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%-3d %-20s %-5d\n&quot;</span>, index, record.address, record.port)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> srcAddress, destAddress <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> srcPort <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入源地址和端口号&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>, &amp;srcAddress, &amp;srcPort)</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入目的地址&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;destAddress)</span><br><span class="line">        destPort, err := findTable(destAddress)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中未找到记录&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;从其他端口将此帧转发给别的网桥&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中找到记录&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> srcPort == destPort &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;目的地址和源地址在同一网段，目的主机已经收到&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;将此帧从查找到的端口发出 %d\n&quot;</span>, destPort)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printTable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有,就在转发表中增加一个项目(源地址、进入的接口和时间)。如有,则把原有的项目进行更新。</li>
<li>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<ul>
<li>如没有,则通过所有其他接口(但进入网桥的接口除外)按进行转发。</li>
<li>如有,则按转发表中给出的接口进行转发。</li>
<li>若转发表中给出的接口就是该帧进入网桥的接口,则应丢弃这个帧(因为这时不需要经过网桥进行转发)。</li>
</ul>
</li>
</ul>
<h5 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h5><ul>
<li>互连在一起的网桥在进行彼此通信后,就能找出原来的网络拓扑的一个子集。在这个子集里,整个连通的网络中不存在回路,即在任何两个站之间只有一条路径。</li>
<li>网桥会关闭不在生成树上的那些接口,以确保不存在环路。</li>
<li>为了得出能够反映网络拓扑发生变化时的生成树,在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</li>
</ul>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><ul>
<li>透明网桥容易安装,但网络资源的利用不充分。</li>
<li>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。源站以广播方式向欲通信的目的站发送一个发现帧,每个发现帧都记录所经过的路由。</li>
<li>发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后,从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部,都必须携带源站所确定的这一路由信息。</li>
</ul>
<h5 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h5><ul>
<li>1990 年问世的交换式集线器(switching hub),可明显地提高局域网的性能。</li>
<li>交换式集线器常称为以太网交换机(switch)或第二层交换机(表明此交换机工作在数据链路层)。</li>
<li>以太网交换机通常都有十几个接口。因此,以太网交换机实质上就是一个多接口的网桥,可见交换机工作在数据链路层。</li>
</ul>
<h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><ul>
<li>以太网交换机的每个接口都直接与主机相连,并且一般都工作在全双工方式。</li>
<li>交换机能同时连通许多对的接口,使每一对相互通信的主机都能像独占通信媒体那样,进行无碰撞地传输数据。</li>
<li>以太网交换机由于使用了专用的交换结构芯片,其交换速率较高。</li>
</ul>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><h4 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h4><ul>
<li>无线局域网不能简单地搬用 CSMA/CD 协议。这里主要有两个原因。对于无线信道,接收信号强度往往会远远小于发送信号强度。如要在无线局域网的适配器上实现碰撞检测,对硬件的要求非常高。。</li>
<li>即使我们能够实现碰撞检测的功能,并且当我们在发送数据时检测到信道是空闲的,在接收端仍然有可能发生碰撞(隐蔽站问题)。</li>
<li>无线局域网不能使用 CSMA/CD,而只能使用改进的 CSMA 协议。</li>
<li>改进的办法是把 CSMA 增加一个碰撞避免(Collision Avoidance)功能。</li>
<li>802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时,还增加使用停止等待协议。</li>
<li>下面先介绍 802.11 的 MAC 层。</li>
<li>所有的站在完成发送后,必须再等待一段很短的时间(继续监听)才能发送下一帧。这段时间的通称是帧间间隔 IFS (InterFrame Space)。</li>
<li>帧间间隔长度取决于该站欲发送的帧的类型。高优先级帧需要等待的时间较短,因此可优先获得发送权。</li>
<li>若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>
</ul>
<h5 id="三种帧间间隔"><a href="#三种帧间间隔" class="headerlink" title="三种帧间间隔"></a>三种帧间间隔</h5><ul>
<li>SIFS,即短(Short)帧间间隔,是最短的帧间间隔,用来分隔开属于一次对话的各帧。一个站应当能够在这段时间内从发送方式切换到接收方式。</li>
<li>使用 SIFS 的帧类型有:ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧,以及所有回答 AP 探询的帧<br>和在 PCF 方式中接入点 AP 发送出的任何帧。</li>
<li>PIFS,即点协调功能帧间间隔,它比 SIFS 长,是为了在开始使用 PCF 方式时(在 PCF 方式下使用,没有争用)优先获得接入到媒体中。PIFS 的长度是 SIFS 加一个时隙(slot)长度。</li>
<li>时隙的长度是这样确定的:在一个基本服务集 BSS 内当某个站在一个时隙开始时接入到媒体时,那么在下一个时隙开始时,其他站就都能检测出信道已转变为忙态。</li>
<li>DIFS,即分布协调功能帧间间隔(最长的 IFS),在 DCF 方式中用来发送数据帧和管理帧。DIFS 的长度比 PIFS 再增加一个时隙长度。</li>
<li>欲发送数据的站先检测信道。在 802.11 标准中规定了在物理层的空中接口进行物理层的载波监听。</li>
<li>通过收到的相对信号强度是否超过一定的门限数值就可判定是否有其他的移动站在信道上发送数据。</li>
<li>当源站发送它的第一个 MAC 帧时,若检测到信道空闲,则在等待一段时间 DIFS 后就可发送。</li>
<li>为什么信道空闲还要再等待？这是考虑到可能有其他的站有高优先级的帧要发送。如有,就要让高优先级帧先发送。</li>
</ul>
<h5 id="高优先级帧发送"><a href="#高优先级帧发送" class="headerlink" title="高优先级帧发送"></a>高优先级帧发送</h5><ul>
<li>源站发送了自己的数据帧。</li>
<li>目的站若正确收到此帧,则经过时间间隔 SIFS 后,向源站发送确认帧 ACK。</li>
<li>若源站在规定时间内没有收到确认帧 ACK(可能是发生碰撞),就必须重传此帧,直到收到确认为止,或者经过若干次的重传失败后放弃发送。</li>
<li>确认机制可以认为是一种间接碰撞检测 。</li>
</ul>
<h6 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h6><ul>
<li>为避免碰撞,如果要发送数据的站发现信道忙, 在信道恢复空闲时并不是立即发送数据,而是要退避一段随机的时间(大于 DIFS)若信道仍然空闲才能发送数据</li>
<li>若发送方接收到确认要立即发送下一帧时,为公平竞争,也要执行退避</li>
<li>当发送方没有接收到确认,重传帧时,要将随机选择退避时间的范围扩大一倍。</li>
</ul>
<h5 id="退避计时器"><a href="#退避计时器" class="headerlink" title="退避计时器"></a>退避计时器</h5><ul>
<li>站点每经历一个时隙的时间就检测一次信道。这可能发生两种情况。</li>
<li>若检测到信道空闲,退避计时器就继续倒计时。</li>
<li>若检测到信道忙,就冻结退避计时器的剩余时间,重新等待信道变为空闲并再经过时间 DIFS 后,从剩余时间开始继续倒计时。如果退避计时器的时间减小到零时,就开始发送整个数据帧。</li>
</ul>
<h5 id="退避算法的使用"><a href="#退避算法的使用" class="headerlink" title="退避算法的使用"></a>退避算法的使用</h5><ul>
<li>仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是要发送的第一个数据帧。<br>除此以外的所有情况,都必须使用退避算法。即:<ul>
<li>在发送第一个帧之前检测到信道处于忙态。</li>
<li>在每一次的重传后。</li>
<li>在每一次的成功发送后。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11退避机制.png" alt="802.11退避机制"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/24/%E7%AE%97%E6%B3%95/leetcodeP10-RegularExpressionMatching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/24/%E7%AE%97%E6%B3%95/leetcodeP10-RegularExpressionMatching/" class="post-title-link" itemprop="url">leetcodeP10-RegularExpressionMatching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-24 00:18:24" itemprop="dateCreated datePublished" datetime="2019-03-24T00:18:24+00:00">2019-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">543(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">2(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一题最开始想到模拟，也想到了匹配的贪婪问题，感觉题目可能不要求那么多，结果是 WA，看到讨论区 PO 出的一份代码，使用了动态规划，想了一下确实改用 DP，此题确有一定难度，在此记录一下解法。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s 和字符串 p，s 只包含英文小写字母，p 只包含英文小写字母和 ‘.’ 或 ‘*‘，实现一个支持元字符 ‘.’ 和 ‘*‘的正则匹配</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设 dp[x][y]表示取字符串 s 前 x 个字符和模式串 p 前 y 个字符是否能够完全匹配，为一个 bool 值<br>初始状态 dp[0][0] = true，若 p 串以”a*b*c*“的形式开头，则 dp[0][2],dp[0][4],dp[0][6]也为 true，显示这种状态是匹配的<br>dp 的转移过程为<br>若 s[i-1] == p[j-1] || p[j-1] == ‘.’，dp[i][j] = dp[i][j] || dp[i-1][j-1]<br>若 p[j-1] == ‘*‘ ，方程至多可从一下三种状态转移</p>
<ul>
<li>dp[i][j] = dp[i][j] || dp[i][j-2]，*可以匹配 0 个多个，因此总可以从该状态转移</li>
<li>若 s[i-1] == p[j-2] || int(p[j-2]) == ‘.’，即匹配 “?*“形式，可采用贪婪与非贪婪策略<ul>
<li>dp[i][j] = dp[i][j] || dp[i-1][j] ，采用非贪婪策略，*不匹配字符</li>
<li>dp[i][j] = dp[i][j] || dp[i][j-1]，采用贪婪策略，*匹配字符</li>
</ul>
</li>
</ul>
<p>以下是代码，参考了 leetcode 上的题解</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lens := <span class="built_in">len</span>(s)</span><br><span class="line">    lenp := <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">var</span> dp [][]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= lens; i++ &#123;</span><br><span class="line">        d := <span class="built_in">make</span>([]<span class="keyword">bool</span>, lenp+<span class="number">1</span>)</span><br><span class="line">        dp = <span class="built_in">append</span>(dp, d)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= lenp; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= lens; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= lenp; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i][j<span class="number">-2</span>]</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || <span class="keyword">int</span>(p[j<span class="number">-2</span>]) == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lens][lenp]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Mongodb%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Mongodb%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Mongodb入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-14 01:36:04" itemprop="dateCreated datePublished" datetime="2019-03-14T01:36:04+00:00">2019-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">3.8k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">15(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>跟着官方文档学习</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>db 显示当前数据库</p>
<h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">item</span>: <span class="string">&quot;journal&quot;</span>,</span><br><span class="line">    <span class="attr">qty</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="attr">size</span>: &#123; <span class="attr">h</span>: <span class="number">14</span>, <span class="attr">w</span>: <span class="number">21</span>, <span class="attr">uom</span>: <span class="string">&quot;cm&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&quot;blank&quot;</span>, <span class="string">&quot;red&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">item</span>: <span class="string">&quot;notebook&quot;</span>,</span><br><span class="line">    <span class="attr">qty</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="attr">size</span>: &#123; <span class="attr">h</span>: <span class="number">8.5</span>, <span class="attr">w</span>: <span class="number">11</span>, <span class="attr">uom</span>: <span class="string">&quot;in&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>美化查询结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find(&#123;&#125;).pretty();</span><br></pre></td></tr></table></figure>
<h3 id="相等匹配"><a href="#相等匹配" class="headerlink" title="相等匹配"></a>相等匹配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find(&#123; <span class="attr">status</span>: <span class="string">&quot;D&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>对于数组，严格相等，数组项的顺序也要一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不匹配 &#123; tags: [&quot;blank&quot;, &quot;red&quot;] &#125;</span></span><br><span class="line">db.inventory.find(&#123; <span class="attr">tags</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>] &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="定义返回结构-Projection"><a href="#定义返回结构-Projection" class="headerlink" title="定义返回结构 Projection"></a>定义返回结构 Projection</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.find( &#123; &#125;, &#123; item: 1, status: 1 &#125; );</span><br></pre></td></tr></table></figure>
<p>默认全是 0 或者全是 1，不能既有 0 又有 1</p>
<h2 id="database-and-collections"><a href="#database-and-collections" class="headerlink" title="database and collections"></a>database and collections</h2><p>MongoDB 在集合中存储 BSON 文档，即数据记录;数据库中的集合。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>可以 使用 use 去切换到一个不存在的数据库</p>
<p>如果数据库不存在，MongoDB 将在您第一次为该数据库存储数据时创建数据库。</p>
<p>MongoDB 将文档存储在集合中。集合类似于关系数据库中的表。</p>
<p>如果一个集合不存在，MongoDB 会在您第一次存储该集合的数据时创建该集合。</p>
<h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><p>ObjectId 是一个 12 字节的 BSON 类型字符串。按照字节顺序，依次代表：</p>
<ul>
<li>4 字节 UNIX 时间戳</li>
<li>3 字节 运行 MongoDB 的机器</li>
<li>2 字节 代表生成次 id 的进程</li>
<li>3 字节 由一个随机数开始的的计数器生成的值</li>
</ul>
<p>使用这种机制可以保证唯一性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.myNewCollection2.insertOne(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br><span class="line">db.myNewCollection3.createIndex(&#123; <span class="attr">y</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>如果 insertOne()和 createIndex()操作还不存在，那么它们将创建各自的集合。确保集合名称遵循 MongoDB 命名限制。</p>
<p>db.createCollection() 可以显式以指定的选项创建一个数据库</p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view 是一个可查询的对象，由其他集合或者视图聚合产生。</p>
<p>MongoDB 并不在硬盘中保存 view，而是在需要的时候进行计算。view 不支持写操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(</span><br><span class="line">  <span class="string">&quot;&lt;viewName&gt;&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;viewOn&quot;</span> : <span class="string">&quot;&lt;source&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pipeline&quot;</span> : [&lt;pipeline&gt;],</span><br><span class="line">    <span class="string">&quot;collation&quot;</span> : &#123; &lt;collation&gt; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">db.createView(</span><br><span class="line">  <span class="string">&quot;&lt;viewName&gt;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;source&gt;&quot;</span>,</span><br><span class="line">  [&lt;pipeline&gt;],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;collation&quot;</span> : &#123; &lt;collation&gt; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>view 支持以下方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find();</span><br><span class="line">db.collection.findOne();</span><br><span class="line">db.collection.aggregate();</span><br><span class="line">db.collection.countDocuments();</span><br><span class="line">db.collection.estimatedDocumentCount();</span><br><span class="line">db.collection.count();</span><br><span class="line">db.collection.distinct();</span><br></pre></td></tr></table></figure>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collsetion.update(</span><br><span class="line">  &lt;query&gt;,</span><br><span class="line">  &lt;updateObj&gt;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">upsert</span>:&lt;boolean&gt;,</span><br><span class="line">    multi:&lt;boolean&gt;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>update 更新后的对象或指定一些更新的操作符</p>
<ul>
<li><code>$set</code> 直接指定更新后的值</li>
<li><code>$inc</code> 在原基础上累加</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">age</span>: <span class="number">44</span> &#125; &#125;);</span><br><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;, &#123; <span class="attr">$inc</span>: &#123; <span class="attr">age</span>: <span class="number">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$unset</code> 删除字段，如果字段不存在不做处理</li>
<li><code>$push</code> 向数组添加数据</li>
<li><code>$ne</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">hobby</span>: &#123; <span class="attr">$ne</span>: <span class="string">&quot;smoking&quot;</span> &#125; &#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$each</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">$push</span>: &#123; <span class="attr">hobby</span>: &#123; <span class="attr">$each</span>: [<span class="string">&quot;smok&quot;</span>, <span class="string">&quot;dringing&quot;</span>] &#125; &#125; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$addToSet</code> 插入到集合，可以保证唯一性，如果项是重复的，将不会被插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zfpx&quot;</span> &#125;, &#123; <span class="attr">$addToSet</span>: &#123; <span class="attr">hobby</span>: <span class="string">&quot;drink&quot;</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<p>upsert 可选，不过不存在记录是否插入，默认不插入<br>muitl 可选，默认只更新找到的第一条记录，如果为 true，更新所有符合的记录</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><code>$eq</code>：匹配字段值等于指定值的文档</p>
<p><code>$gt</code>：匹配字段值大于指定值的文档</p>
<p><code>$gte</code>：匹配字段值大于等于指定值的文档</p>
<p><code>$lt</code>：匹配字段值小于指定值的文档</p>
<p><code>$lte</code>：匹配字段值小于等于指定值的文档</p>
<p><code>$ne</code>：匹配字段值不等于指定值的文档，包括没有这个字段的文档</p>
<p><code>$in</code>：匹配字段值等于指定数组中的任何值</p>
<p><code>$nin</code>：字段值不在指定数组或者不存在</p>
<p><code>$or</code>：文档至少满足其中的一个表达式</p>
<p><code>$not</code>：字段值不匹配表达式或者字段值不存在</p>
<p><code>$nor</code>：字段值不匹配所有的表达式的文档，包括那些不包含这些字段的文档</p>
<p><code>$exists</code>：boolean 等于 true 时，字段存在，包括字段值为 null 的文档</p>
<p><code>$type</code>：匹配字段值为指定数据类型的文档</p>
<p><code>$mod</code>：匹配字段值被除有指定的余数的文档</p>
<p><code>$regex</code>：正则表达式可以匹配到的文档</p>
<p><code>$text</code>：针对创建了全文索引的字段进行文本搜索</p>
<p><code>$where</code>：可以通过 js 表达式或 js 函数来查询文档<br><code>$all</code>: 字段值是包含所有指定元素的数组的文档<br><code>$elemMatch</code>：数组字段至少一个元素满足所有指定查询条件的文档<br><code>$size</code>：匹配数组字段元素个数等于指定数量的文档<br><code>$ (projection)</code>：限定查询结果中指定数组字段返回满足条件的第一个元素<br><code>$elemMatch (projection)</code>：限定查询结果中指定数组字段返回满足条件的第一个元素<br><code>$slice (projection)</code>：控制指定数组字段返回元素个数<br><code>$inc</code>：给一个字段增加指定值<br><code>$setOnInsert</code> ：upsert 为 true 时，有插入文档操作时插入指定字段值<br><code>$unset</code>：删除指定字段</p>
<p><code>$min</code>：指定值小于当前值则更新为指定值<br><code>$max</code>: 指定值大于当前值则更新为指定值<br><code>$currentDate</code>:设置字段值为当前日期</p>
<p><code>$</code>: 更新指定数组的第一个元素<br><code>$addToSet</code>:数组字段增加一个值<br><code>$pop</code>: 删除数组字段中的第一个或最后一个元素<br><code>$pullAll</code>: 删除数组字段中所有指定值，如果指定值为数组，则删除匹配数组内的元素<br><code>$pull</code>: 符合条件的值将被删除<br><code>$pushAll</code>：向数组中追加多个指定值<br><code>$push</code>：向数组中追加值<br><code>$each</code>：用于 <code>$addToSet</code> 添加多个值到数组中</p>
<h3 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h3><h4 id="通过配置项启动数据库"><a href="#通过配置项启动数据库" class="headerlink" title="通过配置项启动数据库"></a>通过配置项启动数据库</h4><p>—dbpath 数据库文件的目录<br>—port 默认是 27017 28017<br>—fork 以后台守护方式运行<br>—logpath 日志目录<br>—config 指定一个配置文件<br>—auth 以安全参数启动</p>
<h4 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h4><p>mongoimport 导出数据<br>mongoexport 导入数据</p>
<p>mongodb 使用 mongorestore 来恢复备份的数据</p>
<p>Mongodump 可以 backup 整个数据库，而 mongoexport 要对每个 conllection 进行操作。恢复使用 mongostore</p>
<p>mongoexport 输出的 json 比 mongodump 的 bson 可读性高，进而可以直接对 json 文件进行操作然后还原数据（bson 转换 json 存在潜在兼容问题）</p>
<h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><p>物理隔离<br>网络隔离<br>防火墙<br>用户名和密码验证</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show roles 查看角色</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>:<span class="string">&#x27;zf&#x27;</span>,<span class="attr">pwd</span>:<span class="string">&#x27;123&#x27;</span>,<span class="attr">roles</span>:[&#123;<span class="attr">db</span>:<span class="string">&#x27;school&#x27;</span>&#125;,<span class="attr">role</span>:<span class="string">&#x27;read&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>ensure 表示升序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.ensureIndex(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="分析索引的执行过程"><a href="#分析索引的执行过程" class="headerlink" title="分析索引的执行过程"></a>分析索引的执行过程</h4><p>mongodb 提供了 explain 命令来分析查询过程</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1 为正序 -1 为倒序<br>索引可以提升查询速度，但会降低插入速度<br>数据量不大时不需要使用索引，性能的提升不明显，反而大大增加了内存和硬盘的消耗<br>查询数据超过表数据量 30%时，不要使用索引字段查询<br>排序工作的时候可以建立索引提高排序速度<br>数字索引要比字符串索引快得多</p>
<h3 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>数据库集群中明确知道谁是主服务器，主服务器只有一台<br>从服务器要知道自己的数据源也就是主服务器是谁<br>—master 用来确定主服务器，—slave 和—source 来控制从服务器</p>
<h5 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h5><p>-only 从节点 指定复制某个数据库<br>-slavedelay 从节点 设置主数据库同步数据的延迟<br>-fastsync 从节点 以主数据库的节点快照为节点启动从数据库<br>-autoresync 从节点 如果不同步则重新同步数据库<br>-oplogSize 主节点 设置 oplog 的大小</p>
<h5 id="db-sources"><a href="#db-sources" class="headerlink" title="db.sources"></a>db.sources</h5><p>提供了 api 设置从服务器的 source</p>
<h4 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h4><p>需要一台活跃服务器和两个备份服务器<br>当活跃服务器故障，集群根据权重算法推选出活跃服务器<br>当原来的主服务器恢复后又会变成从服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbpath=...</span><br><span class="line">prot=...</span><br><span class="line">replSet=group  // 每个副本集需要有一个名字</span><br></pre></td></tr></table></figure>
<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">  <span class="attr">binary</span>: Buffer,</span><br><span class="line">  <span class="attr">living</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">  <span class="attr">birthday</span>: <span class="built_in">Date</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">Number</span>,</span><br><span class="line">  <span class="attr">_id</span>: Schema.Types.ObjectId,</span><br><span class="line">  <span class="attr">_fk</span>: Schema.Types.ObjectId,</span><br><span class="line">  <span class="attr">array</span>: [],</span><br><span class="line">  <span class="attr">arrOfString</span>: [<span class="built_in">String</span>],</span><br><span class="line">  <span class="attr">arrOfNumber</span>: [<span class="built_in">Number</span>],</span><br><span class="line">  <span class="comment">// 内嵌文档</span></span><br><span class="line">  <span class="attr">nested</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="SchemaType"><a href="#SchemaType" class="headerlink" title="SchemaType"></a>SchemaType</h4><p>以下是 mongoose 的所有合法 SchemaTypes：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
<li>Decimal128<br>直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象。</li>
</ul>
<h5 id="全部可用"><a href="#全部可用" class="headerlink" title="全部可用"></a>全部可用</h5><ul>
<li>required: 布尔值或函数 如果值为真，为此属性添加 required 验证器</li>
<li>default: 任何值或函数 设置此路径默认值。如果是函数，函数返回值为默认值</li>
<li>select: 布尔值 指定 query 的默认 projections 为 false 默认不返回该字段</li>
<li>validate: 函数 adds a validator function for this property</li>
<li>get: 函数 使用 Object.defineProperty() 定义自定义 getter 这个 getter 是在访问该属性时生效的 consolelog 打印的还是初始值</li>
<li>set: 函数 使用 Object.defineProperty() 定义自定义 setter</li>
<li>alias: 字符串 仅 mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets</li>
</ul>
<h5 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h5><ul>
<li>index: 布尔值 是否对这个属性创建索引</li>
<li>unique: 布尔值 是否对这个属性创建唯一索引</li>
<li>sparse: 布尔值 是否对这个属性创建稀疏索引</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><ul>
<li>lowercase: 布尔值 是否在保存前对此值调用 .toLowerCase()</li>
<li>uppercase: 布尔值 是否在保存前对此值调用 .toUpperCase()</li>
<li>trim: 布尔值 是否在保存前对此值调用 .trim()</li>
<li>match: 正则表达式 创建验证器检查这个值是否匹配给定正则表达式</li>
<li>enum: 数组 创建验证器检查这个值是否包含于给定数组</li>
</ul>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><ul>
<li>min: 数值 创建验证器检查属性是否大于或等于该值</li>
<li>max: 数值 创建验证器检查属性是否小于或等于该值</li>
</ul>
<h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><ul>
<li>min: Date</li>
<li>max: Date</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p><strong>Dates</strong><br>内建 Date 方法 不会触发 mongoose 修改跟踪逻辑， 如果你对使用 setMonth() 修改文档里的 Date， mongoose 在 doc.save() 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库。 如果你一定要用内建 Date 方法， 请手动调用 doc.markModified(‘pathToYourDate’) 告诉 mongoose 你修改了数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Assignment = mongoose.model(<span class="string">&quot;Assignment&quot;</span>, &#123; <span class="attr">dueDate</span>: <span class="built_in">Date</span> &#125;);</span><br><span class="line">Assignment.findOne(<span class="function"><span class="keyword">function</span> (<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">  doc.dueDate.setMonth(<span class="number">3</span>);</span><br><span class="line">  doc.save(callback); <span class="comment">// THIS DOES NOT SAVE YOUR CHANGE</span></span><br><span class="line"></span><br><span class="line">  doc.markModified(<span class="string">&quot;dueDate&quot;</span>);</span><br><span class="line">  doc.save(callback); <span class="comment">// works</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Mixed</strong><br>一个啥都可以放的 SchemaType ， 虽然便利，但也会让数据难以维护。 Mixed 可以通过 Schema.Types.Mixed 或 传入一个空对象定义。以下三种方法效果一致：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: &#123;&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: <span class="built_in">Object</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: Schema.Types.Mixed &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>ObjectIds</strong></p>
<p>创造 SchemaTypes 或子文档数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ToySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> ToyBox = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">toys</span>: [ToySchema],</span><br><span class="line">  <span class="attr">buffers</span>: [Buffer],</span><br><span class="line">  <span class="attr">string</span>: [<span class="built_in">String</span>],</span><br><span class="line">  <span class="attr">numbers</span>: [<span class="built_in">Number</span>],</span><br><span class="line">  <span class="comment">// ... etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>指定空数组相当于 Mixed</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Empty1 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [] &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty2 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: <span class="built_in">Array</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty3 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [Schema.Types.Mixed] &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty4 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [&#123;&#125;] &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>mongoose.connect(‘mongodb://username:password@host:port/database?options…’);</p>
<h4 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a>操作缓存</h4><p>不必等待连接建立成功就可以使用 mongoose models</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&quot;mongodb://localhost/myapp&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> MyModel = mongoose.model(<span class="string">&quot;Test&quot;</span>, <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;));</span><br><span class="line"><span class="comment">// 可行</span></span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mongoose 会缓存操作，这样很方便，但有时也会造成疑惑，因为如果你没连上 ，Mongoose 不会 抛错。<br>要禁用缓存，请修改 bufferCommands 配置。 如果你打开了 bufferCommands 连接被挂起，尝试关闭 bufferCommands 检查你是否正确打开连接。 你也可以全局禁用 bufferCommands ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">&quot;bufferCommands&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是通过 Schema 构造而成的，除了具有 Schema 定义的数据库骨架以外，还可以操作数据库</p>
<p>第一个参数是跟 model 对应的集合（ collection ）名字的 单数 形式。 Mongoose 会自动找到名称是 model 名字 复数 形式的 collection 。 对于上例，Tank 这个 model 就对应数据库中 tanks 这个 collection。.model() 这个函数是对 schema 做了拷贝（生成了 model）。 你要确保在调用 .model() 之前把所有需要的东西都加进 schema 里了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span>, <span class="attr">size</span>: <span class="string">&quot;string&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Tank = mongoose.model(<span class="string">&quot;Tank&quot;</span>, schema);</span><br></pre></td></tr></table></figure>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>可以用 model 的 find，findById，findOne，where 这些静态方法</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>remove 方法</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>update 方法</p>
<h3 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h3><p>Mongoose document 代表着 MongoDB 文档的一对一映射。 每个 document 都是他的 Model 的实例。</p>
<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>有很多方法可以更新文档</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  tank.size = <span class="string">&quot;large&quot;</span>;</span><br><span class="line">  tank.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, updatedTank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(updatedTank);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用 .set() 修改 document，在底层 tank.size = ‘large’; 用 tank.set({ size: ‘large’ })实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  tank.set(&#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125;);</span><br><span class="line">  tank.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, updatedTank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(updatedTank);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们仅仅需要更新而不需要获取该数据， Model#update 就很适合我们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.update(&#123; <span class="attr">_id</span>: id &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125; &#125;, callback);</span><br></pre></td></tr></table></figure>
<p>如果我们确实需要返回文档</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tank.findByIdAndUpdate(</span><br><span class="line">  id,</span><br><span class="line">  &#123; <span class="attr">$set</span>: &#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">new</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(tank);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>document 在被保存前会被验证</p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>可以用 .set() 覆盖整个文档，如果要修改在中间件中被保存的文档，这样很方便</p>
<h3 id="子文档-subdocument"><a href="#子文档-subdocument" class="headerlink" title="子文档 subdocument"></a>子文档 subdocument</h3><p>Mongoose 中子文档有两种不同的概念 子文档数组和单个嵌套子文档。</p>
<p>子文档与普通 document 类似。嵌套 schema 可以有自己的 中间件、自定义检验逻辑、 虚拟值以及其他顶层 schemas 可用的特性。两者主要的不同点是 子文档不能单独保存，他们会在他们的顶级文档保存时保存。</p>
<p>子文档跟普通 document 一样有 save 和 validate 中间件。 调用父文档的 save() 会触发其所有子文档的 save() 中间件， validate() 中间件同理。</p>
<p>子文档的 pre(‘save’) 和 pre(‘validate’) 中间件执行于 顶层 document 的 pre(‘save’) 之前， 顶层 document 的 pre(‘validate’) 之后。 因为 save() 前的验证就是一个内置中间件。（待修改）</p>
<h4 id="查找子文档"><a href="#查找子文档" class="headerlink" title="查找子文档"></a>查找子文档</h4><p>每个子文档都有一个默认的 <code>_id</code> 。Mongoose document 数组有一个特别的 id 方法， 这个方法只要传入 <code>_id</code> 就能返回文档数组中特定文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = parent.children.id(_id);</span><br></pre></td></tr></table></figure>
<h4 id="添加子文档到数组"><a href="#添加子文档到数组" class="headerlink" title="添加子文档到数组"></a>添加子文档到数组</h4><p>Mongoose 数组方法有 push、 unshift、 addToSet、 及其他：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = mongoose.model(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a comment</span></span><br><span class="line">parent.children.push(&#123; <span class="attr">name</span>: <span class="string">&quot;Liesl&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> subdoc = parent.children[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(subdoc); <span class="comment">// &#123; _id: &#x27;501d86090d371bab2c0341c5&#x27;, name: &#x27;Liesl&#x27; &#125;</span></span><br><span class="line">subdoc.isNew; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="代替声明语法的写法"><a href="#代替声明语法的写法" class="headerlink" title="代替声明语法的写法"></a>代替声明语法的写法</h4><p>如果你用对象的数组创建 schema ，mongoose 会自动 为你把对象转换成 schema：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">children</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span> &#125;],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Equivalent</span></span><br><span class="line"><span class="keyword">var</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">children</span>: [<span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span> &#125;)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/07/%E8%BF%90%E7%BB%B4/%E8%AE%B0%E4%BD%BF%E7%94%A8docker-compose%E5%AF%B9OJ%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E4%BC%98%E5%8C%96%E9%87%8D%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/07/%E8%BF%90%E7%BB%B4/%E8%AE%B0%E4%BD%BF%E7%94%A8docker-compose%E5%AF%B9OJ%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E4%BC%98%E5%8C%96%E9%87%8D%E6%9E%84/" class="post-title-link" itemprop="url">记使用docker-compose对OJ系统部署优化重构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-07 21:11:59" itemprop="dateCreated datePublished" datetime="2019-03-07T21:11:59+00:00">2019-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">2.1k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">7(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这几天研究了一下用把上学期写的 oj 部署在 docker 容器中，自己编写了 Dockerfile 构建主容器，并将数据库容器分离，使用了 docker-compose 对容器进行管理，实现了自动化的部署，感觉收获挺多的。写下这篇博客记录一下自己新 get 到的技能。</p>
<h3 id="重构原因"><a href="#重构原因" class="headerlink" title="重构原因"></a>重构原因</h3><p>其实我接触到 docker 这门技术已经很久了。在学习 Laravel 的时候使用了 laradock 快速构建开发环境，那时候感觉 docker 真是太方便了。不过长久以来，我对于 docker 的了解，仅仅停留在基础的使用上，也没有尝试过自己编写 Dockerfile 构建镜像，对于 docker 中一些基础的概念都很模糊，像什么端口映射啊，数据持久化啊，都不了解，结果在部署应用的时候，白白费了很多功夫，实在是得不偿失。这就不得不说之前部署 OJ 的血泪史（菜啊(⊙﹏⊙)b）。我校 OJ 是基于 HUSTOJ 进行二次开发的，在本地开发的时候使用了作者的一键部署脚本，没有使用容器构建。之前学长在学校的服务器上用 docker 跑了一个 hustoj 的镜像。本地开发倒是没有什么问题，但是怎么部署到服务器的 docker 上？我的做法现在看来非常的傻逼，把项目改动部分的代码上传到 github 仓库，然后进入到学校 oj 的 hustoj 容器中，把其中 web 部分的代码删除，再从 github 上 pull 下我的代码。我想的是很简单，实际操作起来。先是部署上去就花了将近一整天，而之后像是 OJ 判不了 JAVA，文件权限不对，配置文件不对等各种问题等前前后后修复了好几次才搞定，一点都不<strong>优雅</strong>。之后过了一个寒假，倒是一直稳定运行到现在。但是我觉得不能就这样放着，因为这系统除了我自己。趁开学事情少，我学习了一下怎么编写 Dockerfile，以及编写 docker-compose 的配置脚本，实现了 OJ 的自动化部署。</p>
<h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><p>之前看 docker 的书的时候，是有看过怎么编写 Dockerfile 的，但是没有自己写过。所以一上来就陷入了僵局。基础镜像选择我比较熟悉的 ubuntu，但之后该干嘛啊。百度学习一番后，我了解到 docker 有 history 这个命令，其加上—no-trunc 可以完整显示镜像构建每个步骤执行的命令（但是后来我才意识到 hustoj 的项目中就有 Dockerfile 文件，僵）。先复制过来，然后看着基础镜像 ubuntu:Trusty，不明所以，百度了一下才知道这个 ubuntu14 的代号，这也太老了吧。直接换成 ubuntu18.04，把里面的软件都换成了比较新的版本，把 php5 换成了 php7，去掉了 mysql，因为要放到单独的容器中。就这样小改了一下，感觉没啥问题，那就构建一下试试吧。<br>进行构建，显示命令报错，很多软件包都不存在。果断开一个 ubuntu 的容器，一个个测试能不能下载，确认没问题再次构建。然后 apt 能下载了，但是官方源的速度实在是太慢了。因此添加了<code>COPY sources.list /etc/apt/sources.list</code>命令到最前面。这下下载速度没问题了，但是在安装某个依赖 tzdata 时，需要手动选择时区，但是我按照指令选择并没有相应，重新构建了几次，都是如此。百度解决办法，需要这样来安装</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">export</span> DEBIAN_FRONTEND=noninteractive \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y tzdata</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="bash">    &amp;&amp; dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure>
<p>我把它放在安装其他软件之前。docker 的构建步骤是有缓存的，之前成功构建的步骤会缓存起来，每一个步骤对应一个镜像层，下次不需要再次构建。一条 RUN 语句的执行就创建了一个镜像层。如果构建步骤发生了改变，就从开始改变的那一步开始重新构建。开始构建的时候，往往少安装很多软件包，可以把新添加的包放在新的 RUN 语句下安装，避免把原先安装的包再下载一遍。<br>hustoj 的构建镜像的项目代码是从 github 上 clone 下来的，我最开始也是这么写的，后来发现有更好的方法，这个后面再说。</p>
<h3 id="使用-docker-compose"><a href="#使用-docker-compose" class="headerlink" title="使用 docker-compose"></a>使用 docker-compose</h3><p>因为打算把 mysql 容器分离，所以要使用 docker-compose 进行容器的管理。laradock 就是基于 docker-compose 的一个项目。在配置文件中，我们需要定义服务，每个服务对应一个容器，服务的选项对应了 docekr 启动是的各种启动选项。将其写在配置文件中，我们只要简单的两行命令就可以了，非常高效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>下面记录几个我认为重要的点</p>
<ul>
<li>tty 选项，主容器应该设置为 true，否则会因为确实控制终端的配置导致启动失败</li>
<li>ports 选项，设置容器的端口映射，按照 主机端口：容器端口 的顺序映射</li>
<li>expose，说明容器暴露的端口，但没有实际作用，仍需要设置 ports 选项才能让映射生效</li>
<li>links，容器间数据互联，容器的中会解析服务名为对应的 ip 地址，我让主容器连接到了 mysql 容器</li>
<li>depends_on 依赖，被依赖的服务会现行构建</li>
<li>enviroment 环境变量，对于 mysql 可以通过环境变量设置管理员密码，新建用户和新建数据库</li>
<li>volumes，数据卷，像/var/lib/mysql 这样存放数据的目录应该放在可持久化的数据卷中，也可以映射本机目录到容器</li>
<li>.env 文件可以定义当前目录中的环境变量，这是 linux 系统的特性，会自动读取.env 中定义的变量到环境变量</li>
<li>entrypoint，容器<strong>启动</strong>时自动运行的脚本，一般用于启动后台服务进程。是启动而不是构建时，每次<code>docker-compose start</code>时都会运行，Dockerfile 中也有 ENTRYPOINT 选项，也是在每次容器启动的时候运行。</li>
</ul>
<p>总结一下，Dockerfile 中 RUN 命令只在构建的时候运行，用于安装软件包，和简单的一些配置。两个 entrypoint 区别不大，都是容器启动时运行，一般用于启动后台服务。而对于只需要进行一次的操作，比如运行 sql 建库，修改文件权限，可以编写一个 shell 脚本，在容器创建之后手动执行一次</p>
<h3 id="整合到项目"><a href="#整合到项目" class="headerlink" title="整合到项目"></a>整合到项目</h3><p>这样构建起来的项目，代码是保存在镜像中的，没办法用 vscode 打开。回想起来之前用 laradock 的经历，似乎可以将本地项目目录映射到容器，看了 laradock 的配置文件，果然如此。于是把项目代码文件目录也整合了进来，在 volumes 选项中设置映射代码目录。目录结构是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── docker</span><br><span class="line">│   ├── ahpuoj</span><br><span class="line">│   └── docker-compose.yml</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── core</span><br><span class="line">    ├── install</span><br><span class="line">    └── web</span><br></pre></td></tr></table></figure>
<p>这样只要 clone 到本地，简单构建一下容器，就可以进行开发了。<br>对于不要提交的配置文件，我将其放在 install 文件夹中，并且在创建后执行的安装脚本中设置了软连接指向本该所在的目录。个人认为是个不错的方法。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>depends_on 虽然决定了容器创建的顺序，但是容器中的服务启动仍然需要时间。因此在 entrypoint.sh 中访问数据库会失败，因为这时候数据库容器中的服务可能还没有启动完成</li>
<li>sed 修改软连接文件会将其变成真正的文件，需要添加<code>--follow-symlinks</code>选项</li>
<li>entrypoint.sh 文件的最后应加上<code>/bin/bash</code>,运行 bash 前台应用，否则也会造成容器启动后就停止</li>
</ul>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>最后是<a target="_blank" rel="noopener" href="https://github.com/jiezi19971225/ahpuoj-docker">项目的地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiezi19971225</p>
  <div class="site-description" itemprop="description">记录编程学习路上的点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiezi19971225</span>
</div>
  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"/>
  <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备17001385号-1</a>
  <br/>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
