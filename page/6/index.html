<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="baidu-site-verification" content="5IfwMCE5hH" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.jiezi19971225.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录编程学习路上的点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Jiez19971225‘s Blog">
<meta property="og:url" content="http://www.jiezi19971225.cn/page/6/index.html">
<meta property="og:site_name" content="Jiez19971225‘s Blog">
<meta property="og:description" content="记录编程学习路上的点滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiezi19971225">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.jiezi19971225.cn/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jiez19971225‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiez19971225‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做自己爱做的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/" class="post-title-link" itemprop="url">mysql45-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 23:28:34" itemprop="dateCreated datePublished" datetime="2019-08-03T23:28:34+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">502(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><ul>
<li>mysql 里面的锁可以大致分成全局锁，表级锁和行锁</li>
</ul>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁对整个数据库实例加锁<br>Flush tables with read lock(FTWRL)<br>当使用这个命令后，其他线程的一下语句会被阻塞：数据更新语句，数据定义语句和更新类事务的提交语句<br>典型使用场景是做全局逻辑备份</p>
<ul>
<li>主库上备份，业务会停摆</li>
<li>从库上备份，备份期间不能执行主库同步过来的 binlog，导致主从延迟<br>官方自带的逻辑备份工具是 mysqldump，当使用参数-single-transaction 的时候，导数据之前就会启动一个事务，确保拿到一致性视图</li>
<li>myisam 不支持事务的引擎，这时就需要使用 FTWRL</li>
<li>不建议使用 set global readonly = true</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>lock tables … read/write<br>可以使用 unlock 主动释放，也可以在客户端断开的时候自动释放</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><ul>
<li>MyiSAM 把表的总行数存在了磁盘上，因此效率很高</li>
<li>innodb 需要一行一行统计</li>
<li>在保证逻辑正确的前提下 尽量减少扫描的数据量 是数据库系统设计的通用法则之一</li>
<li>show table status 返回很快 但是不准确</li>
<li>innodb 可以将计数保存到一张表中，使用事务，保持了一致性</li>
<li>count(id) innodb 会遍历整张表，把每一行的 id 都取出来，返回给 server 层，server 层拿到 id 后，判断是不可能为空的，就按行累加</li>
<li>count(1) innodb 引擎便利整张表，但不取值，server 层对返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加</li>
<li>count(字段)<ul>
<li>如果是 not null 就一行行独读出，判断不能为 null，按行累加</li>
<li>如果允许为 null，不是 null 才累加</li>
</ul>
</li>
<li>count(*)做了优化，按行累加</li>
</ul>
<h4 id="答疑-1"><a href="#答疑-1" class="headerlink" title="答疑 1"></a>答疑 1</h4><ul>
<li>insert on duplicate 确保了在事务内部，执行 SQL 后占住了这个行锁</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">mysql45-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 23:28:32" itemprop="dateCreated datePublished" datetime="2019-08-03T23:28:32+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">164(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="order-by-是怎么工作的"><a href="#order-by-是怎么工作的" class="headerlink" title="order by 是怎么工作的"></a>order by 是怎么工作的</h4><ul>
<li>mysql 的外部排序采用归并排序，将排序数据分成多个保存到临时文件中，最后合并为一个大文件</li>
<li>mysql 有两种排序方式 全字段排序和 rowid 排序，mysql 的设计思想是，如果内存够，就要多利用内存，尽量减少磁盘访问</li>
<li>rc 模式下 for update 对所有行加了 X 锁 没有上 gap 锁 rr 模式下，也加了 X 锁</li>
<li>幻读是指一个事务在前后两次查询同一个范围的时候，后一次查询到了前一次没看到的行</li>
<li>加上 forupdate 是当前读</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">mysql45</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 23:27:55" itemprop="dateCreated datePublished" datetime="2019-08-03T23:27:55+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">2.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">7(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>Mysql 拿到一个查询请求后，会先到查询缓存看是否执行过该语句。缓存可能会以 key-value 对形式直接缓存在内存，如果能直接在缓存中找到结果，就直接返回 value 给客户端，否则，就继续后面的执行阶段。执行完成后，执行结果被存入查询缓存。</p>
<p>但是查询缓存的失效非常频繁，只要对一个表有更新，这个表上所有查询缓存都会被清空。从 mysql8.0 版本，查询缓存的功能被删除了。</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><img src="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/查询流程.png" alt="查询流程"></p>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p>WAL 技术全称是 Write-Ahead Logging 先写日志，再写磁盘，当有一条记录需要更新的时候，innodb 会把记录写到 redo log，并更新内存，并在适当的时候，将这个操作记录更新到磁盘。redolog 的大小是固定的，写到末尾又会回到开头覆写。<br>因为 redolog，innodb 可以保证数据库异常重启后，之前提交的记录不会丢失，称为 crash-safe。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redolog 是 innodb 特有的 log，而 server 层也有自己的日志，称为 binlog（归档日志）<br>redolog 是物理日志，记录在某个数据页做了什么修改，binlog 是逻辑日志，记录的是语句的原始逻辑<br>binlog 采用追加写，写到一定大写后会创建新的 binlog，不会覆盖之前的日志</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>浅色表示在 innoDB 内部执行，深色表示在执行器中执行<br><img src="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/两阶段提交.png" alt="两阶段提交"></p>
<p>redolog 的写入拆分成 parpare 和 commit 两步，保证两个日志逻辑上的一致，这给了 binlog 和 redolog 一个同时说 ok 的机会</p>
<h4 id="崩溃恢复原则"><a href="#崩溃恢复原则" class="headerlink" title="崩溃恢复原则"></a>崩溃恢复原则</h4><p>redo log 和 binlog 有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>
<ol>
<li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li>
<li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。<ul>
<li>binlog 无记录，回滚事务</li>
<li>binlog 有记录，提交事务。</li>
</ul>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>set innodb_flush_log_at_trx_commit = 1 将每次事务都持久化到磁盘<br>set sync_binlog = 1 将每次事务的 binlog 都持久化到磁盘</p>
<h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>读未提交，一个事务还没提交时，它做的变更就能被别的事务看到<br>读提交，一个事务提交之后，他做的变更才会被其他事务看到<br>可重复读是，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一样的，未提交的变更对其他事务是不可见的<br>串行化，对于同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成后才能继续执行<br>配置方式 将启动参数 transaction_isolation 的值设置成 READ-COMMITTED，可以用 show variables 查看当期数值</p>
<p>数据库内会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是在事务启动的时候创建的，整个事务存在期间都用这个事务。在读提交级别下，这个视图是在每个 sql 语句开始执行的时候创建的。读未提交没有视图概念，串行化直接用加锁的方式避免并行访问。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>可重复读 每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，可以得到前一个状态的值<br>不同时刻启动的事务会有不同的 read-view,同一个记录的值分别是 1,2,3,4，同一个记录在系统中可以存在多个版本，这是数据库的多版本并发控制 mvcc。对于 read-view A，要得到更新后的值，就必须将当前数值依次执行所有回滚操作<br>回滚日志会一直保留到没有比这个更早的 read-view 的时候，因此尽量不要使用长事务</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>显式启动事务 begin 或 start transaction 提交使用 commit 回滚使用 rollback<br>set autocommit=0 会将线程的自动提交关掉，这意味着事务不会自动提交，知道主动执行 commit 或者 rollback 或者断开连接，建议总是设置 autocommit 为 1<br>可以在 informatino_schema 库的 innodb_trx 表中查询长事务</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>三种数据结构<ul>
<li>哈希表 优点是增加新的 user 时速度很快，只需要往后追加，但缺点是，因为不是有序的，哈希索引做区间查询速度很慢</li>
<li>有序数组 在等值查询和范围查询场景的性能非常优秀，但是需要插入的时候成本太高，只适用于静态存储引擎</li>
<li>搜索树 目前数据库中使用的是 N 叉数</li>
</ul>
</li>
</ul>
<h3 id="innodb-的索引模型"><a href="#innodb-的索引模型" class="headerlink" title="innodb 的索引模型"></a>innodb 的索引模型</h3><ul>
<li>innodb 中，表都是根据主键顺序以索引的形式存放的，这种方式称为索引组织表，使用 B+树索引模型，所有数据存储在 B+树中。</li>
<li>主键索引的叶子节点存的是整行数据，在 innodb 中，主键索引也被称为聚簇索引，非主键索引的叶子节点的内容是主键的数值，非主键索引也被称为二级索引</li>
<li>使用二级索引查表需要先找到主键的值，再在主键的索引书搜索一次，这个过程称为回表</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><ul>
<li>主键索引树需要保持树的有序性，自增主键的插入数据模式的耗时很低，而有业务逻辑的字段作主键，往往不容易保证有序插入，这样写数据的成本相对较高</li>
<li>而且从空间角度，使用 int 型作为主键，占用的空间也较小，主键索引越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</li>
<li>直接用业务字段作主键<ul>
<li>只有一个索引</li>
<li>该索引必须是唯一索引</li>
</ul>
</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果在某个查询里面，索引 k 已经覆盖了我们的查询需求，我们称其为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能</p>
<h3 id="最左索引"><a href="#最左索引" class="headerlink" title="最左索引"></a>最左索引</h3><ul>
<li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以使联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</li>
</ul>
<h3 id="下推优化"><a href="#下推优化" class="headerlink" title="下推优化"></a>下推优化</h3><p>mysql5.6 之后，可以在索引遍历的过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数</p>
<h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p>重建主键索引会将整个表重建</p>
<ul>
<li>普通索引与唯一索引的性能差距<br>对于普通索引，查找到满足条件的第一条记录后，还需要继续查找知道碰到第一个不满足条件的记录，对于唯一索引，由于定义了唯一性，查找到第一个满足条件的记录后就会停止继续检索，这带来的性能差距呢是微乎其微，innodb 是按照页读写的，当找到记录的时候，他所在的数据页也都在内存中，因此下一次查找的消耗很低</li>
<li>change buffer<br>当需要更新一个数据页时，如果数据页在内存中就直接更新，如果不再，在不影响数据一致性的前提下，innodb 会将更新操作缓存在 changer buffer 中，当下一次查询需要访问这个页面的时候，将数据读入内存，然后执行 change buffer 中与这个页有关的操作。很像操作系统中的页面交换。</li>
<li>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge，除了访问这个数据页会触发 purge，还有后台线程会定期 purge，在数据库正常关闭的过程中，也会执行 purge</li>
<li>对于唯一索引，所有更新操作都先判断这个操作是否违反唯一约数，要将数据页读入内存才能判断，没必要使用 change buffer 实际上只有普通索引可以使用</li>
<li>change buffer 用的是 buffer pool 里的内存，可通过 innodb_change_buffer_max_size 来动态设置</li>
<li>对于写多读少的业务，比较适合使用 change buffer，如果业务写入之后立即查询，由于会频繁触发 purge 过程，增加了 change buffer 的维护代价，反而起到了副作用</li>
</ul>
<h3 id="mysql-选择了错误的索引"><a href="#mysql-选择了错误的索引" class="headerlink" title="mysql 选择了错误的索引"></a>mysql 选择了错误的索引</h3><ul>
<li>可以使用 force index 强制选取使用的索引</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/javascript/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/javascript/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">es6学习笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 23:25:54" itemprop="dateCreated datePublished" datetime="2019-08-03T23:25:54+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">4.9k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">18(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在全局变量 tmp，但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 let 声明变量前，对 tmp 赋值会报错</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用 但是浏览器的实现与规范不同，应避免使用该写法</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心</p>
<p>如果真的想将对象冻结，应该使用 Object.freeze 方法</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>如果解构不成功，变量的值就等于 undefined。</p>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p>
<p>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>如果解构失败，变量的值等于 undefined</p>
<p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &#x27;hello&#x27;</span><br><span class="line">l // &#x27;world&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><ul>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</li>
</ul>
<h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象</p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>交换变量的值 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 结构 输入模块的指定方法</p>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h4><p>允许采用<code>\uxxxx</code>形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点 可将码点放入大括号</p>
<p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。</p>
<h4 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h4><p>ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<p>模板字符串之中可以放入表达式，还能调用函数</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法</p>
<h3 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h3><h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符</p>
<h4 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h4><p>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法</p>
<h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>能够正确处理 4 个字节储存的字符，返回一个字符的码点</p>
<h4 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h4><p>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化</p>
<h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次</p>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>padStart()用于头部补全，padEnd()用于尾部补全</p>
<h4 id="trimStart-，trimEnd"><a href="#trimStart-，trimEnd" class="headerlink" title="trimStart()，trimEnd()"></a>trimStart()，trimEnd()</h4><p>trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<h4 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h4><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配</p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示"><a href="#二进制和八进制表示" class="headerlink" title="二进制和八进制表示"></a>二进制和八进制表示</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。</p>
<h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>判断是否为极限和 NaN</p>
<h4 id="Number-isFinite-Number-isNaN-1"><a href="#Number-isFinite-Number-isNaN-1" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger()用来判断一个数值是否为整数</p>
<h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差</p>
<h4 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h4><p>ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量<br>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内</p>
<h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分<br>Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值<br>Math.cbrt 方法用于计算一个数的立方根</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<p>参数变量是默认声明的，所以不能用 let 或 const 再次声明</p>
<h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure>
<h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。如果传入 undefined，将触发该参数等于默认值，null 则没有这个效果。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&#x27;Missing parameter&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了 sort 默认是按照 unicode 码点顺序排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const sortNumber = (...number) =&gt; number.sort()</span><br><span class="line">console.log(sortNumber(3, 2, 1))</span><br></pre></td></tr></table></figure>
<p>rest 参数之后不能再有其他参数</p>
<h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>函数的 name 属性，返回该函数的函数名</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，在箭头函数中，它是固定的</p>
<p>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误</p>
<p>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(&#x27;s1: &#x27;, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(&#x27;s2: &#x27;, timer.s2), 3100);</span><br><span class="line">// s1: 3</span><br><span class="line">// s2: 0</span><br></pre></td></tr></table></figure>
<p>上面代码中，Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 this 绑定定义时所在的作用域（即 Timer 函数），后者的 this 指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1 被更新了 3 次，而 timer.s2 一次都没更新。</p>
<p>不能用 call()、apply()、bind()这些方法去改变 this 的指向</p>
<h4 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h4><p>由于箭头函数使得 this 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义对象的方法，且该方法内部包括 this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const cat = &#123;</span><br><span class="line">  lives: 9,</span><br><span class="line">  jumps: () =&gt; &#123;</span><br><span class="line">    this.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用 cat.jumps()时，如果是普通函数，该方法内部的 this 指向 cat；如果写成上面那样的箭头函数，使得 this 指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</p>
<p>第二个场合是需要动态 this 的时候，也不应使用箭头函数。</p>
<h4 id="函数式相关"><a href="#函数式相关" class="headerlink" title="函数式相关"></a>函数式相关</h4><p>省略</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。替代函数的 apply 方法</p>
<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><ul>
<li>复制数组</li>
<li>合并数组</li>
<li>与解构赋值结合</li>
<li>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from 方法用于将两类对象转为真正的数组<br>类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异。</p>
<h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined</p>
<p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>fill 方法使用给定值，填充一个数组。fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h4><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似</p>
<h4 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h4><p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat()方法的参数写成一个整数，表示想要拉平的层数，默认为 1。</p>
<p>flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。</p>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>不建议保留空位，es6 对于空位设置文 undefined</p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</p>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性/方法名，即把表达式放在方括号内。</p>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]</p>
<h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的 name 属性，返回函数名</p>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上 get 和 set。有两种特殊情况：bind 方法创造的函数，name 属性返回 bound 加上原函数的名字；Function 构造函数创造的函数，name 属性返回 anonymous。</p>
<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><p>描述对象 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p>
<p>enumerable 属性，称为“可枚举性”目前，有四个操作会忽略 enumerable 为 false 的属性。只有 for…in 会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for…in 循环，而用 Object.keys()代替。</p>
<ul>
<li>for…in 循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性</li>
</ul>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super，指向当前对象的原型对象 目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法 avaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<h4 id="对象的解构赋值-1"><a href="#对象的解构赋值-1" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象</p>
<p>解构赋值必须是最后一个参数</p>
<h4 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><ul>
<li>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</li>
<li>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</li>
<li>如果扩展运算符后面是一个空对象，则没有任何效果。</li>
<li>如果扩展运算符后面不是对象，则会自动将其转为对象。</li>
<li>如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象</li>
<li>对象的扩展运算符等同于使用 Object.assign()方法。</li>
<li>如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">const clone1 = &#123;</span><br><span class="line">  __proto__: Object.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">const clone2 = Object.assign(</span><br><span class="line">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">const clone3 = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>修改现有对象部分的属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: &#x27;New Name&#x27; // Override the name property</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式</li>
<li>扩展运算符的参数对象之中，如果有取值函数 get，这个函数是会执行的</li>
</ul>
<h3 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致</p>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。浅拷贝，同名属性的替换 ，可以用来处理数组，但是会把数组视为对象，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h4><p>返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<p>Object.getOwnPropertyDescriptors()方法的另一个用处，是配合 Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const clone = Object.create(Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const shallowClone = (obj) =&gt; Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p><strong>proto</strong>属性 用来读取或设置当前对象的 prototype 对象 建议使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替</p>
<p>如果一个对象本身部署了<strong>proto</strong>属性，该属性的值就是对象的原型。</p>
<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><p>Object.fromEntries()方法是 Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/CSS/CSS2%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/CSS/CSS2%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">块格式化上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 23:25:31" itemprop="dateCreated datePublished" datetime="2019-08-03T23:25:31+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">2.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">8(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一致性-要求和建议"><a href="#一致性-要求和建议" class="headerlink" title="一致性 要求和建议"></a>一致性 要求和建议</h3><p>CSS 渲染模型中不考虑替换元素的内容。</p>
<p>在 CSS 2.1 中，只有替换元素才能具有内在维度。对于没有可靠分辨率信息的光栅图像，必须假设每个图像源像素的大小为 1 像素单位。</p>
<p>HTML 的元素名是大小写不敏感的 但是在 XML 中是大小写敏感的</p>
<p>0 长度单位后的单位是可选的</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>E[foo] 匹配设置了”foo”属性（无论值是什么）的 E 元素</p>
<p>E[foo=”warning”] 匹配所有”foo”属性值恰好是”wraning”的 E 元素</p>
<p>E[foo~=”warning”] 匹配所有”foo”属性值为一列空格分隔的值，且其中之一恰好是”warning”的 E 元素</p>
<p>E[lang|=”en”] 匹配所有”lang”属性值为一列以”en”开头（从左向右）用连字符分隔的值的 E 元素</p>
<p>link 伪类：:link 与:visited</p>
<p>动态伪类： :hover，:active 与:focus</p>
<p>:first-line 伪元素对段落内容的第一个格式化行应用特殊样式(选择器”P:first-line”不会匹配任何真实 HTML 元素。它匹配一个（与 CSS 规范）一致的用户代理将在每个段落的开头插入的伪元素) :first-line 伪元素只能用于块容器元素</p>
<p>:first-letter 伪元素必须选择一个块的第一行的第一个字母</p>
<p>当:first-letter 和:first-line 伪元素被应用在一个具有使用:before 和:after 生成内容的元素，它们应用于元素包括生成的内容在内的首字母或首行</p>
<h3 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h3><p>为了让用户代理能够避免为不支持的媒体类型检索资源，编写者可以指定带媒体依赖（media-dependent）的@import 规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;fineprint.css&quot;</span>) print;</span><br></pre></td></tr></table></figure>
<ul>
<li>用户样式表，简单来说就是浏览器的使用者自己编写的一份默认样式表，编写者样式表，是网页的编写者编写的样式表，第一次听说这种说法</li>
</ul>
<h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>Block-level 块级元素 包含以下类型 block list-item table list-item 会生成附加的盒子，相对于主盒子放置</p>
<p>block container box 只包含块级元素或者内联块级元素，</p>
<p>匿名块级盒子 当块级盒子同时包含内联的文本和块级元素时，我们认为这里有一个匿名的盒子包围了这些文本，如果一个块级盒子包含了块级盒子，我们强制让他只包含块级盒子</p>
<p>以@开头的规则（At-rules）需要以分号来结尾</p>
<p>CSS 2.1 用户代理必须忽略在块内或在除@cherset 或@import 规则之外的任何非忽略语句之后发生的任何“@import”规则。一下是非法的，解决方法是将样式的语法放在 At-rules 之后</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;subs.css&quot;</span>;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;list.css&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>‘margin-top’, ‘margin-bottom’ 这两个属性对非替换的行内元素无效</p>
<p>两个 margin 是相邻的，当且仅当</p>
<p>都属于流内（in-flow）块级盒，处于同一个块格式化上下文</p>
<ul>
<li>没有行框（line box），空隙，内边距和边框把它们隔开（注意，因此某些 0 高度行框（见 9.4.2）会被忽略）</li>
<li>都属于垂直相邻框边界（vertically-adjacent box edges），即形成下列某一对：<ul>
<li>盒的上边距与其第一个流内（in-flow）孩子的上边距</li>
<li>盒的下边距与其下一个流内紧挨着的兄弟的上边距</li>
<li>最后一个流内孩子的下边距与其 height 计算值为’auto’的父元素的下边距</li>
<li>盒的上边距和下边距，要求该盒没有建立新的块格式化上下文，并且’min-height’计算值为 0，’height’计算值为 0 或’auto’，还没有流内孩子</li>
</ul>
</li>
<li>margin 和 padding 的百分比数值都相对于包含块，border 不能设置百分比数值</li>
</ul>
<h3 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h3><p>以下方式会创建块格式化上下文</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content 或 strict 的元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中</li>
<li><p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。</p>
</li>
<li><p>行内级元素是源文档中那些不会形成新内容块的元素，内容分布于多行 ‘display’属性的下列值能让一个元素变成行内级：’inline’，’inline-table’和’inline-block’。一个 inline-block 的内部会被格式化成一个块盒，而该元素本身会被格式化成一个原子行内级盒</p>
</li>
<li><p>display 为 table 系的元素的 postion:relative 效果是未定义的</p>
</li>
<li>盒偏移：’top’，’right’，’bottom’，’left’ 如果元素的’position’属性有一个除’static’外的值，就说它是定位元素（positioned） 百分比数值参照包含块的宽度</li>
<li>如果’left’和’right’都不是’auto’，位置就被过度约束（over-constrained）了，它们（’left’和’right’）其中有一个会被忽略。如果包含块的’direction’属性是’ltr’，那么’left’有效，’right’变成-‘left’（负的’left’）。如果包含块的’direction’属性是’rtl’，那么’right’有效，’left’被忽略</li>
<li>清除浮动的方法 overflow-hidden 创建了一个 BFC，BFC 在计算高度的 也计算浮动元素的高度</li>
<li>注意 ‘direction’属性，给表格列元素指定时，不会被列中的单元格继承，因为在文档树中，列不是单元格的祖先。因此，CSS 无法轻易获知[HTML4]的 11.3.2.1 节中”dir”属性的继承规则</li>
<li>direction 和 unicode-bidi 属性结合处理文本流方向问题（不仅，而且句子从右向左，单词也倒着写）</li>
</ul>
<h3 id="视觉格式化模型细节"><a href="#视觉格式化模型细节" class="headerlink" title="视觉格式化模型细节"></a>视觉格式化模型细节</h3><p>width 应用于除了非替换的行内元素，表格行和行组（row group） 外的所有元素,非替换的行内元素盒的内容宽度是它里面渲染的内容（的内容宽度）负值对于 width 是非法的。</p>
<p>行内非替换（non-replaced）元素 ‘width’属性不适用，其计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’。</p>
<p>行内替换元素 计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’ 如果’height’和’width’计算值都是’auto’，并且该元素还具有固有宽度，那么这个固有宽度就是’width’的应用值。</p>
<p>height 指定一个百分比高度。百分比参照生成盒的包含块的高度。如果包含块的高度没有显式指定（即取决于内容高度），并且该元素不是绝对定位的，则计算值为’auto’。根元素上的百分比高度是相对于初始包含块的 注意：对于那些包含块基于一个块级元素的绝对定位元素，百分比根据这个元素的内边距框（padding box）的高度来计算。这与 CSS1 不同，（CSS1 中）百分比总是根据父级元素的内容框（content box）来计算</p>
<p>line-height 的百分比参考元素自身的字体大小</p>
<p>vertical-align 的百分比是行高</p>
<h3 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h3><ul>
<li>visibility hidden 生成的盒是不可见的（完全透明，什么都不绘制），但仍然会影响布局。而且该元素具有’visibility: visible’的后代将是可见的</li>
</ul>
<h3 id="颜色与背景"><a href="#颜色与背景" class="headerlink" title="颜色与背景"></a>颜色与背景</h3><ul>
<li>background-attachment 指定了它应该相对视口固定，还是随包含块滚动</li>
</ul>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul>
<li>字母与单词间距 ‘letter-spacing’和’word-spacing’</li>
<li>‘text-transform’属性 转换单词大小写</li>
<li>‘white-space’属性 决定如何处置换行符</li>
</ul>
<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>cursor crosshair 简单十字 move 暗示可移动 text 暗示可选中的文本 wait 暗示正忙<br>outline 当元素具有焦点时，可应用轮廓属性，该属性不占用空间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/08/03/CSS/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/03/CSS/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">块格式化上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-03 20:13:10" itemprop="dateCreated datePublished" datetime="2019-08-03T20:13:10+00:00">2019-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">2.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">8(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一致性-要求和建议"><a href="#一致性-要求和建议" class="headerlink" title="一致性 要求和建议"></a>一致性 要求和建议</h2><p>CSS 渲染模型中不考虑替换元素的内容。</p>
<p>在 CSS 2.1 中，只有替换元素才能具有内在维度。对于没有可靠分辨率信息的光栅图像，必须假设每个图像源像素的大小为 1 像素单位。</p>
<p>HTML 的元素名是大小写不敏感的 但是在 XML 中是大小写敏感的</p>
<p>0 长度单位后的单位是可选的</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>E[foo] 匹配设置了”foo”属性（无论值是什么）的 E 元素</p>
<p>E[foo=”warning”] 匹配所有”foo”属性值恰好是”wraning”的 E 元素</p>
<p>E[foo~=”warning”] 匹配所有”foo”属性值为一列空格分隔的值，且其中之一恰好是”warning”的 E 元素</p>
<p>E[lang|=”en”] 匹配所有”lang”属性值为一列以”en”开头（从左向右）用连字符分隔的值的 E 元素</p>
<p>link 伪类：:link 与:visited</p>
<p>动态伪类： :hover，:active 与:focus</p>
<p>:first-line 伪元素对段落内容的第一个格式化行应用特殊样式(选择器”P:first-line”不会匹配任何真实 HTML 元素。它匹配一个（与 CSS 规范）一致的用户代理将在每个段落的开头插入的伪元素) :first-line 伪元素只能用于块容器元素</p>
<p>:first-letter 伪元素必须选择一个块的第一行的第一个字母</p>
<p>当:first-letter 和:first-line 伪元素被应用在一个具有使用:before 和:after 生成内容的元素，它们应用于元素包括生成的内容在内的首字母或首行</p>
<h2 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h2><p>为了让用户代理能够避免为不支持的媒体类型检索资源，编写者可以指定带媒体依赖（media-dependent）的@import 规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;fineprint.css&quot;</span>) print;</span><br></pre></td></tr></table></figure>
<p>用户样式表，简单来说就是浏览器的使用者自己编写的一份默认样式表，编写者样式表，是网页的编写者编写的样式表，第一次听说这种说法</p>
<h2 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h2><p>Block-level 块级元素 包含以下类型 block list-item table list-item 会生成附加的盒子，相对于主盒子放置</p>
<p>block container box 只包含块级元素或者内联块级元素，</p>
<p>匿名块级盒子 当块级盒子同时包含内联的文本和块级元素时，我们认为这里有一个匿名的盒子包围了这些文本，如果一个块级盒子包含了块级盒子，我们强制让他只包含块级盒子</p>
<p>以@开头的规则（At-rules）需要以分号来结尾</p>
<p>CSS 2.1 用户代理必须忽略在块内或在除@cherset 或@import 规则之外的任何非忽略语句之后发生的任何“@import”规则。一下是非法的，解决方法是将样式的语法放在 At-rules 之后</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;subs.css&quot;</span>;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;list.css&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><code>margin-top</code>, <code>margin-bottom</code> 这两个属性对非替换的行内元素无效</p>
<p>两个 margin 是相邻的，当且仅当</p>
<p>都属于流内（in-flow）块级盒，处于同一个块格式化上下文</p>
<ul>
<li>没有行框（line box），空隙，内边距和边框把它们隔开（注意，因此某些 0 高度行框（见 9.4.2）会被忽略）</li>
<li>都属于垂直相邻框边界（vertically-adjacent box edges），即形成下列某一对：<ul>
<li>盒的上边距与其第一个流内（in-flow）孩子的上边距</li>
<li>盒的下边距与其下一个流内紧挨着的兄弟的上边距</li>
<li>最后一个流内孩子的下边距与其 height 计算值为’auto’的父元素的下边距</li>
<li>盒的上边距和下边距，要求该盒没有建立新的块格式化上下文，并且’min-height’计算值为 0，’height’计算值为 0 或’auto’，还没有流内孩子</li>
</ul>
</li>
<li>margin 和 padding 的百分比数值都相对于包含块，border 不能设置百分比数值</li>
</ul>
<h2 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h2><p>以下方式会创建块格式化上下文</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content 或 strict 的元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中</li>
<li>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。</li>
<li>行内级元素是源文档中那些不会形成新内容块的元素，内容分布于多行 ‘display’属性的下列值能让一个元素变成行内级：’inline’，’inline-table’和’inline-block’。一个 inline-block 的内部会被格式化成一个块盒，而该元素本身会被格式化成一个原子行内级盒</li>
<li>display 为 table 系的元素的 postion:relative 效果是未定义的</li>
<li>盒偏移：’top’，’right’，’bottom’，’left’ 如果元素的’position’属性有一个除’static’外的值，就说它是定位元素（positioned） 百分比数值参照包含块的宽度</li>
<li>如果’left’和’right’都不是’auto’，位置就被过度约束（over-constrained）了，它们（’left’和’right’）其中有一个会被忽略。如果包含块的’direction’属性是’ltr’，那么’left’有效，’right’变成-‘left’（负的’left’）。如果包含块的’direction’属性是’rtl’，那么’right’有效，’left’被忽略</li>
<li>清除浮动的方法 overflow-hidden 创建了一个 BFC，BFC 在计算高度的 也计算浮动元素的高度</li>
<li>注意 ‘direction’属性，给表格列元素指定时，不会被列中的单元格继承，因为在文档树中，列不是单元格的祖先。因此，CSS 无法轻易获知[HTML4]的 11.3.2.1 节中”dir”属性的继承规则</li>
<li>direction 和 unicode-bidi 属性结合处理文本流方向问题（不仅，而且句子从右向左，单词也倒着写）</li>
</ul>
<h2 id="视觉格式化模型细节"><a href="#视觉格式化模型细节" class="headerlink" title="视觉格式化模型细节"></a>视觉格式化模型细节</h2><p>width 应用于除了非替换的行内元素，表格行和行组（row group） 外的所有元素,非替换的行内元素盒的内容宽度是它里面渲染的内容（的内容宽度）负值对于 width 是非法的。</p>
<p>行内非替换（non-replaced）元素 ‘width’属性不适用，其计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’。</p>
<p>行内替换元素 计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’ 如果’height’和’width’计算值都是’auto’，并且该元素还具有固有宽度，那么这个固有宽度就是’width’的应用值。</p>
<p>height 指定一个百分比高度。百分比参照生成盒的包含块的高度。如果包含块的高度没有显式指定（即取决于内容高度），并且该元素不是绝对定位的，则计算值为’auto’。根元素上的百分比高度是相对于初始包含块的 注意：对于那些包含块基于一个块级元素的绝对定位元素，百分比根据这个元素的内边距框（padding box）的高度来计算。这与 CSS1 不同，（CSS1 中）百分比总是根据父级元素的内容框（content box）来计算</p>
<p>line-height 的百分比参考元素自身的字体大小</p>
<p>vertical-align 的百分比是行高</p>
<h2 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h2><p><code>visibility hidden</code> 生成的盒是不可见的（完全透明，什么都不绘制），但仍然会影响布局。而且该元素具有<code>visibility: visible</code> 的后代将是可见的</p>
<h2 id="颜色与背景"><a href="#颜色与背景" class="headerlink" title="颜色与背景"></a>颜色与背景</h2><p>background-attachment 指定了它应该相对视口固定，还是随包含块滚动<br>文本<br>字母与单词间距 <code>letter-spacing’和’word-spacing</code><br><code>text-transform</code>属性 转换单词大小写<br><code>white-space</code>属性 决定如何处置换行符</p>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>cursor crosshair 简单十字 move 暗示可移动 text 暗示可选中的文本 wait 暗示正忙<br>outline 当元素具有焦点时，可应用轮廓属性，该属性不占用空间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机系统基础学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-06 23:33:37" itemprop="dateCreated datePublished" datetime="2019-06-06T23:33:37+00:00">2019-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">863(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">3(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数字逻辑电路基础"><a href="#数字逻辑电路基础" class="headerlink" title="数字逻辑电路基础"></a>数字逻辑电路基础</h2><p>全加器 溢出标志的逻辑表达式 <script type="math/tex">OF=C_n \oplus C_(n-1)</script> 因为若为两个正数相加，最高位必然没有进位，而弱次高位有进位，则说明溢出 若为两个负数相加，最高位必然有进位，若次高位没有进位，则说明溢出</p>
<h2 id="IEEE754-标准"><a href="#IEEE754-标准" class="headerlink" title="IEEE754 标准"></a>IEEE754 标准</h2><ul>
<li>32 位包括 1 位符号位 8 位阶码 23 位有效位</li>
<li>64 位包括 1 位符号位 52 位有效位</li>
<li>规格化尾数最高位总是 1，所以隐含表示，省略一位</li>
<li>阶码使用移码表示</li>
<li>全 0 +0</li>
<li>符号位 1 之后全 0 -0</li>
<li>浮点数除 0 的结果是正负无穷大，而不是一出一场</li>
<li>0 11111111 00000000000000000000000 正无穷大</li>
<li>1 11111111 00000000000000000000000 负无穷大</li>
<li>Not a Number 非数 sqrt(-0.4) 0/0 使用全 1 的阶码和非 0 的尾数</li>
<li>非规格化数<ul>
<li>阶码全 0 尾数非 0</li>
</ul>
</li>
</ul>
<h4 id="C-语言中涉及的运算"><a href="#C-语言中涉及的运算" class="headerlink" title="C 语言中涉及的运算"></a>C 语言中涉及的运算</h4><ul>
<li>无符号数 逻辑左（右）移动，有符号数 算数左（右）移动</li>
<li>溢出标志 of，最高位和次高位的进位 Cn 异或 Cn-1， 当两个正数相加时，最高位不会进位，若次高位进位，则为溢出 ，当两个负数相加，最高位必然进位，若次高位不进位，则为溢出，正数加负数永远不会溢出</li>
<li>乘法指令分有符号乘和无符号乘 若只取低 n 位 不考虑溢出 则可以只使用无符号乘 由程序员自行判断是否溢出</li>
<li>乘法可以转换成加法和移位运算的组合</li>
<li>对于带符号正数 出了 -2^n / -1 = 2^n-1 会发生溢出外，其余情况都不会发生溢出</li>
<li>对于正数 对商取 floor 对于负数 对商取 ceil</li>
<li>编译器对于除数为 2 的倍数的除法运算使用移位优化，对于无符号数，带符号数正整数，移除的低位直接舍弃，对于带符号负整数，由于商取 ceil，需要现加上一个偏移量 2^k-1，然后再右移 k 位，低位截断</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>汇编结果是一个可重定位目标文件，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容</p>
<p>生成的.o 文件可重定位的目标文件 程序中的地址尚未确定 通过链接后方可执行</p>
<h4 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h4><p>柱面号就是磁道号</p>
<h4 id="层次结构存储系统"><a href="#层次结构存储系统" class="headerlink" title="层次结构存储系统"></a>层次结构存储系统</h4><ul>
<li>非易失存储器 Nonvolatile Memory 易失存储器 Volitile Memory</li>
<li>SRAM 不采用地址引脚复用方式，DRAM 采用地址引脚复用方式</li>
<li>内存位宽是 64bit DDR3 采用 8 位预读，若内部核心频率为 133.25MHZ，则每秒传送的数据次数为 133.25M*8 = 1066M 次，带宽为 1066 M*8B=8.5GB/S</li>
<li>当写不命中时，有写分配法和非写分配法。采用写分配法时，需要分配一个 cache 空行，以将主存块复制到 cache，当采用非写分配法时，不将主存块分配到 cache。因此，回写策略下，一定采用写分配法，在全写策略下，两种分配方式都可采用</li>
<li>栈和堆合称堆栈，栈区从 0xc0000000 开始向低地址增长，共享库区从 0x400000000 向高地址增长，只读区从 0x08048000 开始向高地址增长。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/26/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E6%96%B9%E6%A1%88%E6%95%B0%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/26/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E6%96%B9%E6%A1%88%E6%95%B0%E9%87%8F/" class="post-title-link" itemprop="url">背包问题记录方案数量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-26 13:39:48" itemprop="dateCreated datePublished" datetime="2019-05-26T13:39:48+00:00">2019-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">240(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目是求 2019 可以由多少个两两不同的质因数组成，可以转化为 01 背包模型，将每个质因数的价值和花费等同于其数值大小。那么问题就简单变为了求 01 背包的方案数量。<br>代码如下<br>注意初始化 dp[0] =1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> isp[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isp[<span class="number">0</span>] = isp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                isp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">seive</span>();</span><br><span class="line">    <span class="keyword">int</span> dp[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2019</span>; j &gt;= prime[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - prime[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">2019</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/26/%E7%AE%97%E6%B3%95/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%85%AC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/26/%E7%AE%97%E6%B3%95/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%85%AC%E5%BC%8F/" class="post-title-link" itemprop="url">约数个数公式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-26 11:29:06" itemprop="dateCreated datePublished" datetime="2019-05-26T11:29:06+00:00">2019-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">361(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">1(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目是求有 100 个约数的数字的最小值。有两种方法去做，一种直接暴力求每个数的约数个数，直到找到第一个约数为 100 的数。第二种用到了约数定理，首先用质因数分解的方法求出每个质因数的指数：</p>
<script type="math/tex; mode=display">n = a_{1}^{p1}*a_{2}^{p2}*...*a_{n}^{pn}</script><p>那么 n 的约数个数可以用以下公式求得：</p>
<script type="math/tex; mode=display">(p1+1)*(p2+1)*...*(pn+1)</script><p>很简单的乘法原理的思想，对于质因数 $ a_1 $ 可以取 0,1,2…n 一共 n+1 个，其他同理。<br>如何证明这样不会取得相同的因数呢？<br>假设两个因数</p>
<script type="math/tex; mode=display">b_1 = a_1 * a_1 * a_2 * a_2 * a_3 \\ b_2 = a_1 * a_2 * a_3 * a_4</script><p>如果 $ b_1 = b_2 $ 那么有 $ a_1 * a _2 = a_4 $，显然与$a_4$是一个质数矛盾，所以不存在重复的情况。<br>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">2</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % factor != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            factor++;</span><br><span class="line">            a.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            n = n / factor;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= (a[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">solve</span>(n);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ret &lt;&lt; endl;5</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/05/17/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/17/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">最小生成树算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-17 18:13:46" itemprop="dateCreated datePublished" datetime="2019-05-17T18:13:46+00:00">2019-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">1.4k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">6(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最小生成树的算法有 Prim 和 Kruskal,首先，先说明一个结论，定义图有 n 个点，m 条边, prim 的复杂度为 O(nlogm)，kk 的复杂度为 O(mlogm)，可见 prim 更适合稠密图，而 kk 更适合稀松图。</p>
<p>当连通图中各边权值不相等时,最小生成树唯一;当有相等的权值时最小生成树可能不唯一。</p>
<p>prim 算法的思想是，首先选取一个点，加入点集，然后将该点所连的边加入边集，重复以下步骤。<br>选取当前边集合中权值最小的边，如果该边所连接的点不在点集中，将该边的另一个端点加入点集合，同时将该端点所连接的边加入边的集合。<br>当选取了 n-1 条边后，得到最小生成树。使用堆优化后的时间复杂度为 O(nlogm)。</p>
<p>证明，假设 prim 生成的树 T* 不是最小生成树，设最小生成树为 T，T* 中 <u,v> 不属于 T ，那么一定有将 <u,v> 加入 T，T 中形成环(此时共有 n 条边，一定存在环)，可以通过删除环上任意一条边(根据构建过程，<u,v>是点所连边中权值最小的)得到更小的生成树，因此 T 不存在。</u,v></u,v></u,v></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">        <span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">        <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; gra[maxn];</span><br><span class="line">priority_queue&lt;edge&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[<span class="number">1</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        edge tmp = gra[<span class="number">1</span>][i];</span><br><span class="line">        pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n - <span class="number">1</span> &amp;&amp; !pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        edge top = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> to = top.to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to])</span><br><span class="line">        &#123;</span><br><span class="line">            res += top.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[to].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                edge tmp = gra[to][i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[tmp.to])</span><br><span class="line">                &#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gra[from].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, w));</span><br><span class="line">    gra[to].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>次小生成树问题一般使用 prim 算法解决。设最小生成树的权值为 W，因为 prim 算法可以记录生成树路径，思想是在剩下的边集中尝试将每一条边 (u,v) 加入生成树中 ，此时必然可以构成一个环，此时要删除权值最大的一条边。可以用一个 max 数组记录路径 path(u,v) 上的权值最大值 max(u,v)，那么最终的答案就是 min (W + w(u,v) - max(u,v) )，max(u，v)可以在循环过程中求得。</p>
<p>网上的算法都是 O(V^2)的，我自己尝试了，似乎写不出堆优化的后的次小生成树写法，记录路径要用到 LCA。下面是模板的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">bool</span> use[maxn][maxn]; <span class="comment">// 最小生成树使用的边</span></span><br><span class="line"><span class="keyword">int</span> maxv[maxn][maxn]; <span class="comment">// u-&gt;v中边权最大值</span></span><br><span class="line"><span class="keyword">int</span> cost[maxn][maxn]; <span class="comment">// u-&gt;v的花费</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span> use);</span><br><span class="line">    <span class="built_in">memset</span>(maxv, <span class="number">0</span>, <span class="keyword">sizeof</span> maxv);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        pre[i] = s;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, minw = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; minw)</span><br><span class="line">            &#123;</span><br><span class="line">                u = i, minw = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minw == INF)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 不连通</span></span><br><span class="line">        res += dis[u];</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        use[u][pre[u]] = use[pre[u]][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                maxv[u][v] = maxv[v][u] = <span class="built_in">max</span>(maxv[v][pre[u]], dis[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; cost[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = cost[u][v], pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">smst</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// s:起点 ans:最小生成树的值</span></span><br><span class="line">    <span class="keyword">int</span> res = INF, ans = <span class="built_in">prim</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (cost[i][j] != INF &amp;&amp; !use[i][j]) <span class="comment">// i-&gt;j有边且不在最小生成数里</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, ans + cost[i][j] - maxv[i][j]);</span><br><span class="line">    <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cost[i][j] = cost[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        cost[from][to] = <span class="built_in">min</span>(cost[from][to], w);</span><br><span class="line">        cost[to][from] = <span class="built_in">min</span>(cost[to][from], w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">smst</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kruskal 的算法思想是，对于一个有 n 个点和 m 条边的无向图来说，先对其边按照权值按照从小到大的顺序进行排序。初始化一个并查集。每次取排好序的边集中权值最小的一条边，若这条边与已经选取的边不构成回路，那么将这条边加入到最终的生成树中，最终得到的生成树一定是最小生成树。回路的判断用并查集来实现。时间复杂度为 O(mlogm)</p>
<p>假设 Kruskal 算法对 n≤k 阶图适用，那么，在 k+1 阶图 G 中，我们把最短边的两个端点 a 和 b 做一个合并操作，即把 u 与 v 合为一个点 v’，把原来接在 u 和 v 的边都接到 v’上去，这样就能够得到一个 k 阶图 G’(u,v 的合并是 k+1 少一条边)，G’最小生成树 T’可以用 Kruskal 算法得到。</p>
<p>我们证明 T’+{<u,v>}是 G 的最小生成树。</u,v></p>
<p>用反证法，如果 T’+{<u,v>}不是最小生成树，最小生成树是 T，即 W(T)<W(T'+{<u,v>})。显然 T 应该包含<u,v>，否则，可以用<u,v>加入到 T 中，形成一个环，删除环上原有的任意一条边，形成一棵更小权值的生成树。而 T-{<u,v>}，是 G'的生成树。所以 W(T-{<u,v>})=W(T’)，也就是 W(T)=W(T’)+W(<u,v>)=W(T’+{<u,v>})，产生了矛盾。于是假设不成立，T’+{<u,v>}是 G 的最小生成树，Kruskal 算法对 k+1 阶图也适用。</u,v></u,v></u,v></u,v></u,v></u,v></u,v></W(T'+{<u,v></u,v></p>
<p>由数学归纳法，Kruskal 算法得证。</p>
<p>算法的实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;</span><br><span class="line">&#125; edges[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u[x] == x ? x : u[x] = <span class="built_in">find</span>(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(edges[i].from);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">find</span>(edges[i].to);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">merge</span>(x, y);</span><br><span class="line">            res += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 KK 算法，求次小生成树的方法是维护一个子图集合和一个 maxw 数组，maxw 数据记录子图集之间的最大边权。开始每个点都属于一个子图。在进行并查集合并操作的时候合并子图。每次插入边的时候，更新边端点所在子图的最大边权为新加入的边的权值。显然根据 KK 算法的思想，每次加入的边的权值都是连接的两个子图中权值中最大的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[maxn];</span><br><span class="line"><span class="keyword">int</span> maxw[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w, vis;</span><br><span class="line">&#125; edges[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge &amp;a, edge &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u[x] == x ? x : u[x] = <span class="built_in">find</span>(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u[x] = y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gra[y].<span class="built_in">push_back</span>(gra[x][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = i;</span><br><span class="line">        gra[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(edges[i].from);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">find</span>(edges[i].to);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; gra[x].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; gra[y].<span class="built_in">size</span>(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxw[gra[x][j]][gra[y][k]] = maxw[gra[y][k]][gra[x][j]] = edges[i].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            edges[i].vis = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">merge</span>(x, y);</span><br><span class="line">            cnt++;</span><br><span class="line">            res += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seckk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">kk</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].vis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = edges[i].w;</span><br><span class="line">            <span class="keyword">int</span> wmax = maxw[edges[i].from][edges[i].to];</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, res + w - wmax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edges[i].from, &amp;edges[i].to, &amp;edges[i].w);</span><br><span class="line">        edges[i].vis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">seckk</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiezi19971225</p>
  <div class="site-description" itemprop="description">记录编程学习路上的点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiezi19971225</span>
</div>
  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"/>
  <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备17001385号-1</a>
  <br/>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
