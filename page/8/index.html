<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="baidu-site-verification" content="5IfwMCE5hH" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.jiezi19971225.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录编程学习路上的点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Jiez19971225‘s Blog">
<meta property="og:url" content="http://www.jiezi19971225.cn/page/8/index.html">
<meta property="og:site_name" content="Jiez19971225‘s Blog">
<meta property="og:description" content="记录编程学习路上的点滴">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiezi19971225">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.jiezi19971225.cn/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jiez19971225‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiez19971225‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做自己爱做的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络学习笔记之物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 19:20:07" itemprop="dateCreated datePublished" datetime="2019-03-03T19:20:07+00:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">3.2k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">11(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><ul>
<li>物理层的作用是尽可能屏蔽掉传输媒体和通信手段的差异，用于物理层的协议常称为规程（procedure）</li>
<li>数据在通信线路上的传输方式一般都是串行传输</li>
<li>可以将物理层的主要任务描述为与传输媒体的接口有关的一些特性<ul>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ul>
</li>
</ul>
<h3 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h3><h4 id="数据通信的基本模型"><a href="#数据通信的基本模型" class="headerlink" title="数据通信的基本模型"></a>数据通信的基本模型</h4><ul>
<li>一个数据通信系统可以分为三大部分，即源系统（发送端，发送方）、传输系统（或传输网络）和目的系统（接受端、接收方）。<ul>
<li><strong>源点</strong> 源点设备产生要传输的数据，如从计算机的键盘输入汉字，计算机产生输出的数字比特流。又称源站或者信源。</li>
<li><strong>发送器</strong> 源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器是调制器。</li>
<li><strong>接收器</strong> 接受传输系统传送过来的信号，把它转换为能够被目的设备处理的信息。典型的接收器就是解除调器。它把模拟信号解调，还原成数字信号</li>
<li><strong>终点</strong> 终点设备从接收器获取传送来的数字比特流，然后把信息输出（例如，把汉字在计算机屏幕上显示出来）。终点站又称目的站，或信宿。</li>
</ul>
</li>
<li>通信的目的是传送<strong>消息（message）</strong>，如话音，文字，图像，视频都是消息</li>
<li><strong>数据（data）</strong>是运送消息的实体，通常是有意义的符号序列</li>
<li>信号是数据的电气或者电磁的表现</li>
<li><strong>模拟信号</strong>，或<strong>连续信号</strong>，代表消息的参数的取值是连续的</li>
<li><strong>数字信号</strong>，或<strong>离散信号</strong>，代表消息的参数的取值是离散的</li>
</ul>
<h4 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h4><ul>
<li><strong>信道</strong>（channel）表示向某一个方向传送消息的媒体</li>
<li><strong>单向通信</strong>，又称为<strong>单工通信</strong>，只有一个方向的通信而没有反方向的交互，代表有无线电广播或者有线电广播</li>
<li><strong>双向交替通信</strong>，又称为<strong>半双工通信</strong>，通信的双方都可以发送消息，但不能双方同时发送或接受</li>
<li><strong>双向同时通信</strong>，又称为<strong>全双工通信</strong>，通信的双方可以同时发送和接收信息</li>
<li>来自信源的信号常称为<strong>基带信号</strong>，即基本频带信号。基带信号往往包含较多低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或者直流分量，因此必须对基带信号进行<strong>调制（modulation）</strong><ul>
<li><strong>基带调制</strong>，仅仅对基带信号的波形进行变换，使它能够与信道的特性相适应，这种过程是把狮子信号转换成另一种形式的数字信号，也称为<strong>编码</strong></li>
<li>使用<strong>载波（carrier）</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并且转换为模拟信号，这样就能够更好地在模拟信道中传输，经过载波调制后的信号称为<strong>带通信号</strong>（仅在一段频率范围内能够通过信道，可以被正弦公式描述，又叫做宽带信号，其携带的数据量更多），使用载波的调制称为带通调制。</li>
<li>对模拟信号数字化取样，将抽样信号变为离散时间，离散幅度的数字化信号，编码后称为一个二进制码组输出，这种方式叫做<strong>脉编调制</strong>，是 VCD 和 DVD 的视频编码原理。</li>
</ul>
</li>
<li>常用编码方式<br><img src="/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/编码方式.jpg" alt="常用的编码方式"><br><em> <strong>不归零制</strong> 正电平代表 1 复电平代表 0
</em> <strong>归零制</strong> 正脉冲代表 1，负脉冲代表 0<br><em> <strong>曼彻斯特编码</strong> 位周期中心的向上跳代表 0，向下跳代表 1，也可以反过来定义
</em> <strong>差分曼彻斯特编码</strong> 在每一位的中心处都有跳变，位开始边界有跳变代表 0，位开始边界没有跳变代表 1 * 不归零不能从波形本身提取信号时钟频率，这叫做没有自同步能力，而曼彻斯特编码具有自同步能力</li>
<li>基本的带通调制方法<br><img src="/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/带通调制方法.jpg" alt="基本的带通调制方法"><br><em> <strong>调幅（AM）</strong> 载波的振幅随着基带数字信号而变化，如 0 或者 1 分别对应无载波或者有载波输出
</em> <strong>调频（FM）</strong> 载波的频率随着基带数字信号而变化，如 0 或者 1 分别对应于频率 f1 或者 f2 * <strong>调相（PM）</strong> 载波的初始相位随着基带数字变化而变化，如 0 或者 1 分别对应于相位 0 或者 180 度</li>
<li>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法，例如<strong>正交振幅调制 QAM（Quadrature Amplitede Modulation）</strong></li>
</ul>
<h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><ul>
<li><strong>码间串扰</strong>是指信号中的高频分量在传输时收到缩减，接收端收到的波形前沿和后沿不再那么陡峭，码元之间的时间间隔也不明确，码元之间失去了清晰的界限</li>
<li><strong>奈氏准则</strong>给出了假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。我们需要知道，在任何信道，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的识别称为不可能</li>
<li><strong>信噪比</strong> 是信号的平均功率和噪声的平均功率之比，常记为 S/N，并用分贝作为度量<script type="math/tex; mode=display">信噪比(dB) = 10 log_{10}(S/N)</script></li>
<li>香农公式指出 信道的极限信息传输速率 C 是，W 是信道的带宽，S 是信道内所传信号的平均速率，N 为信道内部的高斯噪声功率，它表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高<script type="math/tex; mode=display">C = W log_{2}(1+S/N) (bit/s)</script></li>
<li>对于频带宽度已经确定的信道，如果信噪比不能再提高，码元传输速率也达到了上限，可以用编码的方法让每一个码元携带更多比特的信息量</li>
</ul>
<h4 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h4><ul>
<li><strong>传输媒体</strong>也称为传输介质或者传播媒介<ul>
<li><strong>导引型传输媒体</strong> 电磁波沿着固定媒介（铜线或者光纤）传播</li>
<li><strong>非导引型传输媒体</strong> 媒介是自由空间，称为无线传输</li>
</ul>
</li>
</ul>
<h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul>
<li>导引型传输媒体<ul>
<li>双绞线 把两根互相绝缘的铜导线并排放在一起，然后<strong>绞合（twist）</strong>起来。绞合可以减少对相邻导线的电磁干扰</li>
<li>同轴电缆 由内导体铜质芯线（单股实心线或多股绞合线），绝缘层，网状编织体的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成，具有很好的抗干扰特性</li>
<li>光缆</li>
</ul>
</li>
</ul>
<h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><ul>
<li>非导引型传输媒体<ul>
<li>甚高频</li>
<li>特高频</li>
<li>超高频</li>
<li>极高频</li>
</ul>
</li>
<li>短波通信（高频通信）主要靠电离层的反射。但电离层不稳定所产生的衰落现象和电离层反射产生的多径效应，使得短波信道的通话质量较差，因此短波无线电台传输数据一般都是低速传输</li>
<li>传统的微波通信主要有两种方式，地面微波接力通信（通过中继站）和卫星通信</li>
</ul>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="频分复用，时分复用和统计时分复用"><a href="#频分复用，时分复用和统计时分复用" class="headerlink" title="频分复用，时分复用和统计时分复用"></a>频分复用，时分复用和统计时分复用</h4><ul>
<li><strong>频分复用</strong>的所有用户在同样的时间占用不同的带宽资源</li>
<li><strong>时分复用</strong>是所有的用户在不同的时间占用同样的频带宽度</li>
<li>复用器和分用器成对地使用</li>
<li>分用器的作用和复用器相反，它把高速信道传送过来的数据进行分用，分别送交到相应的用户</li>
<li><strong>统计时分复用（Statistic TDM）</strong>是一种改进的时分复用，它能明显地提高信道的利用率，集中器常使用这种统计时分复用。其用 STDM 帧传送复用的数据，每一个 STDM 帧小于连接在集中器上的用户数。各个用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入 STDM 帧中，对没有数据的缓存就跳过去，当一个帧的数据放满了，就发送出去。因此 STDM 帧不是固定分配时间间隙，而是按需动态的分配时间间隙。</li>
</ul>
<h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><ul>
<li><strong>波分复用（Wavelength Division Multiplexing）</strong>就是光的频分复用。</li>
</ul>
<h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><ul>
<li><strong>码分复用（Code Division Multiplexing）</strong> 更常用的名词是<strong>码分多址 CDMA（Code Division Multiple Access）</strong>。各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰，这种系统有很强的抗干扰能力</li>
<li>CDMA 使用了<strong>扩频（spread spectrum）</strong>的方式，属于<strong>直接序列扩频 DSSS（Direct Sequence Spread Spectrum）</strong>，另一种是<strong>跳频扩频 FHSS（Frequency Hopping Spread Spectrum）</strong></li>
</ul>
<h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><ul>
<li>最初在数字传输系统中使用的传输标准是<strong>脉冲编码调制 PCM</strong>，现在的高速数字传输系统使用同步光纤网<strong>SONET</strong>（美国标准）或者<strong>同步数字系列 SDH（Synchronous Digital Hierarchy）</strong>（国际标准）</li>
</ul>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><ul>
<li><strong>非对称数字用户线 ADSL（Asymmetric Digital Subscriber LIne）</strong>是用数字技术对现有的模拟电话用户线进行改造，使其能够承载数字宽带业务。他需要在用户线的两端各安装一个 ADSL 调制解调器，我国采用的是<strong>离散多音调 DMT（Discrete Multi-Tone）</strong>调制技术。ADSL 不能保证固定的数据率。</li>
<li>基于 ADSL 的接入网由数字用户线接入复用器，用户线和用户家中的一些设施三部分组成<ul>
<li><strong>数字用户线接入复用器 ASLAM（DSL Access Multiplexer）</strong>，包括许多 ADSL 调制解调器，ADSL 调制解调器又称为<strong>接入端单元 ATU（Access Termination Unit）</strong></li>
<li>用户电话通过<strong>电话分离器</strong>和 ATU-R（远端站的调制解调器）连接，它利用低通滤波器将电话信号和数字信号分开。</li>
<li>ADSL 有两个接口，较大的 RJ-45 和计算机相连，较小的 RJ-11 和电话分离器项链。</li>
</ul>
</li>
</ul>
<h4 id="光纤同轴混合网（HFC-网）"><a href="#光纤同轴混合网（HFC-网）" class="headerlink" title="光纤同轴混合网（HFC 网）"></a>光纤同轴混合网（HFC 网）</h4><ul>
<li><strong>光纤同轴混合网 HFC（Hybird Fiber Coax）</strong>是在有线电视网的基础，对有线电视网进行了改造，将有线电视网中的同轴电缆主干部分改换为光纤。光纤藏头端连接到<strong>光纤节点（fiber node）</strong>，在光纤节点被转换为电信号，然后通过同轴电缆传输到每个用户家庭。</li>
<li>为了使现有的模拟电视机能够接受数字电视信号，需要<strong>机顶盒（set-top box）</strong>。为了用户利用 HFC 网接入互联网，还需要增加<strong>电缆调制解调器（cable modem）</strong></li>
</ul>
<h4 id="光纤入户（FTTX）"><a href="#光纤入户（FTTX）" class="headerlink" title="光纤入户（FTTX）"></a>光纤入户（FTTX）</h4><ul>
<li><strong>光纤入户（Fiber To The Home）</strong>是技术上的最好选择，将光纤一直铺设到用户家庭，在光纤入户后，才将光信号转换为电信号。</li>
<li>一个家庭远用不了一根光纤的通信容量，在光纤干线和广大用户之间，还铺设一段中间的转换装置即<strong>光配线网 ODN（Optical Distribution Network）</strong>，使数十个家庭能够共享一根光纤干线。</li>
<li><strong>光线路终端 OLT（Optical Line Terminal）</strong>是连接到光纤干线的终端设备，OLT 把收到的下行数据发往无源的 1：N 的<strong>光分路器（splitter）</strong>，然后用广播的方式向所有用户端的<strong>光网络单元 ONU（Optical Network Unit）</strong>发送。当 ONU 发送上行数据术，先将电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 的方式发往 OLT，发送时间和长度都有 OLT 集中控制。</li>
<li>光配线网采用波分复用，上行和下行分别使用不同的波长</li>
<li>最流行的无源光配线网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/02/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/02/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">go学习笔记-基础与特性总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 20:04:10" itemprop="dateCreated datePublished" datetime="2019-03-02T20:04:10+00:00">2019-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">2.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">9(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>Go 在用一个目录下不能有多个 package</li>
<li>Go 中立即返回函数中局部变量的地址也是安全的</li>
<li>Go 中 new 只是一个预定义的函数，不是一个关键字，因此可以将 new 重新定义为别的类型使用，这样将无法使用 new 函数</li>
<li>Go 的早期版本 GOMAXPROCS 可用核数被设置为 1 因此无法真正做到并行 而 go1.6 版本后 GOMAXPROCS 被设置为可用核心数目</li>
<li>Go 中++ —是语句 不是表达式，并且只有后缀形式，因此以下的代码是错的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">5</span></span><br><span class="line">b := a++ <span class="comment">//不能当做表达式使用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Go 不支持隐式类型转换</li>
<li>Go 不支持三元操作符</li>
<li>Go 只有值传递</li>
<li>Go 指针不能进行运算</li>
<li>特殊只写变量_用于忽略值占位</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Go 的基本类型有 Basic types<ul>
<li>bool</li>
<li>string golang 是没有 char 的 string 在 go 中属于基本数据类型 不可变类型</li>
<li>int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr</li>
<li>byte 是 uint8 的别名</li>
<li>rune 是 int32 的别名 代表一个 Unicode 码</li>
<li>float32 float64</li>
<li>complex64 complex128 Go 原生支持复数类型</li>
</ul>
</li>
<li>16 进制的转义形式是\xhh。8 进制的转移形式是\ooo，o 代表一个八进制数字，但是不能超过\377（对应十进制的 255）</li>
<li>无符号数往往只有在位运算或其他特殊的运算场景才会使用</li>
<li>%q 打印带有单引号的字符</li>
<li>函数外的每个语句都必须以关键字开始（<code>var</code>、<code>func</code>、等等），<code>:=</code> 结构不能使用在函数外。</li>
<li>字符串和字节 slice 可以相互转换 一个[]bytes 转换分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组</li>
<li>将一个整数转为字符串有两种方法，一种是用 fmt.Sprintf 返回一个格式化的字符串，另一种方法是用 strconv.Itoa</li>
<li>FormatInt(FormatUint) func(i int64, base int) string 可以用不同的进制格式化数字</li>
<li>strconv.ParseInt 或者 strconv.Atoi 可以用来解析一个字符串为证书，还有用于解析无符号整数的 ParseUint</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过自定义类型来实现枚举类型限制</li>
<li>math.NaN 与任何数都不相等</li>
<li>Go 语言中的许多常量并没有一个明确的基础类型，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可认为至少有 256bit 的运算精度。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Black Color = <span class="literal">iota</span> <span class="comment">//iota的初始值为0</span></span><br><span class="line">    Red</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Color)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := Black</span><br><span class="line">    test(c)</span><br><span class="line">    x:=<span class="number">1</span></span><br><span class="line">    test(x) <span class="comment">//报错</span></span><br><span class="line">    test(<span class="number">1</span>) <span class="comment">// 常量会被自动转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>go 作为编译型语言，不允许重复声明，但有一种特殊情况，即有新的变量被定义，如下</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;hellp&quot;</span></span><br><span class="line">a,b := <span class="string">&quot;hel&quot;</span>,<span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="选择-循环结构"><a href="#选择-循环结构" class="headerlink" title="选择 循环结构"></a>选择 循环结构</h3><ul>
<li>跟 for 一样，<code>if</code> 语句可以在条件之前执行一个简单的语句 由这个语句定义的变量的作用域仅在 if 范围之内。</li>
<li>go range 只有一个接收参数的时候遍历的是 index</li>
<li>go 中 range 会复制对象，k，v 都是从复制的对象中取出的，所以 a[k]和 v 实际是两个变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[k] = <span class="number">4</span></span><br><span class="line">    a[k] = v + <span class="number">1</span></span><br><span class="line">    fmt.Print(a[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br>2345</p>
<ul>
<li>控制流 if 支持初始化语句，定义代码块局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a := <span class="number">5</span>; a &gt; <span class="number">4</span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带有 flag 的双重循环，可以实现准层数确的 continue 和 break</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L1:</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">3</span>; x++ &#123;</span><br><span class="line">    L2:</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">5</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y &gt; <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> L2</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> L1</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(x, <span class="string">&quot;:&quot;</span>, y, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组-amp-amp-切片"><a href="#数组-amp-amp-切片" class="headerlink" title="数组&amp;&amp;切片"></a>数组&amp;&amp;切片</h3><ul>
<li>make([]T, length, capacity)使用 make 创建切片</li>
<li>切片的 cap 为切片起始位置到底层数组末尾的长度</li>
<li>golan 数组传值默认使用值拷贝，但是会造成性能问题，通常会建议使用 slice 或者数组指针</li>
<li>内置函数 len 和 cap 都能返回数组长度</li>
<li>reslice 是在 slice 的基础上创建新的 slice 对象，新的对象依旧指向原先底层数组</li>
<li>append 是向 slice 尾部添加数据，返回新的 slice 对象，一旦超市原 slice 的 cap 就会重新分配底层数组</li>
<li>copy(dst,src)复制 slice，两个 slice 可以指向不同的数组</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>map 查找，类型断言或者通道接受出现在赋值语句右边不一定是产生两个结果，也可能只产生一个结果</li>
<li>支持== !=等操作符 可用作 map 键类型 相等的判断依据是值相等而非指针相等</li>
<li>结构体可作为 map 的 key 和 value</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]people&#123;</span><br><span class="line">    <span class="number">1</span>: &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>golang 结构体作为 map 的元素时，不能够直接赋值给结构体的某个字段。因为在 Go 里面所有的都是值 copy，map[“name”]取值的时候实际上是里面的 struct 的值完整的一个 copy，如果允许了这样的操作 list[“name”].XXX 这样的操作，那么实际上你修改的东西没有复制回原来的 struct，所以你可以采用 map[key]*struct 的定义来进行操作，如下所示是可以正确操作的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]*A&#123;<span class="string">&quot;a&quot;</span>: &amp;A&#123;<span class="string">&quot;hello&quot;</span>&#125;&#125;</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>].Name = <span class="string">&quot;Asta&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过双赋值检测某个键存在：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>
<ul>
<li>*[]int 指向数组的指针 []*int 指针数组</li>
<li>make 函数可以用于创建 map，预先给 make 函数一个合理的数量参数，有助于提升性能</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok :=m[<span class="string">&quot;a&quot;</span>];ok&#123;</span><br><span class="line">    <span class="built_in">println</span>(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 range 迭代 map 不能保证迭代次序</li>
</ul>
<h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><ul>
<li>go 结构体以%v 形式打印，直接输出，指针以%v 形式打印，会在结构体{}之前加上一个&amp;</li>
<li>go 结构体的几种初始化方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">float64</span></span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line">rect1 := <span class="built_in">new</span>(Rect)</span><br><span class="line">rect2 := &amp;Rect&#123;&#125;</span><br><span class="line">rect3 := &amp;Rect&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line">rect4 := &amp;Rect&#123;width:<span class="number">100</span>, height:<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这几个变量全部为指向 Rect 结构的指针(指针变量)，因为使用了 new()函数和&amp;操作符。而如果使用方法，那么则表示这个是一个 Rect{}类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := Rect&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内置函数 new 计算类型大小，返回指针，make 会被编译器翻译成具体的创建函数，返回对象</li>
<li>使用 `` 定义不做转义处理的原始字符串，支持跨行</li>
<li>使用 ‘’ 表示 Unicode Code Point 字符常量 如 ‘u6211’ 要修改字符串 可以先转换成 []rune 或者[]byte</li>
</ul>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>命名返回参数可以被同名局部变量遮蔽，此时需要显式返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">//必须显式返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>defer 与 return 执行顺序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(x,y <span class="keyword">int</span>)</span><span class="params">(z <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(z)</span><br><span class="line">    &#125;()</span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">//执行顺序 (z = z + 200) -&gt; call defer -&gt; ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x, y := <span class="number">10</span>,<span class="number">20</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;defer&quot;</span>,i, y)</span><br><span class="line">    &#125;(x)</span><br><span class="line">    x += <span class="number">10</span></span><br><span class="line">    y += <span class="number">100</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;x=&quot;</span>,x,<span class="string">&quot;y=&quot;</span>,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>x=20 y=120<br>defer: 10 120</p>
<ul>
<li>go 学习笔记的一个错误，method value 并不会复制 receiver，而是指向同一个结构体</li>
<li>延迟调用中引发的错误，可以被后续延迟调用捕获，但是只有最后一个错误可以被捕获</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><ul>
<li>空接口没有任何方法签名，这意味着任何类型都实现了空借口，其作用类似面向对象语言中的根对象 object</li>
<li>匿名接口可以用作变量类型，或者结构成员</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>go 的错误处理有 panic 和 error 两种方式，当关键流程出现不可修复性错误使用 panic，其他情况使用 error</li>
</ul>
<h3 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h3><ul>
<li>fmt.Sprintf 返回一个格式化的字符串，但是不输出，fmt.Println 直接输出</li>
<li>命令行程序，必须在使用标志参数对应的变量前调用 flag.Parse()，用于更新每个标识变量的值（之前是默认值）</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HandleFunc func(pattern string, handler func(ResponseWriter, *Request)) 如果你的 pattern 是”/“，那么请求的 URL 都是匹配该函数，如果你请求根目录”/“，那么处理函数将会执行两次</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>当只想执行包的 init 函数的时候，在其在 import 的包名设置为 _，这将会使 go 编译器忽略未引用的错误，但是仍然会执行 init 函数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/02/24/misc/%E5%AD%A4%E7%8B%AC%E7%9A%84%E4%BA%BA%E7%BE%A4%E9%9A%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/24/misc/%E5%AD%A4%E7%8B%AC%E7%9A%84%E4%BA%BA%E7%BE%A4%E9%9A%8F%E8%AE%B0/" class="post-title-link" itemprop="url">《孤独的人群》读后感</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-24 22:21:56" itemprop="dateCreated datePublished" datetime="2019-02-24T22:21:56+00:00">2019-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">4.7k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">15(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>《孤独的人群》曾被誉为“当代最有影响的著作之一”，是美国社会学家大卫・理斯曼在同事的协助下完成的一部经典学术著作。本书主旨是讨论美国人社会性格的形成及演变。作者根据传统导向、内在导向和他人导向的社会性格类型对具体的社会阶层――美国中产阶级的性格形成和演变进行了全面阐述。理斯曼认为父母、家庭、学校是性格形成的主要原因，而社会性格最终体现为一定的生活方式，在工作、娱乐、政治生活和子女教育等活动表现出来<br>　　作者着重探讨了 19 世纪美国占主导地位的内在导向性格如何被 20 世纪中叶的他人导向性格所取代的过程，研究了这一取代的原因、过程以及对美国当代主要社会生活领域的影响。</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>全书分为 3 编，主题分别为性格、政治和自主性。在第 1 编的开始，作者首先提出了社会性格的概念。按照作者的解释，这是指个人用来接触世界和他人的一种定型。不同时代的人的社会性格，呈现出有着深深时代烙印的不同特点。<br>　　作者援引谨精神分析心理学家弗洛姆的观点——为了使社会正常地发挥自己的作用，社会成员必须获得某种性格，从而使他们愿意按照社会成员或社会中特定阶层所必须遵奉的行为方式去行动。即人顺从于社会。这种顺从方式可以追溯到人的童年。顺从不能代表整个社会性格，如创造方式是社会性格的重要部分，没有创造性，社会和个人的生活将会枯燥，但是能生存下去，但没有顺从方式，人们则不能生存下去。<br>　　作者运用人口统计学分析了西方自中世纪以来的人口变化，将其分为高度增长潜力时期，过渡时期，早期人口减少时期三个阶段。这三个阶段的社会中的人，分别呈现出传统引导、内部引导和他人引导的性格特点。<br>　　在高度增长潜力时期的社会，尚未受到工业化的影响，社会的生产处于低水平，而人口的出生率和死亡率都处于相当高的水平。这种社会的秩序相对稳定，处在这种社会中的人呈现出传统引导的特点，个人的顺从性易受同龄人和种族的影响，个人学会和理解并且选择持续了几个世纪之久的传统行为模式。在传统引导的社会，社会的分工较为简单，因此不存在无用的人，只要选择从属于社会，就可以在社会中扮演一个角色。阶级的区别是牢固的，农民的孩子未来仍会是农民，而上层贵族家庭的孩子则从小被鼓励建立起某种个性，以符合其贵族身份。从总体上看，整个社会中个人的选择空间是非常有限的。<br>　　而在过渡时期，因为粮食产量提高和医疗卫生条件改善等因素，人口死亡率大大降低，出生率和死亡率不再平衡，这种变化催生出内部引导这一社会性格。内在引导的人不再沿着以往的既定人生轨道，而由其性格类型所引导。这个时期的社会给予成员更多的选择，如金钱，财产，权利，知识，名誉，善行等。这一时期的社会具有流动性，内部引导者可以凭借自身坚毅的品质和努力奋斗实现阶级的跨越，这一时期的工厂主，银行家是这一类人的代表。<br>　　社会发展进入一定阶段后，随着中产阶级队伍逐渐壮大，社会的出生率降低，社会进入了初期人口下降阶段。人们需要工作的时间减少，享乐主义开始盛行，内部引导者所具有的忍耐心和进取心开始不大重要了。这时的新中产阶级呈现出他人引导型的社会性格——他们把同龄人当做个人引导的来源，他人引导所追求的目标随着这种引导的不同而改变，而追求过程本身和密切注意他人态度的过程在一生中保持不变。<br>　　在这三个阶段，父母、老师和同辈人的作用也有很大的不同。<br>　　在传统引导阶段，社会的流动性很低，成人的角色一代一代稳定不变。大多数成人的生活不要求复杂的技巧和文字知识，儿童通过模仿大人可以很快走向社会成熟。性格形成的主要动因是延续维护家庭或团体的存在，儿童所模仿的通常是大人的整个团体而不是自己的父母。<br>　　到了内部引导阶段，阶级不再固定，社会不再要求个人必须顺应社会。父母在孩子儿童时期便向他们灌输和推行理想和目标。这些理想和目标被孩子所内化，当他们长大后被这种力量驱动，追求有限的价值，财富和权利。劳动分工的进步意味着儿童不再以父母当做学习的榜样。父母不能确定孩子未来的生活方式，但是仍有意识地对孩子进行性格训练，常常更严厉地要求孩子。与传统引导相比，父母培养孩子所需要的时间更长了，儿童在社会化的过程中，承受的压力更大了，孩子是被培养大的，而不是爱大的。在内部引导的后期，上学不再是上层阶级孩子的特权。在为了大量培养工业化时代所需要的人才，政府为普通家庭的孩子提供强制的义务的教育，学校开始大批出现。这一阶段教师的主要任务是培养孩子按照中产阶级的标准去说话做事，教师并不关心孩子的情绪生活，认为自己的工作只限于教孩子读书，并且向学生灌输注重学业的评价标准。这种教育对于那些学业失败者有着巨大的损害，因为他们也认同这种标准。内部引导的孩子希望将友谊局限于同社会阶层的人，他们的友谊往往基于共同的爱好，并且只有少数要好的朋友。这一时期，同侪团体的道德约束力，吸引力或威吓力十分衰弱，但是父母甚至老师却可以打破道德权威。<br>　　而在他人引导阶段，社会的流动性仍然存在，但是这种流动性更依赖于他人的看法，以及个人如何操纵他人或为人所操纵，而不大依赖个人是什么和做什么。父母对于如何培养自己的孩子感到不知所措，开始求助于知名人物或者大众媒体，甚至交给孩子本人。他们将焦虑传递给孩子，当孩子表现出乖巧时，会给予赞扬，但其实是在讨好孩子。通过接触大众传播媒介，孩子可以轻易了解父母的行为规范，父母不再具有权威性，其重要性有所降低，而孩子的地位有所提高。在上层中产阶级，父母以克制的讲道理的方式操纵孩子，孩子则以相同的方式回报父母。这一时期的教育更集中于促使孩子全面发展，注重发展人的个性。2-5 岁的孩子也开始进入学校，他们接触的老师是理解他的，陪他玩的大人，这些新老师高度专业化，了解儿童的心理特点，加入学生的各种社会化过程，如消费，友谊，幻想等。环境鼓励孩子的创造性型与个性，但是学校本身仍是扼杀儿童想象力的场所。老师不大关心教学的内容，情绪和精力投入到团体关系领域。当代学校小班级的教师角色，和现代工厂职工关系部的角色极为相似。学校教育他人引导的儿童要准备步入一个重视团体内部关系和道德规范，不太重视产品的社会。这一时期的同侪团体的权利如同美国的陪审团在审判中拥有无上的权利。孩子们常常受到他人意见的摆布，但同侪团体本身常常是充满友谊和忍耐性的。内部引导时期同侪团体中的竞争转变为获取同侪团体赞同，或获取这种赞同的安全感而进行的竞争。同伴成为衡量一切事物的标准。<br>　　大众传媒也是影响社会性格的一个重要因素。传统引导阶段的社会利用家史，神话，传说等形式传播其相对稳定的社会价值观。这些神话与传说中，有些充满了反抗精神。故事里正反两个方面的悖论有助于年轻人综合自己被压抑的冲动，认识到冲动是人类合理的部分，从而不会真正干出有违传统的事。而到了内部引导时期，正式的学校教育机会增加了，更多年轻人学会了读书，出现了对印刷品和书籍的渴求。印刷物帮助他们建立个人与新的社会之间的联系，他们通过印刷物了解道理，所以能够建立一种新的性格结构，使他们能自愿劳动更长时间。印刷物和其他流行的文化形式，通过促使他们回想起父母对自己寄与的愿望以及为他们成功之路提供各种特殊指导，来满足这些开拓者的要求，指导着人们成功之途径。传记和小说促使内部引导社会的孩子试图在想象中离开家庭，步入社会。个人主义的追求在小说和戏剧所描述的各种生活道路上得到了支持和过度支持，独自看书变成了一种孤独的新方式。<br>　　在对待工作和娱乐的态度上，内部引导的人在青年时期往往面临着物质上的贫困，但同时他们有着儿童时期内化了的雄心壮志，这使得他们信奉吃得苦中苦，方为人上人的准则。他们将工作当做生活的主旋律，认为娱乐只是次要的，他们为了自我赞同而奋斗。他人引导的社会，娱乐活动和内部引导时期没有多少变化，但所不同的是人的社会性格发生了变化。新兴的工业革命更看中沟通和操纵人的技术，而把生产工具和技术的改进看作是第二位的。社会上消费主义开始盛行，他人引导者在儿童时期就被培养成为一名消费者。这个时期，个人在工作中若想一枝独秀，光彩夺目，有时是危险的，人们必须学会通过彻底的合作来保持工作上的竞争。而娱乐也不再被看做浪费时间，生产和消费，顺应团体和为个人兴趣服务，以及工作和娱乐之间没有清楚的界限。<br>　　以上是我粗略地总结了书中第一编的内容，在本书的第二编政治部分，作者探讨了这三种人在美国政治生活上的行为与态度。第三编自主性部分，则在更深层次上探究了不同时期人的自主性，包括工作和娱乐的自主性。美国作为一个移民国家，没有封建统治的历史，其政治结构也与我们国家有很大不同，对于这部分内容，我的感触不多。不过从中，我们还是可以了解到不同时期美国人对政治态度的变化，也更可以理解为何现在的美国人都热衷于政治话题——政治已经成为消费文化的一部分。</p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>虽然本书研究的是美国的社会性格变化过程，但是在阅读的过程中，却常常引起我的强烈共鸣。这或许就是社会学的魅力所在，社会学家用一种新的思考方式和分析问题的方法解释周围发生的事情，这往往是普通人所注意不到的。虽然中美所代表的中西方在文化上有巨大差异，但是在社会发展的历程上，却有着很多的共同点。书中所定义的传统引导型社会，对应于欧洲的中世纪，而中国则是经历了长达 2000 年的封建王朝统治时代，这一时期的中国人民，正如书中所刻画的传统引导者的形象，守序而一成不变。十九世纪的美国人，在昭昭天命的引领下，背井离乡，来到那时还是一片荒野的美国西部，希望成就自己的一番事业，他们的社会性格呈现出明显的内部引导的特点。而社会主义建设初期的青年们，尤其是那些参与开发北大荒或是支援新疆建设的青年们，也呈现出相同的性格特点。书中所定义的他人引导的社会性格，随着我国现代化建设的推进，也开始在大城市的市民中出现。<br>　　新中国成立后，我们用半个多世纪走过了西方 200 年走过的现代化道路。在书中所述的美国社会变迁中，我们可以感受到其中的撕裂感。一个在旧的传统社会成长起来的人，往往无法适应新的社会发展。而在新中国的发展历程中，这种撕裂感则更为明显，并且不仅仅是时间轴纵向的，还有横向的。中国拥有广阔的国土和世界上最多的人口，各个地区之间的发展有着巨大的差距。在偏远落后的农村，那里的社会还处于传统引导的阶段，而在小城镇，人们的性格处于内部引导阶段，而在北上广深这样的大都会，一些市民的社会性格已经达到了他人引导的阶段。社会整体的流动性依然存在，生活在农村传统社会的人可以通过努力学习实现阶级跨越，成为大城市的新市民，在他的人生的不同阶段，我们可以看到 3 种不同的性格导向特点。中国的这种快速发展在世界上是前所未有的，但是这种不平衡的发展，所带来的伤痛也是不容忽视的。有时我会觉得，中国的大都市和落后乡村，好似是两个世界。虽然同是炎黄子孙，讲着相同的语言，但是生活在那里的人的人生轨迹却完全不同。大城市中产阶级家庭的孩子，他们的人生早被父母规划好，得益于更好的教育资源，他们往往可以进入更好的高等院校，家庭条件更好的孩子，还可以选择出国留学的道路。农村的孩子，除却少部分人通过高考这条上升通道飞上枝头变成了金凤凰，大部分年轻人辍学来到大城市打工，充当了经济发展的廉价劳动力。他们虽也在大城市生活，但是大城市并不接纳他们，他们结婚生子后，往往因无力承担孩子在大城市的教育而将孩子送回老家，形成了数量庞大的留守一代。父母教育和爱的缺失，让留守一代的成长，尤其是心理健康，成为巨大的社会问题。而他们的人生命运，我想大部分也会和他们的父母一样。没有人会认为这种差异是理所应当的。现代化摧枯拉朽般摧毁了传统的体系，却没有给人以足够的时间去适应，社会整体的发展还未达到较高的水平，阶级却已经开始固化，城市和农村愈发对立，形成不同的文化孤岛。中国社会发展的成果瞩目，但背后隐含的伤痛，可能需要几代人的时间去消解。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>阅读这本书的契机，是一次与一位敬重的朋友的闲谈中，他偶然提及了他对于社会心理学的研究。在此之前，我从未听说过有社会心理学这门学科，但对于心理学，我是一直有着浓厚的兴趣的。于是我下载了几本知名的社会心理学的著作到我的 ipad 中，但是学习生活的繁忙，使得我很少能抽出时间阅读。利用这次假期和开学的这段时间，我阅读了这本足足有 400 页的著作。虽然这是一本学术著作，但阅读的过程却十分有趣。作者举了大量生动有趣的例子，使书中的道理变得浅显易懂。通过阅读这本书，在了解了这么多社会性格的同时，我也更加了解自己。人创造了社会，人无法脱离社会生存，因而要了解社会，最终使自己融入社会，完成自我的社会化，我想这大概是我这个外行涉猎这门科学的意义所在吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E4%B8%8E%E6%A0%88%E5%B8%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E4%B8%8E%E6%A0%88%E5%B8%A7/" class="post-title-link" itemprop="url">汇编与栈帧1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 13:34:50" itemprop="dateCreated datePublished" datetime="2018-12-05T13:34:50+00:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">674(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">3(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dormant/p/5059644.html">汇编与栈帧学习（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dormant/p/5079894.html">esp 和 ebp 详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/striver1205/article/details/25695437">Push, Pop, call, leave 和 Ret 指令图解</a></li>
</ul>
<p>参考以上博文的内容，写了一个简单的程序，说明一下汇编调用过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源程序 test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我的环境为64位linux系统，需要加上-m32指定以32位方式编译</span></span><br><span class="line">$ gcc -m32  -g test1.c</span><br><span class="line">$ gdb a.<span class="built_in">out</span></span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x80483f7</span>: file test1.c, line <span class="number">8.</span></span><br><span class="line">(gdb) b add</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x80483e1</span>: file test1.c, line <span class="number">3.</span></span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at test1.c:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>         <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line"><span class="number">0x080483f1</span> &lt;+<span class="number">0</span>&gt;:     push   %ebp <span class="comment">// ebp寄存器存储当前main栈帧栈底, 将ebp入栈，esp减去4字节</span></span><br><span class="line"><span class="number">0x080483f2</span> &lt;+<span class="number">1</span>&gt;:     mov    %esp,%ebp <span class="comment">// 把esp的数值赋给ebp</span></span><br><span class="line"><span class="number">0x080483f4</span> &lt;+<span class="number">3</span>&gt;:     sub    $<span class="number">0x10</span>,%esp <span class="comment">// 把esp减去16个字节</span></span><br><span class="line">=&gt; <span class="number">0x080483f7</span> &lt;+<span class="number">6</span>&gt;:     movl   $<span class="number">0xffffffff</span>,<span class="number">-0xc</span>(%ebp) <span class="comment">// ebp减去12字节的位置保存直接数-1</span></span><br><span class="line"><span class="number">0x080483fe</span> &lt;+<span class="number">13</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x8</span>(%ebp) <span class="comment">// ebp减去8字节的位置保存直接数0</span></span><br><span class="line"><span class="number">0x08048405</span> &lt;+<span class="number">20</span>&gt;:    pushl  <span class="number">-0x8</span>(%ebp) <span class="comment">// ebp减去8字节的位置的值（b的数值）入栈 同时esp减去4字节</span></span><br><span class="line"><span class="number">0x08048408</span> &lt;+<span class="number">23</span>&gt;:    pushl  <span class="number">-0xc</span>(%ebp) <span class="comment">// ebp减去12字节的位置的值入栈（a的数值） 同时esp减去4字节 说明参数是按照从右向左的顺序入栈的</span></span><br><span class="line"><span class="number">0x0804840b</span> &lt;+<span class="number">26</span>&gt;:    call   <span class="number">0x80483db</span> &lt;add&gt; <span class="comment">// 调用add函数 call指令将返回地址0x0804840b压入栈顶，esp减去4字节，然后程序跳转到add函数的起始地址</span></span><br><span class="line"><span class="number">0x08048410</span> &lt;+<span class="number">31</span>&gt;:    add    $<span class="number">0x8</span>,%esp <span class="comment">// esp加上8 清除局部变量占用的空间</span></span><br><span class="line"><span class="number">0x08048413</span> &lt;+<span class="number">34</span>&gt;:    mov    %eax,<span class="number">-0x4</span>(%ebp)</span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">37</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"><span class="number">0x0804841b</span> &lt;+<span class="number">42</span>&gt;:    leave</span><br><span class="line"><span class="number">0x0804841c</span> &lt;+<span class="number">43</span>&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p $esp</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc68</span></span><br><span class="line">(gdb) p $ebp</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc78</span></span><br><span class="line">(gdb) disas add</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function add:</span><br><span class="line"><span class="number">0x080483db</span> &lt;+<span class="number">0</span>&gt;:     push   %ebp <span class="comment">// ebp寄存器存储当前main栈帧栈底, 将ebp入栈，esp减去4字节</span></span><br><span class="line"><span class="number">0x080483dc</span> &lt;+<span class="number">1</span>&gt;:     mov    %esp,%ebp <span class="comment">// 把esp的数值赋给ebp</span></span><br><span class="line"><span class="number">0x080483de</span> &lt;+<span class="number">3</span>&gt;:     sub    $<span class="number">0x10</span>,%esp <span class="comment">// 把esp减去16个字节</span></span><br><span class="line">=&gt; <span class="number">0x080483e1</span> &lt;+<span class="number">6</span>&gt;:     mov    <span class="number">0x8</span>(%ebp),%edx <span class="comment">// ebp加上8个字节的位置的值 存入寄存器edx</span></span><br><span class="line"><span class="number">0x080483e4</span> &lt;+<span class="number">9</span>&gt;:     mov    <span class="number">0xc</span>(%ebp),%eax <span class="comment">// // ebp加上12个字节的位置的值 存入寄存器eax</span></span><br><span class="line"><span class="number">0x080483e7</span> &lt;+<span class="number">12</span>&gt;:    add    %edx,%eax <span class="comment">// edx的数值加上eax的数值存入eax</span></span><br><span class="line"><span class="number">0x080483e9</span> &lt;+<span class="number">14</span>&gt;:    mov    %eax,<span class="number">-0x4</span>(%ebp) <span class="comment">// ebx减去4字节的位置保存eax的值</span></span><br><span class="line"><span class="number">0x080483ec</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">-0x4</span>(%ebp),%eax <span class="comment">//</span></span><br><span class="line"><span class="number">0x080483ef</span> &lt;+<span class="number">20</span>&gt;:    leave <span class="comment">// LEAVE指令是将ebp的数值赋给esp，然后popl ebp， 即esp加上4字节</span></span><br><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">21</span>&gt;:    ret <span class="comment">// RET指令则是将栈顶的返回地址弹出到EIP，esp+4 然后按照EIP此时指示的指令地址继续执行程序</span></span><br><span class="line">(gdb) p $ebp</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc58</span></span><br><span class="line">(gdb) p $esp</span><br><span class="line">$<span class="number">5</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc48</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2018/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">计算机网络学习笔记之概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-30 06:23:24" itemprop="dateCreated datePublished" datetime="2018-11-30T06:23:24+00:00">2018-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">1.5k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">5(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul>
<li>对等连接 即 p2p（peer to peer），是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（p2p 软件），他们就可以进行对等，平等连接通信，这时，双方下载对方已经存储在硬盘中的共享文档。对等连接工作方式可以支持大量对等用户同事工作</li>
<li>在互联网的信息起特殊作用的是路由器，它是一种专用计算机，是实现分组交换（packet switching）的关键构建，其任务是转发收到的分组。</li>
<li>电路交换的一个重要特点是，在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。使用电路交换来传送计算机数据时，传输效率往往很低，因为计算机数据是突发地出现在传输线路上的，真正用来传送数据的时间很短，被用户占用的通信线路资源在大部分时间都是空闲的。</li>
<li>分组交换采用存储转发技术，路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。</li>
<li>边缘部分 由所有连接在因特网上的主机组成，由用户直接使用，用来运行各种网络应用，为用户直接提供各种网络服务</li>
<li>核心部分 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的</li>
</ul>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ul>
<li>速率 指的是数据的传送速度，单位是 bit/s</li>
<li>带宽 在计算机网络中，表示网络中某通道传送数据的能力，表示在单位时间内网络中某信道所能通过的“最高数据率”，单位是 bit/s</li>
<li>吞吐量 表示在单位时间内通过某个网络（或者信道，接口）的实际的数据量 额定速度 1Gbit/s 的以太网，实际拓扑两可能只是 100Mbit/s</li>
<li>时延（delay 或者 latency）是指数据（一个报文或分组，甚至比特）从网络（或者链路）的一个端传送到另一端所需的时间。<ul>
<li>发送时延 是主机或路由器发送数据帧所需要的时间<br>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li>
<li>传播时延 是电磁波在信道中传播一定的距离需要花费的时间<br>传播时延长 = 信道长度（m）/ 电磁波在信道上的传播速率（m/s）<br>电磁波在自由空间的传播速率是光速，在光纤中速率约为 2.0 * 10^5km/s，1000km 长的光纤线路的传播时延大约为 5ms</li>
<li>处理时延 主机或路由器在收到分组时要花费一定的时间进行处理造成的时延</li>
<li>排队时延 分组在经过网络传输时，要经过许多路由器，分组进入路由器后，要先在输入队列中排队等待处理</li>
<li>时延带宽积 又称为以比特为单位的链路长度<br>时延带宽积 = 传播时延 * 带宽</li>
<li>往返时间 RTT 即数据双向交互一次所需要的时间</li>
<li>利用率 有信道利用率和网络利用率两种。信道或网络利用率过高会产生非常大的时延。</li>
</ul>
</li>
<li>OSI（open system interconnection）开放系统互联标准，只是法律上的国际标准，TCP/IP 是实际上的国际标准<br>OSI 的七层模型包括应用层，表示层，会话层，运输层，网络层，数据链路层，物理层<br>TCP/IP 的四层模型包括应用层（TELNET，FTP，SMTP），传输层（TCP/UDP），网际层（IP），网络接口层<br>在学习计算机网络原理时，采取这种的办法，采用一种五层协议，包括应用层，运输层，网络层，数据链路层，物理层<ul>
<li>应用层 任务是通过应用程序间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则，对于不同的网络应用需要有不同的应用层协议，包括 HTTP 协议，域名系统 DNS，SMTP，应用层交互的数据单元称为报文</li>
<li>运输层 任务是负责向两台主机中进程之间的通信提供通用的数据传输服务，主要使用两种协议<br>传输控制协议 TCP（Transmission Control Protocol），提供面向连接的，可靠的数据传输服务，其数据传输的单位是报文段（segment）<br>用户数据包协议 UDP（User Datagram Protocol），提供无连接的，尽最大努力的数据传输服务，不保证可靠性，传输的单位是用户数据报</li>
<li>网络层 负责为分组交换网上的不同主机提供通信服务。在发送数据是，网络层把运输层产生的报文或用户数据报封装成分组或包进行传送。在 TCP/IP 体系中，网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称数据报。</li>
<li>数据链路层 将网络层交下来的 IP 数据报组装成数据帧（framing），在两个相邻节点的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制）。控制信息能使接受端能检测到所收到的帧有无差错，如果有差错，数据链路层就简单的丢弃这个出了差错的帧，如果有需要改正的数据在传输中出现了差错，就要采用可靠传输协议来纠错</li>
<li>物理层 在物理层上所传数据的单位是比特</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2018/11/25/%E8%BF%90%E7%BB%B4/oj%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/25/%E8%BF%90%E7%BB%B4/oj%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">oj运维笔记-持续更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-25 13:59:10" itemprop="dateCreated datePublished" datetime="2018-11-25T13:59:10+00:00">2018-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">663(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">2(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接到协会老师的任务，我负责了学校 oj 的开发和运维工作，这篇博客记录我在运维过程中遇到的一些问题和解决办法。</p>
<ul>
<li>重启容器 找不到 java，vi 等命令 使用 update update-alternatives —config 配置 java javac vi 等</li>
<li>java 遇到　 OpenJDK 64-Bit Server VM warning: Can’t detect initial thread stack location - find_vma failed 　错误原因是 chroot 系统中，需要挂载/proc，只需要执行以下语句即可<br>mount -t proc none /proc</li>
<li><p>php 下载 excel 文件 nginx 报错 502<br>首先查看 nginx 日志，发现在站点配置文件中没有设置输出日志，在站点配置文件末尾加入<br>error_log logs/errors.log error;<br>输入命令 nginx -t 发现报错<br>nginx: [emerg] open() “/usr/share/nginx/logs/errors.log” failed (2: No such file or directory)<br>使用 touch 创建日志文件，查看日志文件发现<br>*4 upstream sent too big header while reading response header from upstream<br>百度之后，说是 header 过大的问题，在 nginx.conf 的 http 段加入以下配置<br>proxy_buffer_size 128k;<br>proxy_buffers 32 32k;<br>proxy_busy_buffers_size 128k;</p>
<pre><code>  fastcgi_buffer_size 128k;
  fastcgi_buffers 4 256k;
  fastcgi_busy_buffers_size 256k;
</code></pre><p>问题搞定！</p>
<ul>
<li>手动执行 judge_client<br>judge_client 1000 1 /home/judge/hustoj_core debug</li>
</ul>
</li>
<li><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p>
</li>
<li>supervisor 的使用 运行命令 supervisorctl 然后参照配置文件的写法运行命令</li>
<li>docker-compose 要注意 services 不能重名，即使是在不同的目录下，如果 services 重名，会覆盖之前的容器，建议使用项目名+容器名进行命名</li>
</ul>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>因为使用 redis 缓存了问题数据，我想要测试一下有没有带来性能上提升<br>首先我尝试的是 postman 的 runner，但是测试之后发现并没有什么区别。后来了解到 postman 的 runner 是串行的。<br>又看到 jMeter 这个工具，但是它在 linux 下没有 GUI，配置又很繁琐，直接劝退。<br>之后又看到 linux 下几款 命令行压力测试工具，最终选择使用 ab。</p>
<h3 id="ab-的使用"><a href="#ab-的使用" class="headerlink" title="ab 的使用"></a>ab 的使用</h3><p>使用很简单，最基础的设置，请求 10000 次，并发数量 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 10000 -c 1000 http://localhost:8080/api/problem/1</span><br></pre></td></tr></table></figure>
<h3 id="socket-Too-many-open-files-24-的解决办法"><a href="#socket-Too-many-open-files-24-的解决办法" class="headerlink" title="socket: Too many open files (24)的解决办法"></a>socket: Too many open files (24)的解决办法</h3><p>打开的文件太多了，超过了系统限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 204800</span><br></pre></td></tr></table></figure>
<h3 id="redigo"><a href="#redigo" class="headerlink" title="redigo"></a>redigo</h3><p>文献 系统优点</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx 容器配置反向代理，无法使用 localhost 访问主机，可以使用宿主机 docker 0 的网卡 ip 代替</p>
<h3 id="mysql-相关"><a href="#mysql-相关" class="headerlink" title="mysql 相关"></a>mysql 相关</h3><p>innodb_lock_wait_timeout 和 lock_wait_timeout<br>前者是 innodb 的 dml 操作的行级锁的等待时间 后面是数据结构 ddl 操作的锁的等待时间</p>
<p>减少锁等待时间，防止数据库卡死</p>
<p>set GLOBAL innodb_lock_wait_timeout = 50;<br>set GLOBAL lock_wait_timeout = 10;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiezi19971225</p>
  <div class="site-description" itemprop="description">记录编程学习路上的点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiezi19971225</span>
</div>
  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"/>
  <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备17001385号-1</a>
  <br/>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
