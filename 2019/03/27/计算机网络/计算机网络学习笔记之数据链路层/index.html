<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="baidu-site-verification" content="5IfwMCE5hH" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.jiezi19971225.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基本概念数据链路层属于计算机网络的底层，使用的信道主要有以下两种类型:  点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式,因此过程比较复杂。广播信道上连接的主机很多,因此必须使用专用的共享信道协议来协调这些主机的数据发送。本章主要内容是 数据链路层点对点和广播信道的特点，以及这两种信道使用的协议（PPP，CSMA&#x2F;CD）的特点 数据链路层的三个基本问题">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络学习笔记之数据链路层">
<meta property="og:url" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/index.html">
<meta property="og:site_name" content="Jiez19971225‘s Blog">
<meta property="og:description" content="基本概念数据链路层属于计算机网络的底层，使用的信道主要有以下两种类型:  点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式,因此过程比较复杂。广播信道上连接的主机很多,因此必须使用专用的共享信道协议来协调这些主机的数据发送。本章主要内容是 数据链路层点对点和广播信道的特点，以及这两种信道使用的协议（PPP，CSMA&#x2F;CD）的特点 数据链路层的三个基本问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/传送帧.png">
<meta property="og:image" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/汉明码原理.png">
<meta property="og:image" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网的帧格式.png">
<meta property="og:image" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11退避机制.png">
<meta property="article:published_time" content="2019-03-27T08:14:35.000Z">
<meta property="article:modified_time" content="2021-10-21T16:45:16.175Z">
<meta property="article:author" content="jiezi19971225">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/传送帧.png">

<link rel="canonical" href="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络学习笔记之数据链路层 | Jiez19971225‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiez19971225‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做自己爱做的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络学习笔记之数据链路层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 08:14:35" itemprop="dateCreated datePublished" datetime="2019-03-27T08:14:35+00:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">10.4k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">37(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>数据链路层属于计算机网络的底层，使用的信道主要有以下两种类型:</p>
<ul>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播信道。这种信道使用一对多的广播通信方式,因此过程比较复杂。广播信道上连接的主机很多,因此必须使用专用的共享信道协议来协调这些主机的数据发送。<br>本章主要内容是</li>
<li>数据链路层点对点和广播信道的特点，以及这两种信道使用的协议（PPP，CSMA/CD）的特点</li>
<li>数据链路层的三个基本问题：封装成帧，透明传输和差错检测</li>
<li>以太网 mac 层的硬件地址</li>
<li>适配器，转发器，集线器，王巧，以太网交换机的作用和使用场合</li>
</ul>
<h3 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><ul>
<li>链路(link)是一条无源的点到点的物理线路段,中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li>
<li>数据链路(data link) 除了物理线路外,还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上,就构成了数据链路。现在最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/传送帧.png" alt="传送帧"></li>
<li>点对点通信在数据链路层的主要步骤<br><em> 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧
</em> 结点 A 把封装好的帧发给结点 B 的数据链路层 * 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层，否则丢弃该帧<br>数据链路层不考虑物理层之间如何实现比特传输的细节</li>
</ul>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部,然后就构成了一个帧。确定帧的界限。</li>
<li>首部和尾部的一个重要作用就是进行帧定界。</li>
<li>MTU Maximum Transfer Unit 最大传输单元</li>
<li>当数据是可打印的 ASCII 码组成的文本文件时，可以用特殊的帧定界符。控制字符 SOH（start of header）和 EOT （end of transmission），十六进制编码分别为 01 和 04</li>
</ul>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><ul>
<li>由于帧开始和结束使用了专门制定的控制字符，因此，所传输的数据中任何 8 比特的组合一定不允许和帧定界的控制字符的比特编码一样当传输的帧是用文本文件组成的帧时，这种方式没有问题，不用管传送的是什么字符，这种传输就是透明传输。但是当传送的是非 ASCII 的文本文件时，数据中可能会出现恰好和 SOH 和 EOT 一样的二进制数据。</li>
<li>如何解决<ul>
<li>字节填充法<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现数据当中,那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时,就删除其中前面的一个。</li>
<li>字符计数法<br>这种方法是在帧头部中使用一个字符计数字段来标明帧内字符数。例如,发送序列“5 A B C D E 4 U V W X 7 1 2 3 4 4 5 8”表示一共有三个帧,三个帧的长度分别为 5 字节、4 字节和 7 字节。但是这种方法很容易出现定界错误。假如计数值出现传输差错,接收端收到的序列为“5 A B C D E 6 U V W X 7 1 2 3 4 4 5 8”时,则接收端会将第二帧解释为“6 U V W X 7 1”,从而导致因发收双方对帧大小和内容理解不一致而出错。</li>
<li>带字符填充的首尾界符法<br>这种方法是在每一帧的开头加上 ASCII 字符“DLESTX” ,在帧末尾加上 ASCII 字符“DLE ETX” 。例如,假设待发送的数据是 ADLECB ,则在数据链路层封装的帧为:DLE STX ADLECB DLE ETX 如果发送方在数据帧中遇到帧头或者帧尾字符,就采用字符填充法来处理。例如,数据帧有 DLE 字符,就在其前面加一个 DLE。<br>DLE STX A DLE DLE CB DLE ETX</li>
<li>带位填充的首尾标志法(零比特填充法)<br>这种方法是用一个特殊的位模式“01111110”作为帧边界。数据中可能包含“01111110”数据,如何判断?采用零比特填充法使一帧中两个边界字段之间的数据不会出现 6 个连续 1。在发送端,当一串比特流数据中有 5 个连续 1 时,就立即填入一个 0。如此保证数据部分不会出现 6 个连续的 1 在接收帧时,先找到边界字段以确定帧的边界。接着再对比特流进行扫描。每当发现 5 个连续 1 时,就将其后的一个 0 删除,以还原成原来的比特流。</li>
<li>物理层编码违例法<br>物理层编码违例法就是利用物理层信息编码中未用的电信号来作为帧的边界。例如,用曼彻斯特编码,在传输之前,将数据位 1 编码成高-低电平对,数据位 0 编码成低-高电平对。那么高-高电平、低-低电平就可以用作帧的边界。</li>
</ul>
</li>
</ul>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><ul>
<li>误码率 传输错误比特占传输总比特数的比率称为误码率</li>
</ul>
<h5 id="循环冗余检测-CRC"><a href="#循环冗余检测-CRC" class="headerlink" title="循环冗余检测 CRC"></a>循环冗余检测 CRC</h5><ul>
<li>在数据链路层传送的帧中,广泛使用了循环冗余检验 CRC 的检错技术。 在发送端,先把数据划分为组。假定每组 k 个比特。假设待传送的一组数据 M = 101001(现在 k = 6)。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</li>
<li>用二进制的模 2 运算进行 2n 乘 M 的运算,这相当于在 M 后面添加 n 个 0。</li>
<li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P,得出商是 Q 而余数是 R,余数 R 比除数 P 少 1 位,即 R 是 n 位。</li>
<li>模 2 运算是不进位也不借位的运算，在这里等同于异或运算，即有当前位就可以得到该位运算的结果</li>
<li>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。循环冗余检验 CRC 和帧检验序列 FCS 并不等同。CRC 是一种常用的检错方法,而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出,但 CRC 并非用来获得 FCS 的唯一方法。</li>
<li>若得出的余数 R = 0,则判定这个帧没有差错,就接受(accept)。 若余数 R != 0,则判定这个帧有差错,就丢弃。但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。只要经过严格的挑选,并使用位数足够多的除数 P,那么出现检测不到的差错的概率就很小很小。</li>
</ul>
<h5 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h5><p><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/汉明码原理.png" alt="汉明码原理"><br>汉明码(Hamming Code)编码的关键是使用多余的奇偶校验位来识别一位错误。假设信息码共有 n 位,海明码共有 h 位,那么总共的码长为 n + h 位。为能检测出 n + h 位编码，中其中一位的错误,海明码必须能够表示至少 n + h + 1 种状态,其中 n + h 种表示 n + h 位编码中有一位错误,另外还需要 1 种来表示整个编码正确无误。则海明码的长度需要满足下列关系:</p>
<script type="math/tex; mode=display">2^h >= n + h + 1</script><p>把所有 2 的幂次方的数据位标记为奇偶校验位(编号为 1, 2, 4, 8, 16, 32, 64 等的位置)<br>其他数据位用于待编码数据. (编号为 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17 等的位置)<br>每个奇偶校验位的值代表了码字中部分数据位的奇偶性,其所在位置决定了要校验的比特位。<br>位置 1，校验所有二进制最后一位是 1 的位置<br>位置 2，校验所有二进制倒数第二位是 1 的位置<br>位置 4，校验所有二进制倒数第三位是 1 的位置<br>配偶是该位置的数值加上是其要效验的位置和为偶数，可以用异或运算计算。<br>配奇则正好相反。<br>如何得到是哪一位出错了呢？以配偶方式为例，求冗余码的效验和，假设 分别为 1 1 0 0 。正常效验和应当为 0，为 1 说明该位置效验的比特位有一位出现了错误。因此倒数第一位和倒数第二位为 1 的都为 1 的位置出现了错误，这可以唯一确定一个位置，即数据的第三位。</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>在不可靠的信道上实现可靠的数据传输为上层提供一条可靠的逻辑通道。CRC 循环冗余检测只能保证无比特差错，但是可能会出现帧丢失，帧失序等，无法做到无传输差错。</p>
<h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><ul>
<li>在发送完一个帧后,必须暂时保留已发送的帧的副本。数据帧和确认帧都必须进行编号。只要超过了一段时间还没有收到确认,就认为已发送的帧出错或丢失了,因而重传已发送过的帧。这就叫做超时重传。<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
<li>使用上述的确认和重传机制,我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li>
<li>RTT (Round Trip)</li>
<li>停止等待协议不适合发送时延远远小于往返时延的情况</li>
<li>停止等待协议的优点是简单,但缺点是信道利用率低。发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送,这种传输方式可获得很高的信道利用率,<br>这种方式是<strong>流水线传输</strong></li>
</ul>
<h5 id="回退-N-帧"><a href="#回退-N-帧" class="headerlink" title="回退 N 帧"></a>回退 N 帧</h5><ul>
<li>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N(回退 N),表示需要再退回来重传已发送过的 N 个分组。</li>
<li>GBN 协议的接受窗口大小为 1，当收到序号错误的分组，接收方除了丢弃他们，还对最近按序接受的分组进行确认</li>
<li>接收方采用累积确认的方式，对分组 n 的确认，表明接收方已经正确收到分组 n 和之前所有的分组</li>
<li>GBN 协议存在一个缺点:一个分组的差错可能引起大量分组的重传,这些分组可能已经被接收方正确接收了,但由于未按序到达而被丢弃。可设法只重传出现差错的分组。但必须加大接收窗口,以便先收下<br>失序到达但仍然处在接收窗口中的哪些分组,等到所缺分组收齐后再一并送交上层。这就是选择重传 SR(Selective Repeat)协议。</li>
</ul>
<h5 id="数据链路层的可靠传输"><a href="#数据链路层的可靠传输" class="headerlink" title="数据链路层的可靠传输"></a>数据链路层的可靠传输</h5><ul>
<li>实现可靠传输需要付出代价(例如会降低传输效率)。因此,应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。当链路误码率非常低时,在数据链路层可不实现可靠传输,而是由上层协议(例如,<br>运输层的 TCP 协议)来完成。但是在使用无线信道传输数据时,由于信道质量较差,在数据链路层仍需要实现可靠传输(例如使用停止等待协议)。</li>
</ul>
<h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><ul>
<li>现在全世界使用得最多的点对点数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。用户使用拨号电话线接入因特网时,一般都是使用 PPP 协议。</li>
<li>PPP 协议的特点<ul>
<li>简单——这是首要的要求</li>
<li>封装成帧</li>
<li>透明性</li>
<li>多种网络层协议</li>
<li>多种类型链路</li>
<li>差错检测</li>
<li>检测连接状态</li>
</ul>
</li>
<li>PPP 协议的组成<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP (Link Control Protocol)。</li>
<li>网络控制协议 NCP (Network Control Protocol)。</li>
</ul>
</li>
<li>PPP 协议的帧格式<br>标志字段 F = 0x7E (符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110)。地址字段 A 只置为 0xFF。地址字段实际上并不起作用。控制字段 C 通常置为 0x03。PPP 是面向字节的,所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP 协议字段<br>当协议字段为 0x0021 时,PPP 帧的信息字段就是 IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021,则表示这是网络控制数据。</li>
<li>透明传输问题<br>当 PPP 用在同步传输链路时,协议规定采用硬件来完成比特填充(和 HDLC 的做法一样)。当 PPP 用在异步传输时,就使用一种特殊的字符填充法。</li>
<li>PPP 的工作状态<br>当用户拨号接入 ISP 时,路由器的调制解调器对拨号做出确认,并建立一条物理连接。PC 机向路由器发送一系列的 LCP 分组(封装成多个 PPP 帧)。这些分组及其响应选择一些 PPP 参数,和进行网络层配置,NCP 给新接入的 PC 机分配一个临时的 IP 地址,使 PC 机成为因特网上的一个主机。通信完毕时,NCP 释放网络层连接,收回原来分配出去的 IP 地址。接着,LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul>
<li>广播信道可以进行一对多的通信,能很方便且廉价地连接多个邻近的计算机,因此曾经被广泛应用于局域网之中。由于用广播信道连接的计算机共享同一传输媒体,因此使用广播信道的局域网被称为共享式局域网。<br>虽然交换式局域网在有线领域已完全取代了共享式局域网,但无线局域网仍然使用的是共享媒体技术。</li>
</ul>
<h4 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h4><p>媒体访问/接入控制(MAC) Medium Access Control 多点接入、多址访问(Multiple Access)</p>
<ul>
<li>静态划分信道<br>频分多址，码分多址和时分多址，这种固定划分信道的方法很不灵活，对于突发性信道的传输利用率很低，通常在无线网络的物理层使用，而不是在数据链路层中使用。</li>
<li>动态接入控制<br>各站点动态占用信道发送数据，而不是使用预先固定分配好的信道<ul>
<li>随机接入<br>通过所有站点之间的竞争，随机地在信道上发送数据，如果恰巧有两个或者更多的站点在同意时刻发送数据，那么信号在共享媒体上就要发生碰撞，使得这些站点的发送都失败，因此这类协议要解决的关键问题是如何避免冲突以及在发生冲突后如何尽快恢复通信。共享式以太网采用的就是随机接入。</li>
<li>受控接入<br>不能随机的发送信息而必须服从一定的控制，典型代表有集中控制的多点轮询协议和分散的令牌传递协议。集中控制的多点轮训协议有一个主站以循环方式轮询每个站点有无数据发送，只有被轮询到的站点才能发送数据，分散控制的令牌传递协议中各站点是平等的，并连接成一个唤醒网络，令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据。</li>
</ul>
</li>
</ul>
<h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul>
<li>局域网的拓扑有星形网，环形网，总线网，树形网。总线网和树形网用总线两端的匹配电阻消除总线上传播的电磁波信号的能量</li>
</ul>
<h5 id="局域网体系结构"><a href="#局域网体系结构" class="headerlink" title="局域网体系结构"></a>局域网体系结构</h5><ul>
<li>IEEE 802 委员会将局域网的数据链路层拆成了两个子层，即逻辑链路控制 (Logical Link Control) 和 媒体接入控制 (Medium Access Control MAC) 子层。与接入到传输媒体有关的内容都放在 MAC 子层，而 LLC 子层与传输媒体无关，不管采用何种传输媒体和 MAC 子层的局域网，对 LLC 子层来说都是透明的。然而由于以太网在局域网中已经取得了垄断地位，LLC(802.2 标准)已经不再重要。</li>
</ul>
<h5 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h5><ul>
<li>网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (NetworkInterface Card),或“网卡”。</li>
<li>适配器的重要功能:<ul>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。</li>
</ul>
</li>
</ul>
<h5 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h5><ul>
<li>在局域网中,硬件地址又称为物理地址,或 MAC 地址。802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。但鉴于大家都早已习惯了将这种 48 位的“名字”称为“地址”,所以本书也采用这种习惯用法,尽管这种说法并不太严格。</li>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24 位)由厂家自行指派,称为扩展标识符,必须保证生产出的适配器没有重复地址。一个地址块可以生成$2^24$个不同的地址。这种 48 位地址称为 MAC-48,它的通用名称是 EUI-48。“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</li>
<li>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.<br>如果是发往本站的帧则收下,然后再进行其他的处理。<br>否则就将此帧丢弃,不再进行其他的处理。</li>
<li>“发往本站的帧”包括以下三种帧:<br>单播(unicast)帧(一对一)<br>广播(broadcast)帧(一对全体)<br>多播(multicast)帧(一对多)</li>
</ul>
<h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><ul>
<li>以太网的两个标准<br>DIX Ethernet V2。<br>IEEE 的 802.3 标准。<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别,因此可以将 802.3 局域网简称为“以太网”。严格说来,“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</li>
</ul>
<h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA CD 协议"></a>CSMA CD 协议</h4><ul>
<li>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致,因此只有 D 才接收这个数据帧。其他所有的计算机(A, C 和 E)都检测到不是发送给它们的数据帧,因此就丢弃这个数据帧而不能够收下来。具有广播特性的总线上实现了一对一的通信。</li>
<li>采用较为灵活的无连接的工作方式,即不必先建立连接就可以直接发送数据。以太网对发送的数据帧不进行编号,也不要求对方发回确认。 这样做的理由是局域网信道的质量很好,因信道质量产生差错的概率是很<br>小的。</li>
<li>以太网提供的服务是不可靠的交付,即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧,其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传,但以太网并不知道这是一个重传的帧,而是当作一个新的数据帧来发送。</li>
<li>以太网发送数据都使用曼彻斯特编码</li>
<li>CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。<ul>
<li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据,如果有,则暂时不要发送数据,以免发生碰撞。</li>
<li>总线上并没有什么“载波”。因此, “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时,总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。在发生碰撞时,总线上传输的信号产生了严重的失真,无法从中恢复出有用的信息来。每一个正在发送数据的站,一旦发现总线上出现了碰撞,就要立即停止发送,免得继续浪费网络资源,然后等待一段随机时间后再次发送。</li>
<li>关于如何检测信道空闲，站点会持续监听到达该站的信号，如果检测到信号包含数据，则说明在这一段时间内信道不是空闲的</li>
<li>当某个站监听到总线是空闲时,也可能总线并非真正是空闲的。A 向 B 发出的信息,要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息),则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</li>
<li>最先发送数据帧的站,在发送数据帧后至多经过时间 2r (两倍的端到端往返时延)就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2r 称为争用期,或碰撞窗口。经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞。</li>
</ul>
</li>
<li>以太网取 51.2 us 为争用期的长度。对于 10 Mb/s 以太网,在争用期内可发送 512 bit,即 64 字节。以太网在发送数据时,若前 64 字节没有发生冲突,则后续的数据就不会发生冲突。</li>
<li>为保证发送方能检测到所有碰撞,以太网规定了最短有效帧长为 64 字节。如果发生冲突,就一定是在发送的前 64 字节之内,立即中止发送,这时已经发送出去的数据一定小于 64 字节。因此将长度小于 64 字节的帧都视为是由于冲突而异常中止的无效帧。</li>
<li>当发送数据的站一旦发现发生了碰撞时: 立即停止发送数据;再继续发送若干比特的人为干扰信号(jamming signal),以便让所有站点都知道现在已经发生了碰撞。</li>
<li>帧间最小间隔 96 比特时间，站点在发送数据帧之前要等待信道空闲 96 比特时间，这样用于接收方检测一个帧的结束，同时也使得其他所有站点都能有机会争用信道并发送数据</li>
<li>CSMA/CD 的要点如下<ul>
<li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送</li>
<li>若适配器检测到信道空闲 96 比特时间，就发送这个帧。若检测到信道忙，则继续检测并等待信道转换为空闲 96 比特时间，然后发送这个帧</li>
<li>在发送过程中继续检测，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则终止数据的发送，并认为发送干扰信号</li>
<li>在终止发送后，适配器就执行指数退避算法，随机等待 r 倍的 512 比特时间后，返回到步骤 2</li>
</ul>
</li>
</ul>
<h5 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h5><p>go 语言的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRandomRate</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    <span class="keyword">return</span> random.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resend</span><span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    index := k</span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">10</span> &#123;</span><br><span class="line">        index = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    upperBound := <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(index)</span><br><span class="line">    r := random.Intn(upperBound)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d次重传 本次退避 51.2 * %d us\n&quot;</span>, k, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tbeb</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> failRate <span class="keyword">int</span></span><br><span class="line">    k := <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入碰撞几率 0-100&quot;</span>)</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;failRate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> getRandomRate() &lt; failRate &#123;</span><br><span class="line">            k++</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">16</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;重传已经达到16次，丢弃该帧，向上层报告&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;发生碰撞，准备重传&quot;</span>)</span><br><span class="line">            resend(k)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;传送成功，共传输%d次\n&quot;</span>, k)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tbeb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第ｋ次重传，选择 $[0,2^k-1]$中的一个随机数作为倍数，将 2r 乘以该倍数作为退避时间</p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><script type="math/tex; mode=display">a = \frac{r}{t_0}</script><p>其中 2r 是争用期长，即端到端传播时延的两倍，帧长为 L，数据发送速率为 C，$t_0=\frac{L}{C}$是帧发送时间，当 a 趋近于 0 时，表示一发生碰撞就可以检测出来，a 越大，信道利用率越低。</p>
<ul>
<li>当网络覆盖范围越大,既端到端时延越大,信道极限利用率越低,即网络性能越差。另外,端到端时延越大或连接的站点越多,都会导致发生冲突的概率变大,网络性能还会进一步降低。可见,共享式以太网只能作为一种局域网技术。</li>
</ul>
<h4 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h4><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><ul>
<li>集线器是使用电子器件来模拟实际电缆线的工作,因此整个系统仍然像一个传统的以太网那样运行。</li>
<li>使用集线器的以太网在逻辑上仍是一个总线网,各工作站使用的还是 CSMA/CD 协议,并共享逻辑上的总线。</li>
<li>集线器很像一个多接口的转发器,工作在物理层。</li>
</ul>
<h4 id="以太网的帧格式"><a href="#以太网的帧格式" class="headerlink" title="以太网的帧格式"></a>以太网的帧格式</h4><ul>
<li>常用的以太网 MAC 帧格式有两种标准 :<ul>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ul>
</li>
<li>最常用的 MAC 帧是以太网 V2 的格式。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网的帧格式.png" alt="以太网的帧格式"><br><em> 源地址和目的地址的地址指的是 MAC 地址
</em> 类型字段用来表示上层协议的类型<br><em> FCS 是帧检验学列
</em> 如果数据字段的长度小于 46 字节，MAC 子层就会在数据字段的最后加入一个整数字节的填充字段</li>
<li>因为以太网在传输帧的时候，各个帧之间必须有一定的间隙，因此不需要使用帧结束定界符</li>
<li>无效的 MAC 帧<ul>
<li>数据字段的长度与长度字段的值不一致;</li>
<li>帧的长度不是整数个字节;</li>
<li>用收到的帧检验序列 FCS 查出有差错;</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
<li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</li>
</ul>
</li>
</ul>
<h3 id="网桥和以太网交换机"><a href="#网桥和以太网交换机" class="headerlink" title="网桥和以太网交换机"></a>网桥和以太网交换机</h3><h4 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h4><ul>
<li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了局域网覆盖的地理范围。</li>
<li>碰撞域增大了,但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率,那么就不能用集线器将它们互连起<br>来。</li>
<li>由于争用期的限制,并不能无限扩大地理覆盖范围</li>
</ul>
<h4 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h4><ul>
<li>在数据链路层扩展以太网要使用网桥。</li>
<li>网桥工作在数据链路层,它根据 MAC 帧的目的地址对收到的帧进行转发。</li>
<li>网桥具有过滤帧的功能。当网桥收到一个帧时,并不是向所有的接口转发此帧,而是先检查此帧的目的 MAC 地址,然后再确定将该帧转发到哪一个接口</li>
</ul>
<h5 id="使用网桥的好处"><a href="#使用网桥的好处" class="headerlink" title="使用网桥的好处"></a>使用网桥的好处</h5><ul>
<li>过滤通信量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>(由于采用存储转发方式)可互连不同物理层、不同 MAC 子层和不同速率(如 10 Mb/s 和<br>100 Mb/s 以太网)的局域网。</li>
</ul>
<h5 id="使用网桥的缺点"><a href="#使用网桥的缺点" class="headerlink" title="使用网桥的缺点"></a>使用网桥的缺点</h5><ul>
<li>存储转发增加了时延。</li>
<li>在 MAC 子层并没有流量控制功能。</li>
<li>具有不同 MAC 子层的网段桥接在一起时时延更大。</li>
<li>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网,</li>
<li>否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的</li>
<li>广播风暴。</li>
</ul>
<h5 id="网桥和集线器-或转发器-不同"><a href="#网桥和集线器-或转发器-不同" class="headerlink" title="网桥和集线器(或转发器)不同"></a>网桥和集线器(或转发器)不同</h5><ul>
<li>集线器在转发帧时,不对传输媒体进行检测。</li>
<li>网桥在转发帧之前必须执行 CSMA/CD 算法。若在发送过程中出现碰撞,就必须停止发送和进行退避。</li>
</ul>
<h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><ul>
<li>目前使用得最多的网桥是透明网桥(transparent bridge)。“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥,因为网<br>桥对各站来说是看不见的。</li>
<li>透明网桥是一种即插即用设备,其标准是 IEEE 802.1D。</li>
</ul>
<h5 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h5><p>go 语言实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">    port    <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Iptable <span class="keyword">struct</span> &#123;</span><br><span class="line">    records []Record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iptable Iptable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTable</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        <span class="keyword">if</span> record.address == address &#123;</span><br><span class="line">            <span class="keyword">return</span> record.port, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err := errors.New(<span class="string">&quot;没找到记录&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeRecord</span><span class="params">(address <span class="keyword">string</span>, port <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    iptable.records = <span class="built_in">append</span>(iptable.records, Record&#123;port, address&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id  address               port\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%-3d %-20s %-5d\n&quot;</span>, index, record.address, record.port)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> srcAddress, destAddress <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> srcPort <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入源地址和端口号&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>, &amp;srcAddress, &amp;srcPort)</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入目的地址&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;destAddress)</span><br><span class="line">        destPort, err := findTable(destAddress)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中未找到记录&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;从其他端口将此帧转发给别的网桥&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中找到记录&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> srcPort == destPort &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;目的地址和源地址在同一网段，目的主机已经收到&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;将此帧从查找到的端口发出 %d\n&quot;</span>, destPort)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printTable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有,就在转发表中增加一个项目(源地址、进入的接口和时间)。如有,则把原有的项目进行更新。</li>
<li>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<ul>
<li>如没有,则通过所有其他接口(但进入网桥的接口除外)按进行转发。</li>
<li>如有,则按转发表中给出的接口进行转发。</li>
<li>若转发表中给出的接口就是该帧进入网桥的接口,则应丢弃这个帧(因为这时不需要经过网桥进行转发)。</li>
</ul>
</li>
</ul>
<h5 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h5><ul>
<li>互连在一起的网桥在进行彼此通信后,就能找出原来的网络拓扑的一个子集。在这个子集里,整个连通的网络中不存在回路,即在任何两个站之间只有一条路径。</li>
<li>网桥会关闭不在生成树上的那些接口,以确保不存在环路。</li>
<li>为了得出能够反映网络拓扑发生变化时的生成树,在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</li>
</ul>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><ul>
<li>透明网桥容易安装,但网络资源的利用不充分。</li>
<li>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。源站以广播方式向欲通信的目的站发送一个发现帧,每个发现帧都记录所经过的路由。</li>
<li>发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后,从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部,都必须携带源站所确定的这一路由信息。</li>
</ul>
<h5 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h5><ul>
<li>1990 年问世的交换式集线器(switching hub),可明显地提高局域网的性能。</li>
<li>交换式集线器常称为以太网交换机(switch)或第二层交换机(表明此交换机工作在数据链路层)。</li>
<li>以太网交换机通常都有十几个接口。因此,以太网交换机实质上就是一个多接口的网桥,可见交换机工作在数据链路层。</li>
</ul>
<h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><ul>
<li>以太网交换机的每个接口都直接与主机相连,并且一般都工作在全双工方式。</li>
<li>交换机能同时连通许多对的接口,使每一对相互通信的主机都能像独占通信媒体那样,进行无碰撞地传输数据。</li>
<li>以太网交换机由于使用了专用的交换结构芯片,其交换速率较高。</li>
</ul>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><h4 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h4><ul>
<li>无线局域网不能简单地搬用 CSMA/CD 协议。这里主要有两个原因。对于无线信道,接收信号强度往往会远远小于发送信号强度。如要在无线局域网的适配器上实现碰撞检测,对硬件的要求非常高。。</li>
<li>即使我们能够实现碰撞检测的功能,并且当我们在发送数据时检测到信道是空闲的,在接收端仍然有可能发生碰撞(隐蔽站问题)。</li>
<li>无线局域网不能使用 CSMA/CD,而只能使用改进的 CSMA 协议。</li>
<li>改进的办法是把 CSMA 增加一个碰撞避免(Collision Avoidance)功能。</li>
<li>802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时,还增加使用停止等待协议。</li>
<li>下面先介绍 802.11 的 MAC 层。</li>
<li>所有的站在完成发送后,必须再等待一段很短的时间(继续监听)才能发送下一帧。这段时间的通称是帧间间隔 IFS (InterFrame Space)。</li>
<li>帧间间隔长度取决于该站欲发送的帧的类型。高优先级帧需要等待的时间较短,因此可优先获得发送权。</li>
<li>若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>
</ul>
<h5 id="三种帧间间隔"><a href="#三种帧间间隔" class="headerlink" title="三种帧间间隔"></a>三种帧间间隔</h5><ul>
<li>SIFS,即短(Short)帧间间隔,是最短的帧间间隔,用来分隔开属于一次对话的各帧。一个站应当能够在这段时间内从发送方式切换到接收方式。</li>
<li>使用 SIFS 的帧类型有:ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧,以及所有回答 AP 探询的帧<br>和在 PCF 方式中接入点 AP 发送出的任何帧。</li>
<li>PIFS,即点协调功能帧间间隔,它比 SIFS 长,是为了在开始使用 PCF 方式时(在 PCF 方式下使用,没有争用)优先获得接入到媒体中。PIFS 的长度是 SIFS 加一个时隙(slot)长度。</li>
<li>时隙的长度是这样确定的:在一个基本服务集 BSS 内当某个站在一个时隙开始时接入到媒体时,那么在下一个时隙开始时,其他站就都能检测出信道已转变为忙态。</li>
<li>DIFS,即分布协调功能帧间间隔(最长的 IFS),在 DCF 方式中用来发送数据帧和管理帧。DIFS 的长度比 PIFS 再增加一个时隙长度。</li>
<li>欲发送数据的站先检测信道。在 802.11 标准中规定了在物理层的空中接口进行物理层的载波监听。</li>
<li>通过收到的相对信号强度是否超过一定的门限数值就可判定是否有其他的移动站在信道上发送数据。</li>
<li>当源站发送它的第一个 MAC 帧时,若检测到信道空闲,则在等待一段时间 DIFS 后就可发送。</li>
<li>为什么信道空闲还要再等待？这是考虑到可能有其他的站有高优先级的帧要发送。如有,就要让高优先级帧先发送。</li>
</ul>
<h5 id="高优先级帧发送"><a href="#高优先级帧发送" class="headerlink" title="高优先级帧发送"></a>高优先级帧发送</h5><ul>
<li>源站发送了自己的数据帧。</li>
<li>目的站若正确收到此帧,则经过时间间隔 SIFS 后,向源站发送确认帧 ACK。</li>
<li>若源站在规定时间内没有收到确认帧 ACK(可能是发生碰撞),就必须重传此帧,直到收到确认为止,或者经过若干次的重传失败后放弃发送。</li>
<li>确认机制可以认为是一种间接碰撞检测 。</li>
</ul>
<h6 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h6><ul>
<li>为避免碰撞,如果要发送数据的站发现信道忙, 在信道恢复空闲时并不是立即发送数据,而是要退避一段随机的时间(大于 DIFS)若信道仍然空闲才能发送数据</li>
<li>若发送方接收到确认要立即发送下一帧时,为公平竞争,也要执行退避</li>
<li>当发送方没有接收到确认,重传帧时,要将随机选择退避时间的范围扩大一倍。</li>
</ul>
<h5 id="退避计时器"><a href="#退避计时器" class="headerlink" title="退避计时器"></a>退避计时器</h5><ul>
<li>站点每经历一个时隙的时间就检测一次信道。这可能发生两种情况。</li>
<li>若检测到信道空闲,退避计时器就继续倒计时。</li>
<li>若检测到信道忙,就冻结退避计时器的剩余时间,重新等待信道变为空闲并再经过时间 DIFS 后,从剩余时间开始继续倒计时。如果退避计时器的时间减小到零时,就开始发送整个数据帧。</li>
</ul>
<h5 id="退避算法的使用"><a href="#退避算法的使用" class="headerlink" title="退避算法的使用"></a>退避算法的使用</h5><ul>
<li>仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是要发送的第一个数据帧。<br>除此以外的所有情况,都必须使用退避算法。即:<ul>
<li>在发送第一个帧之前检测到信道处于忙态。</li>
<li>在每一次的重传后。</li>
<li>在每一次的成功发送后。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11退避机制.png" alt="802.11退避机制"></li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/24/%E7%AE%97%E6%B3%95/leetcodeP10-RegularExpressionMatching/" rel="prev" title="leetcodeP10-RegularExpressionMatching">
      <i class="fa fa-chevron-left"></i> leetcodeP10-RegularExpressionMatching
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="docker学习">
      docker学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">点对点信道的数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7"><span class="nav-number">2.1.</span> <span class="nav-text">封装成帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="nav-number">2.2.</span> <span class="nav-text">透明传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B"><span class="nav-number">2.3.</span> <span class="nav-text">差错检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B-CRC"><span class="nav-number">2.3.1.</span> <span class="nav-text">循环冗余检测 CRC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%89%E6%98%8E%E7%A0%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">汉明码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">2.4.</span> <span class="nav-text">可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.1.</span> <span class="nav-text">停止等待协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E9%80%80-N-%E5%B8%A7"><span class="nav-number">2.4.2.</span> <span class="nav-text">回退 N 帧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">2.4.3.</span> <span class="nav-text">数据链路层的可靠传输</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE-PPP"><span class="nav-number">3.</span> <span class="nav-text">点对点协议 PPP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">使用广播信道的数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">4.1.</span> <span class="nav-text">媒体接入控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-number">4.2.</span> <span class="nav-text">局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.1.</span> <span class="nav-text">局域网体系结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">网络适配器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MAC-%E5%9C%B0%E5%9D%80"><span class="nav-number">4.2.3.</span> <span class="nav-text">MAC 地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="nav-number">5.</span> <span class="nav-text">共享式以太网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CSMA-CD-%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">CSMA CD 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">二进制指数退避算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-number">5.2.</span> <span class="nav-text">信道利用率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91"><span class="nav-number">5.3.</span> <span class="nav-text">使用集线器的星形拓扑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">集线器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">以太网的帧格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">6.</span> <span class="nav-text">网桥和以太网交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="nav-number">6.1.</span> <span class="nav-text">在物理层扩展以太网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="nav-number">6.2.</span> <span class="nav-text">在数据链路层扩展以太网</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E6%A1%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">使用网桥的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E6%A1%A5%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">6.2.2.</span> <span class="nav-text">使用网桥的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E6%A1%A5%E5%92%8C%E9%9B%86%E7%BA%BF%E5%99%A8-%E6%88%96%E8%BD%AC%E5%8F%91%E5%99%A8-%E4%B8%8D%E5%90%8C"><span class="nav-number">6.2.3.</span> <span class="nav-text">网桥和集线器(或转发器)不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E7%BD%91%E6%A1%A5"><span class="nav-number">6.2.4.</span> <span class="nav-text">透明网桥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.5.</span> <span class="nav-text">自学习算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.2.6.</span> <span class="nav-text">生成树协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E8%B7%AF%E7%94%B1%E7%BD%91%E6%A1%A5"><span class="nav-number">6.2.7.</span> <span class="nav-text">源路由网桥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">6.2.8.</span> <span class="nav-text">以太网交换机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.2.9.</span> <span class="nav-text">以太网交换机的特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-number">7.</span> <span class="nav-text">无线局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CSMA-CA-%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.</span> <span class="nav-text">CSMA&#x2F;CA 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%A7%E9%97%B4%E9%97%B4%E9%9A%94"><span class="nav-number">7.1.1.</span> <span class="nav-text">三种帧间间隔</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E5%B8%A7%E5%8F%91%E9%80%81"><span class="nav-number">7.1.2.</span> <span class="nav-text">高优先级帧发送</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">退避算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%80%E9%81%BF%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">7.1.3.</span> <span class="nav-text">退避计时器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.1.4.</span> <span class="nav-text">退避算法的使用</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiezi19971225</p>
  <div class="site-description" itemprop="description">记录编程学习路上的点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiezi19971225</span>
</div>
  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"/>
  <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备17001385号-1</a>
  <br/>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
