<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="baidu-site-verification" content="5IfwMCE5hH" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.jiezi19971225.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言这里说明一下打包工具的概念，打包工具是用来将多个 js 文件和他们的依赖组合成一个或者多个 bundle 文件的工具。前端知名的打包工具有 webpack，rollup，gulp 等。  我们的前端项目一般都会使用 webpack 进行构建。随着项目规模不断增加，引入的依赖逐渐增多，我们开启开发服务器和进行生产构建的时间会不断增加。目前我的公司的项目开启开发服务器需要 1 分钟左右，进行生产构">
<meta property="og:type" content="article">
<meta property="og:title" content="esbuild简介">
<meta property="og:url" content="http://www.jiezi19971225.cn/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="Jiez19971225‘s Blog">
<meta property="og:description" content="前言这里说明一下打包工具的概念，打包工具是用来将多个 js 文件和他们的依赖组合成一个或者多个 bundle 文件的工具。前端知名的打包工具有 webpack，rollup，gulp 等。  我们的前端项目一般都会使用 webpack 进行构建。随着项目规模不断增加，引入的依赖逐渐增多，我们开启开发服务器和进行生产构建的时间会不断增加。目前我的公司的项目开启开发服务器需要 1 分钟左右，进行生产构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.jiezi19971225.cn/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/bundle.png">
<meta property="article:published_time" content="2021-07-19T08:04:20.000Z">
<meta property="article:modified_time" content="2021-10-21T16:45:16.147Z">
<meta property="article:author" content="jiezi19971225">
<meta property="article:tag" content="esbuild">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.jiezi19971225.cn/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/bundle.png">

<link rel="canonical" href="http://www.jiezi19971225.cn/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>esbuild简介 | Jiez19971225‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jiez19971225‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做自己爱做的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.jiezi19971225.cn/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiezi19971225">
      <meta itemprop="description" content="记录编程学习路上的点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jiez19971225‘s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          esbuild简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 08:04:20" itemprop="dateCreated datePublished" datetime="2021-07-19T08:04:20+00:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 16:45:16" itemprop="dateModified" datetime="2021-10-21T16:45:16+00:00">2021-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">开发工具</span></a>
                </span>
            </span>

          

          <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-bar-chart"></i>
            </span>
            <span class="post-meta-item-text">字数统计:</span>
            <span class="post-count">3.3k(字)</span>

          </span>

            <span class="post-time">
          &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-clock-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">13(分)</span>

          </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里说明一下打包工具的概念，打包工具是用来将多个 js 文件和他们的依赖组合成一个或者多个 bundle 文件的工具。前端知名的打包工具有 webpack，rollup，gulp 等。</p>
<p><img src="/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/bundle.png" alt="打包过程"></p>
<p>我们的前端项目一般都会使用 webpack 进行构建。随着项目规模不断增加，引入的依赖逐渐增多，我们开启开发服务器和进行生产构建的时间会不断增加。目前我的公司的项目开启开发服务器需要 1 分钟左右，进行生产构建需要 5 分钟以上，而这已经是进行微前端拆分后的结果，如果还是单体巨石应用的结构，那画面太美不敢想象。webpack 的速度实在是太慢，esbuild 就是为了解决这一痛点而被创造出来的。</p>
<p>esbuild 是使用 go 语言编写的一个新一代的 JavaScript 打包工具，它的作者是 figma 的 CTO Evan Wallace。得益于 go 语言编译型语言的优点，打包速度可以达到 webpack 的几十倍。一些知名的热门项目已经内置了 esbuild，比如 vite，snowpack。今天我们就跟随 esbuild 的官方文档，学习一下 esbuild 的相关知识。</p>
<p>下文的主要内容包括</p>
<ul>
<li>为什么 esbuild 这么快</li>
<li>上手使用 esbuild</li>
<li>esbuild plugin api 简介</li>
<li>esbuild 目前的局限</li>
</ul>
<h3 id="esbuild-为什么那么快"><a href="#esbuild-为什么那么快" class="headerlink" title="esbuild 为什么那么快"></a>esbuild 为什么那么快</h3><p>在文档中作者给出了 esbuild 与其他打包工具对 three.js 进行的打包基准测试结果，我们可以看到 esbuild 的速度惊人的快，最高是 rollup 和 webpack 的百倍。<br>| Bundler | Time | Relative slowdown |Absolute speed| Output size|<br>|—-|—-|—-|—-|—-|<br>|esbuild |0.37s |1x |1479.6 kloc/s |5.81mb|<br>|esbuild (1 thread) |1.61s |4x |340.0 kloc/s |5.81mb|<br>|rollup + terser |37.79s |102x |14.5 kloc/s |5.81mb|<br>|parcel 2 |39.28s |106x |13.9 kloc/s |5.87mb|<br>|webpack 4 |43.07s |116x |12.7 kloc/s |5.97mb|<br>|webpack 5 |55.25s |149x |9.9 kloc/s |5.84mb|</p>
<p>这里大家一定非常好奇 esbuild 是如何做到如此之快的，在官方文档的 FAQ 中给出了以下解释:</p>
<h4 id="go-语言编写"><a href="#go-语言编写" class="headerlink" title="go 语言编写"></a>go 语言编写</h4><p>go 是为了<strong>并行</strong>而被设计出来的<strong>编译型语言</strong>，速度相比使用<strong>脚本语言</strong> JavaScript 编写的同类工具有很大的优势。<br>尽管 v8 引擎提供了 JIT 的特性，很大程度上提升了 Javascript 的性能，但是对于命令行程序，它依然太慢了。 每次运行打包器时，JavaScript VM 都会在没有任何优化的情况下运行打包程序的代码。在 esbuild 忙于解析 JavaScript 时，node 还在忙于解析打包程序的 JavaScript。<br>在线程间通信方面， Go 在线程之间可以共享内存，而 JavaScript 必须在线程之间传递序列化数据，这一点显然共享内存的效率更高。<br>Go 和 JavaScript 都有并行的垃圾收集器，但是 Go 的堆在所有线程之间共享，而对于 JavaScript, 每个 JavaScript 线程中都有一个单独的堆。</p>
<h4 id="充分使用并行"><a href="#充分使用并行" class="headerlink" title="充分使用并行"></a>充分使用并行</h4><p>esbuild 内部的算法专门被设计为可以最大程度利用 cpu 资源的形式。esbuild 的工作流程可大致分为三个阶段，解析，链接和代码生成。其中作为主要工作的解析代码和代码生成全部并行方式处理。因为所有的线程共享了内存，不同入口文件的打包工作可以使用相同的导入的 Javascript 模块数据。<br>这里需要额外说明一下，Go 语言是一门为并发编程设计的语言，它原生支持协程。</p>
<h4 id="代码完全自己编写"><a href="#代码完全自己编写" class="headerlink" title="代码完全自己编写"></a>代码完全自己编写</h4><p>esbuild 不使用第三方库，自己来编写实现 js/ts 的编译相关模块，带来了很多细节上的性能优化。</p>
<h4 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h4><p>理想情况下，编译器以近乎 O(n) 的复杂度处理输入，如果需要处理大量数据，内存访问速度可能会严重影响性能。如果你能更少地遍历代码，编译器的运行速度就会更快。<br>esbuild 只会访问 js/ts 的 AST 三次。<br>第一次是对于词法解析，作用域设置，以及声明符号<br>第二次是绑定符号，压缩语法， JSX/TS 转 JS，ESNext 转 ES2015<br>第三次是压缩标识符，压缩空白字符，生成代码与生成 sourcemap<br>esbuild 最大程度重用了 AST 数据，当它们还在 cpu 的缓存中时。</p>
<p>综合以上的几个方面，使得 esbuild 的速度比起其他打包工具高出一个数量级。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>esbuild 提供了三种方式来使用 esbuild，分别是 命令行，npm 包 和 go 包<br>esbuild 提供了两种调用类型主要 API 类型，Transform API 和 Build API<br>下面分别简单介绍一下它们的使用</p>
<h4 id="npm-包方式"><a href="#npm-包方式" class="headerlink" title="npm 包方式"></a>npm 包方式</h4><p>首先安装 esbuild</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install esbuild</span><br></pre></td></tr></table></figure>
<p>可以看到 esbuild 的 npm 包结构如下:</p>
<p>│ esbuild.exe<br>│ install.js<br>│ package.json<br>│ README.md<br>│<br>├─bin<br>│ esbuild<br>│<br>├─lib<br>│ main.d.ts<br>│ main.js</p>
<p>esbuild 是一个 go 语言编译的可执行程序， 包在安装时会根据所在平台安装对应的可执行程序，windows 系统下就是 esbuild.exe 。lib 下 main.js 提供了对于 esbuild 可执行程序调用的封装。</p>
<p>以下是官网的示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).writeFileSync(<span class="string">&quot;in.ts&quot;</span>, <span class="string">&quot;let x: number = 1&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>).buildSync(&#123;</span><br><span class="line">  <span class="attr">entryPoints</span>: [<span class="string">&quot;in.ts&quot;</span>],</span><br><span class="line">  <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFileSync(<span class="string">&quot;out.js&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h4><p>使用 npm 安装 esbuild 后，我们也可以通过命令行的方式调用 esbuild。esbuild 在 package.json 中定义了 bin 的配置，该文件是一个 node 脚本，用以子进程方式调用 esbuild 可执行文件。</p>
<p>根据 npm 的约定，当 package.json 中定义了 bin 选项时，包安装时会自动将脚本软链接到 node_modules/.bin 目录下。当使用 npm 执行定义在 scripts 中的命令时，会自动将 node_modules/.bin 目录下添加到 PATH 中。通过这种方式就可以以命令行方式调用 esbuild。</p>
<h4 id="Transform-API"><a href="#Transform-API" class="headerlink" title="Transform API"></a>Transform API</h4><p>Transform API 对单个字符串进行操作，它不访问文件系统。这使得它非常适合在没有文件系统(例如浏览器)的环境中使用，或者作为另一个工具链的一部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;esbuild&#x27;</span>).transformSync(<span class="string">&#x27;let x: number = 1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;ts&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">=&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;let x = 1;\n&#x27;</span>,</span><br><span class="line">  <span class="attr">map</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">warnings</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>社区中有很多基于 esbuild Transform API 打造的其他打包工具的插件，比如</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/privatenumber/esbuild-loader">esbuild-loader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/egoist/rollup-plugin-esbuild">rollup-plugin-esbuild</a></li>
</ul>
<h4 id="Build-API"><a href="#Build-API" class="headerlink" title="Build API"></a>Build API</h4><p>esbuild 的 Build API 做的事情和 webpack，rollup 等一样，需要入口文件，用于将一系列文件及其以来打包输出到一个或多个文件中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).writeFileSync(<span class="string">&quot;in.ts&quot;</span>, <span class="string">&quot;let x: number = 1&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>).buildSync(&#123;</span><br><span class="line">  <span class="attr">entryPoints</span>: [<span class="string">&quot;in.ts&quot;</span>],</span><br><span class="line">  <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">  <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFileSync(<span class="string">&quot;out.js&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">(<span class="string">&quot;let x = 1;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>设置 watch 选项为 true 既可以开启开发服务器模式，esbuild 会监听文件系统的变化并自动重新 build。</p>
<h3 id="内置-loaders"><a href="#内置-loaders" class="headerlink" title="内置 loaders"></a>内置 loaders</h3><p>esbuild 内置的 loaders 可以处理以下文件类型：JavaScript，typescript，jsx，json，css，text，binary，base64，dataurl，external file</p>
<p>除了 external，其他类型的 loader 会在处理相关扩展名的文件时自动调用，也可以通过 loader 手动设置调用规则。</p>
<p>需要注意的是 esbuild 对于 js 的处理。如果你想要用 esbuild 转译 es5 的代码，需要将<strong>target 设置为 es5</strong>，这可以避免 esbuild 进行错误的转译，比如将<code>&#123;x:x&#125;</code> 转译为 <code>&#123;x&#125;</code>。</p>
<p>esbuild 目前对将<strong>es6+ 的代码转译为 es5 的代码的支持不完善</strong>，如 <code>let</code>，<code>const</code> 等语法不会被转译。</p>
<h3 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h3><p>同 rollup 和 和 webpack 一样，esbuild 提供了插件机制，目前 esbuild 的插件 api 还在实验阶段，在未来可能会有很大的变动。<br><strong>esbuild 目前只支持在 build API 中使用插件，不支持 transform API</strong>。</p>
<h4 id="编写-esbuild-插件"><a href="#编写-esbuild-插件" class="headerlink" title="编写 esbuild 插件"></a>编写 esbuild 插件</h4><p>一个 esbuild 的插件是一个对象，有一个 <code>name</code> 属性和一个 <code>setup</code> 函数。在 build API 中，我们可以设置 plugins 数组。插件对象中的 <code>setup</code> 函数会在 build 每次运行时调用一次。</p>
<p>下面是文档中的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> envPlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;env&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Intercept import paths called &quot;env&quot; so esbuild doesn&#x27;t attempt</span></span><br><span class="line">    <span class="comment">// to map them to a file system location. Tag them with the &quot;env-ns&quot;</span></span><br><span class="line">    <span class="comment">// namespace to reserve them for this plugin.</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^env$/</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">path</span>: args.path,</span><br><span class="line">      <span class="attr">namespace</span>: <span class="string">&quot;env-ns&quot;</span>,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load paths tagged with the &quot;env-ns&quot; namespace and behave as if</span></span><br><span class="line">    <span class="comment">// they point to a JSON file containing the environment variables.</span></span><br><span class="line">    build.onLoad(&#123; <span class="attr">filter</span>: <span class="regexp">/.*/</span>, namespace: <span class="string">&quot;env-ns&quot;</span> &#125;, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">contents</span>: <span class="built_in">JSON</span>.stringify(process.env),</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>)</span><br><span class="line">  .build(&#123;</span><br><span class="line">    <span class="attr">entryPoints</span>: [<span class="string">&quot;app.js&quot;</span>],</span><br><span class="line">    <span class="attr">bundle</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [envPlugin],</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> process.exit(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>这个插件的作用是让 esbuild 将以 env 结尾的文件作为 json 文件解析。可以看到 esbuild 的插件编写非常简单，只有少量的关键概念和关键 API，下面我们来简单了解一下。</p>
<h4 id="两个关键观念"><a href="#两个关键观念" class="headerlink" title="两个关键观念"></a>两个关键观念</h4><h5 id="Namespaces-命名空间"><a href="#Namespaces-命名空间" class="headerlink" title="Namespaces 命名空间"></a>Namespaces 命名空间</h5><p>每个模块有一个关联的命名空间。默认情况下，esbuild 在 <code>file</code> 命名空间下工作，它对应于真实文件系统上的文件。<br>esbuild 也可以处理虚拟的模块，即并不对应于文件系统上的文件。举个例子，比如从 <code>stdin</code> 中提供的模块。</p>
<p>可以用插件去创建虚拟模块，标注模块在一个特定的命名空间，以使用其他的插件进行特殊处理。</p>
<h5 id="Filters-过滤器"><a href="#Filters-过滤器" class="headerlink" title="Filters 过滤器"></a>Filters 过滤器</h5><p>每一个回调函数必须提供一个正则表达式作为过滤器，那些不匹配的模块将被跳过处理。<br>你应该尽可能使用过滤正则表达式而非使用 js 代码来处理，因为 Filters 是在 esbuild 内部处理的，效率更高。</p>
<h4 id="两个主要回调"><a href="#两个主要回调" class="headerlink" title="两个主要回调"></a>两个主要回调</h4><h5 id="onResolve-回调"><a href="#onResolve-回调" class="headerlink" title="onResolve 回调"></a>onResolve 回调</h5><p>使用 onResolve 添加的回调会在每次 esbuild build 过程中的路径解析阶段被调用。这个回调用来自定义 esbuild 解析路径的行为。</p>
<p>下面这个例子中，插件将以 images 开头的导入路径重定向到 /public/images 目录，将 http 开头的路径标记为 external。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleOnResolvePlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redirect all paths starting with &quot;images/&quot; to &quot;./public/images/&quot;</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^images\//</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: path.join(args.resolveDir, <span class="string">&quot;public&quot;</span>, args.path) &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark all paths starting with &quot;http://&quot; or &quot;https://&quot; as external</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^https?:\/\//</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: args.path, <span class="attr">external</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="onLoad-回调"><a href="#onLoad-回调" class="headerlink" title="onLoad 回调"></a>onLoad 回调</h5><p>使用 onLoad 添加的回调会在所有没有被标记为 external 的模块中运行，模块由路径和命名空间共同标识。它用来自定义模块返回的内容，告诉 esbuild 如何去转译它。</p>
<p>下面这个例子中，插件将以 txt 文件以 utf8 方式获取内容后，以 json 数据形式读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleOnLoadPlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load &quot;.txt&quot; files and return an array of words</span></span><br><span class="line">    build.onLoad(&#123; <span class="attr">filter</span>: <span class="regexp">/\.txt$/</span> &#125;, <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> text = <span class="keyword">await</span> fs.promises.readFile(args.path, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">contents</span>: <span class="built_in">JSON</span>.stringify(text.split(<span class="regexp">/\s+/</span>)),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>)</span><br><span class="line">  .build(&#123;</span><br><span class="line">    <span class="attr">entryPoints</span>: [<span class="string">&quot;app.js&quot;</span>],</span><br><span class="line">    <span class="attr">bundle</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [exampleOnLoadPlugin],</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> process.exit(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="esbuild-插件的局限"><a href="#esbuild-插件的局限" class="headerlink" title="esbuild 插件的局限"></a>esbuild 插件的局限</h4><p>esbuild 的插件无法做到覆盖全部的用户场景。它只提供了自定义模块家在方式和自定义模块返回内容的能力，没有提供给我们直接访问 js ast 的能力，这是出于为了保持 esbuild 卓越性能的考虑，但这也导致很多 babel 插件提供的基于 js ast 的转译功能都无法使用 esbuild 的插件机制来实现。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>esbuild 作为打包工具的性能表现是极为出色的，但是现阶段并不能代替 webpack。一方面，webpack 经过多年的发展，生态非常成熟，可以覆盖到几乎所有的使用场景，另一方面，esbuild 本身受限的插件机制使得它注定无法完成一些事情。<br>比如说我们使用 webpack 中使用的 基于 ast 的 babel 插件，是没办法迁移到 esbuild 中去的，因为 esbuild 根本不提供访问 ast 的能力。<br>对于基于 webpack 的老项目，通常包含了很多基于 webpack 生态的 loader，插件等，将它们迁移到 esbuild 是一项艰巨且风险巨大的工作。新的项目没有技术债务，可以使用 esbuild 作为构建工具，可以极大提升开发体验。<br>但是，把 esbuild 作为纯的 js/ts 转译工具，或者作为代码压缩工具，作为其他构建工具工具链的一部分，是可以的融入到老项目中，提升构建速度的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://esbuild.github.io/">esbuild 官方文档</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39843414/article/details/117719170">「 不懂就问 」esbuild 为什么这么快?</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/esbuild/" rel="tag"># esbuild</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/21/%E6%9D%82%E9%A1%B9/%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/" rel="prev" title="时区问题踩坑">
      <i class="fa fa-chevron-left"></i> 时区问题踩坑
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/28/%E6%9D%82%E9%A1%B9/switch%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/" rel="next" title="switch虚拟系统折腾记录">
      switch虚拟系统折腾记录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#esbuild-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB"><span class="nav-number">2.</span> <span class="nav-text">esbuild 为什么那么快</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#go-%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99"><span class="nav-number">2.1.</span> <span class="nav-text">go 语言编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%85%E5%88%86%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C"><span class="nav-number">2.2.</span> <span class="nav-text">充分使用并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%8C%E5%85%A8%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99"><span class="nav-number">2.3.</span> <span class="nav-text">代码完全自己编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-number">2.4.</span> <span class="nav-text">高效使用内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">开始使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#npm-%E5%8C%85%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">npm 包方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">命令行方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transform-API"><span class="nav-number">3.3.</span> <span class="nav-text">Transform API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-API"><span class="nav-number">3.4.</span> <span class="nav-text">Build API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE-loaders"><span class="nav-number">4.</span> <span class="nav-text">内置 loaders</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">插件机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99-esbuild-%E6%8F%92%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">编写 esbuild 插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E8%A7%82%E5%BF%B5"><span class="nav-number">5.2.</span> <span class="nav-text">两个关键观念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Namespaces-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">5.2.1.</span> <span class="nav-text">Namespaces 命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Filters-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">Filters 过滤器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%9B%9E%E8%B0%83"><span class="nav-number">5.3.</span> <span class="nav-text">两个主要回调</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#onResolve-%E5%9B%9E%E8%B0%83"><span class="nav-number">5.3.1.</span> <span class="nav-text">onResolve 回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#onLoad-%E5%9B%9E%E8%B0%83"><span class="nav-number">5.3.2.</span> <span class="nav-text">onLoad 回调</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#esbuild-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B1%80%E9%99%90"><span class="nav-number">5.4.</span> <span class="nav-text">esbuild 插件的局限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">6.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiezi19971225</p>
  <div class="site-description" itemprop="description">记录编程学习路上的点滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiezi19971225</span>
</div>
  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"/>
  <a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备17001385号-1</a>
  <br/>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
