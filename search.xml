<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>块格式化上下文</title>
    <url>/2019/08/03/CSS/CSS2%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一致性-要求和建议"><a href="#一致性-要求和建议" class="headerlink" title="一致性 要求和建议"></a>一致性 要求和建议</h3><p>CSS 渲染模型中不考虑替换元素的内容。</p>
<p>在 CSS 2.1 中，只有替换元素才能具有内在维度。对于没有可靠分辨率信息的光栅图像，必须假设每个图像源像素的大小为 1 像素单位。</p>
<p>HTML 的元素名是大小写不敏感的 但是在 XML 中是大小写敏感的</p>
<p>0 长度单位后的单位是可选的</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>E[foo] 匹配设置了”foo”属性（无论值是什么）的 E 元素</p>
<p>E[foo=”warning”] 匹配所有”foo”属性值恰好是”wraning”的 E 元素</p>
<p>E[foo~=”warning”] 匹配所有”foo”属性值为一列空格分隔的值，且其中之一恰好是”warning”的 E 元素</p>
<p>E[lang|=”en”] 匹配所有”lang”属性值为一列以”en”开头（从左向右）用连字符分隔的值的 E 元素</p>
<p>link 伪类：:link 与:visited</p>
<p>动态伪类： :hover，:active 与:focus</p>
<p>:first-line 伪元素对段落内容的第一个格式化行应用特殊样式(选择器”P:first-line”不会匹配任何真实 HTML 元素。它匹配一个（与 CSS 规范）一致的用户代理将在每个段落的开头插入的伪元素) :first-line 伪元素只能用于块容器元素</p>
<p>:first-letter 伪元素必须选择一个块的第一行的第一个字母</p>
<p>当:first-letter 和:first-line 伪元素被应用在一个具有使用:before 和:after 生成内容的元素，它们应用于元素包括生成的内容在内的首字母或首行</p>
<h3 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h3><p>为了让用户代理能够避免为不支持的媒体类型检索资源，编写者可以指定带媒体依赖（media-dependent）的@import 规则。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;fineprint.css&quot;</span>) print;</span><br></pre></td></tr></table></figure>
<ul>
<li>用户样式表，简单来说就是浏览器的使用者自己编写的一份默认样式表，编写者样式表，是网页的编写者编写的样式表，第一次听说这种说法</li>
</ul>
<h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>Block-level 块级元素 包含以下类型 block list-item table list-item 会生成附加的盒子，相对于主盒子放置</p>
<p>block container box 只包含块级元素或者内联块级元素，</p>
<p>匿名块级盒子 当块级盒子同时包含内联的文本和块级元素时，我们认为这里有一个匿名的盒子包围了这些文本，如果一个块级盒子包含了块级盒子，我们强制让他只包含块级盒子</p>
<p>以@开头的规则（At-rules）需要以分号来结尾</p>
<p>CSS 2.1 用户代理必须忽略在块内或在除@cherset 或@import 规则之外的任何非忽略语句之后发生的任何“@import”规则。一下是非法的，解决方法是将样式的语法放在 At-rules 之后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;subs.css&quot;</span>;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;list.css&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>‘margin-top’, ‘margin-bottom’ 这两个属性对非替换的行内元素无效</p>
<p>两个 margin 是相邻的，当且仅当</p>
<p>都属于流内（in-flow）块级盒，处于同一个块格式化上下文</p>
<ul>
<li>没有行框（line box），空隙，内边距和边框把它们隔开（注意，因此某些 0 高度行框（见 9.4.2）会被忽略）</li>
<li>都属于垂直相邻框边界（vertically-adjacent box edges），即形成下列某一对：<ul>
<li>盒的上边距与其第一个流内（in-flow）孩子的上边距</li>
<li>盒的下边距与其下一个流内紧挨着的兄弟的上边距</li>
<li>最后一个流内孩子的下边距与其 height 计算值为’auto’的父元素的下边距</li>
<li>盒的上边距和下边距，要求该盒没有建立新的块格式化上下文，并且’min-height’计算值为 0，’height’计算值为 0 或’auto’，还没有流内孩子</li>
</ul>
</li>
<li>margin 和 padding 的百分比数值都相对于包含块，border 不能设置百分比数值</li>
</ul>
<h3 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h3><p>以下方式会创建块格式化上下文</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content 或 strict 的元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中</li>
<li><p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。</p>
</li>
<li><p>行内级元素是源文档中那些不会形成新内容块的元素，内容分布于多行 ‘display’属性的下列值能让一个元素变成行内级：’inline’，’inline-table’和’inline-block’。一个 inline-block 的内部会被格式化成一个块盒，而该元素本身会被格式化成一个原子行内级盒</p>
</li>
<li><p>display 为 table 系的元素的 postion:relative 效果是未定义的</p>
</li>
<li>盒偏移：’top’，’right’，’bottom’，’left’ 如果元素的’position’属性有一个除’static’外的值，就说它是定位元素（positioned） 百分比数值参照包含块的宽度</li>
<li>如果’left’和’right’都不是’auto’，位置就被过度约束（over-constrained）了，它们（’left’和’right’）其中有一个会被忽略。如果包含块的’direction’属性是’ltr’，那么’left’有效，’right’变成-‘left’（负的’left’）。如果包含块的’direction’属性是’rtl’，那么’right’有效，’left’被忽略</li>
<li>清除浮动的方法 overflow-hidden 创建了一个 BFC，BFC 在计算高度的 也计算浮动元素的高度</li>
<li>注意 ‘direction’属性，给表格列元素指定时，不会被列中的单元格继承，因为在文档树中，列不是单元格的祖先。因此，CSS 无法轻易获知[HTML4]的 11.3.2.1 节中”dir”属性的继承规则</li>
<li>direction 和 unicode-bidi 属性结合处理文本流方向问题（不仅，而且句子从右向左，单词也倒着写）</li>
</ul>
<h3 id="视觉格式化模型细节"><a href="#视觉格式化模型细节" class="headerlink" title="视觉格式化模型细节"></a>视觉格式化模型细节</h3><p>width 应用于除了非替换的行内元素，表格行和行组（row group） 外的所有元素,非替换的行内元素盒的内容宽度是它里面渲染的内容（的内容宽度）负值对于 width 是非法的。</p>
<p>行内非替换（non-replaced）元素 ‘width’属性不适用，其计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’。</p>
<p>行内替换元素 计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’ 如果’height’和’width’计算值都是’auto’，并且该元素还具有固有宽度，那么这个固有宽度就是’width’的应用值。</p>
<p>height 指定一个百分比高度。百分比参照生成盒的包含块的高度。如果包含块的高度没有显式指定（即取决于内容高度），并且该元素不是绝对定位的，则计算值为’auto’。根元素上的百分比高度是相对于初始包含块的 注意：对于那些包含块基于一个块级元素的绝对定位元素，百分比根据这个元素的内边距框（padding box）的高度来计算。这与 CSS1 不同，（CSS1 中）百分比总是根据父级元素的内容框（content box）来计算</p>
<p>line-height 的百分比参考元素自身的字体大小</p>
<p>vertical-align 的百分比是行高</p>
<h3 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h3><ul>
<li>visibility hidden 生成的盒是不可见的（完全透明，什么都不绘制），但仍然会影响布局。而且该元素具有’visibility: visible’的后代将是可见的</li>
</ul>
<h3 id="颜色与背景"><a href="#颜色与背景" class="headerlink" title="颜色与背景"></a>颜色与背景</h3><ul>
<li>background-attachment 指定了它应该相对视口固定，还是随包含块滚动</li>
</ul>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul>
<li>字母与单词间距 ‘letter-spacing’和’word-spacing’</li>
<li>‘text-transform’属性 转换单词大小写</li>
<li>‘white-space’属性 决定如何处置换行符</li>
</ul>
<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>cursor crosshair 简单十字 move 暗示可移动 text 暗示可选中的文本 wait 暗示正忙<br>outline 当元素具有焦点时，可应用轮廓属性，该属性不占用空间</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass学习</title>
    <url>/2019/09/16/CSS/Sass%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>记录一下从 Sass 官网学习到的 Sass 的一些高级应用。</p>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h2><p>@content 是一个特殊的占位符，可以把 @includes 的 body 中的内容传递进入</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><p>CSS 定义了许多函数，一些在 sass 中工作的很好，他们被解析为函数调用，然后转换为普通传递 css 函数。但是有一些例外，他们被解析为 Sass 脚本表达式。所有特殊的函数调用返回 unquoted 字符串</p>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><p>他可以接受 quoted 或者 unquoted 的 URL，当他接受一个有效的 unquoted URL 的时候，Sass 按照原样解析它，如果它包含变量或函数调用，它被解析为一个普通的 CSS 函数调用。</p>
<h2 id="at-rules"><a href="#at-rules" class="headerlink" title="at-rules"></a>at-rules</h2><p>use 是 scss 模块化语法，未来将代替 import，导入的文件必须以_开头</p>
<p>forward 可以传递模块，但是在本文件中无法使用，要使用还需要额外使用 use 加载，不用担心的是模块只会被加载一次</p>
<h2 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h2><p>有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.funky</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: <span class="number">30em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明</p>
<h2 id="extend"><a href="#extend" class="headerlink" title="@extend"></a>@extend</h2><p>用于扩展继承样式</p>
<p>可以继承一个 html 元素的样式，你对于该元素添加的样式都会继承</p>
<h2 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h2><p>使用 !default 用于变量</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="普通-CSS-函数"><a href="#普通-CSS-函数" class="headerlink" title="普通 CSS 函数"></a>普通 CSS 函数</h3><p>任何不再内置和用户定义函数列表中的函数会被编译为 css 函数，除非它使用了 scss 的参数语法</p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>abs, ceil, floor,max,min,percentage,round 顾名思义</p>
<p>comparable($number1,$number2) //=&gt; boolean 返回数值单位是否具有可比较性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@debug</span> comparable(<span class="number">2px</span>, <span class="number">1px</span>); // true</span><br><span class="line"><span class="keyword">@debug</span> comparable(<span class="number">100px</span>, <span class="number">3em</span>); // false</span><br><span class="line"><span class="keyword">@debug</span> comparable(<span class="number">10cm</span>, <span class="number">3mm</span>); // true</span><br></pre></td></tr></table></figure>
<p>random($number) 生成随机数，如果 limit 是 null，返回一个 0-1 之间的随机数</p>
<p>unitless($number) //=&gt; boolean 判断 $number 是否具有单位</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>quote($string) //=&gt; string 加上双引号, unquote 去掉双引号</p>
<p>str-index,str-insert,str-length,str-slice,to-upper-case,to-lower-case 顾名思义</p>
<p>unique-id() //=&gt; string 生成随机字符串</p>
<h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// color 综合调整</span></span><br><span class="line">adjust-<span class="attribute">color</span>($color,$red: null, $green: null, $blue: null,$hue: null, $saturation: null, $lightness: null,$alpha: null)</span><br><span class="line"><span class="comment">// color 色调调整</span></span><br><span class="line">adjust-hue($color, $degrees)</span><br><span class="line">alpha($color)</span><br><span class="line"><span class="attribute">opacity</span>($color)</span><br><span class="line"></span><br><span class="line"><span class="comment">// blue,red,green,hue,saturation,lightness,aplha 用法类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//color 调整颜色参数的某一项数值</span></span><br><span class="line">change-<span class="attribute">color</span>($color,$red: null, $green: null, $blue: null,$hue: null, $saturation: null, $lightness: null,$alpha: null)</span><br><span class="line"><span class="comment">// 返回补色</span></span><br><span class="line">complement($color)</span><br></pre></td></tr></table></figure>
<p>太多了就不罗列了 详见官方文档 <a href="https://sass-lang.com/documentation/functions/color">sass 颜色函数</a></p>
<h2 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">append,index,length,nth,set-nth 这些函数顾名思义</span><br><span class="line"><span class="comment">// 合并两个列表</span></span><br><span class="line">join($list1, $list2, $separator: auto, $bracketed: auto)</span><br><span class="line"><span class="comment">// unquoted string 返回列表的分隔符</span></span><br><span class="line">list-separator($list)</span><br></pre></td></tr></table></figure>
<h2 id="映射函数"><a href="#映射函数" class="headerlink" title="映射函数"></a>映射函数</h2><p>略</p>
<h2 id="选择器函数"><a href="#选择器函数" class="headerlink" title="选择器函数"></a>选择器函数</h2><p>实用性不大，略过</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>css世界笔记</title>
    <url>/2020/02/22/CSS/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="chapter3-流，元素与基本尺寸"><a href="#chapter3-流，元素与基本尺寸" class="headerlink" title="chapter3 流，元素与基本尺寸"></a>chapter3 流，元素与基本尺寸</h2><p>外在盒子与内在盒子-外在盒子负责元素是可以一行显示,还是只能换行显示;内在盒子负责宽高、内容呈现什么的。内在盒子专业的名称是“容器盒子”。y 属性值是 inline-block 的元素既能和图文一行显示,又能直接设置 width/height。</p>
<p>width:auto 的四种表现</p>
<ul>
<li>充分利用可用空间，即 fill-available， 4 。比方说,<code>&lt;div&gt;</code>;、 <code>&lt;p&gt;</code>;这些元素的宽度默认是 100% 于父级容器的。</li>
<li>收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素,<br>英文称为 shrink-to-fit,可简单理解为“包裹性”。CSS3 中的 fit-content 指的就是这种宽度表现。</li>
<li>收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中,</li>
<li>超出容器限制。除非有明确的 width 相关设置,否则上面 3 种情况尺寸都不会主动<br>超过父级容器宽度的,但是存在一些特殊情况。例如,内容很长的连续的英文和数字,或者内联<br>元素被设置了 white-space:nowarp。</li>
</ul>
<p>唯一的外部尺寸是 div 的宽，外部尺寸是指宽度由外部元素决定</p>
<h3 id="外部尺寸与流体特性"><a href="#外部尺寸与流体特性" class="headerlink" title="外部尺寸与流体特性"></a>外部尺寸与流体特性</h3><p>正常流宽度</p>
<p>正常填充满盒子。</p>
<p>格式化宽度</p>
<p>格式化宽度仅出现在“绝对定位模型”中,也就是出现在 position 属性值为 absolute 或 fixed 的元素中。在默认情况下,绝对定位元素的宽度表现是“包裹性”,宽度由于内部尺寸决定。但有一种情况例外。对于非替换元素，,当 left/top 或 top/bottom 对立方位的属性值同时存在的时候,元素的宽度表现为“格式化宽度”,其宽度大小相对于最近的具有定位特性<br>(position 属性值不是 static)的祖先元素计算。</p>
<h3 id="内部尺寸与流体特性"><a href="#内部尺寸与流体特性" class="headerlink" title="内部尺寸与流体特性"></a>内部尺寸与流体特性</h3><p>包裹性</p>
<p>自适应性 元素尺寸是元素尺寸由内部元素决定,但永远小于“包含块”容器的尺寸。因此,对于一个元素,如果其 display 属性值是 inline-block,那么即使其里面内容再多,只要是正常文本,宽度也不会超过容器。</p>
<p>文字少的时候居中显示,文字超过一行的时候居左显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首选最小宽度 对于东亚文字，最小宽度为每个字的宽度，西方文字的最小宽度是由特定的连续的英文字符单元决定的，利用首选最小宽度可以实现</p>
<h3 id="宽度分离原则"><a href="#宽度分离原则" class="headerlink" title="宽度分离原则"></a>宽度分离原则</h3><p>width 属性不与 padding/border 共存，更好的方式是使用 box-sizing:border-box</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="height-auto"><a href="#height-auto" class="headerlink" title="height:auto"></a>height:auto</h3><p>对于 height 属性,如果父元素 height 为 auto,只要子元素在文档流中,其百分比值完全就被忽略了</p>
<p>如果包含块的高度没有显式指定(即高度由内容决定),并且该元素不是绝对定位,则计算值为 auto，auto 无法进行百分比计算</p>
<p>height:100% 的两种计算，绝对定位的宽高百分比计算是相对于 padding box ，,非绝对定位元素则是相对于 content box 计算的。</p>
<h3 id="min-width-max-width"><a href="#min-width-max-width" class="headerlink" title="min-width/max-width"></a>min-width/max-width</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>height:auto 是必需的,否则,如果原始图片有设定 height, max-width 生效的时候,图片就会被水平压缩。</p>
<p>max-*初始值是 none，min-*初始值是 auto</p>
<p>数值变化无动画，需要设置初始值为 0</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: min-height <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>max-*</code>会覆盖 !important 的 width/height</p>
<p>::selection 选择器匹配被用户选取的选取是部分。即对选中文本的操作。<br>只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。</p>
<h2 id="chapter4-盒尺寸四大家族"><a href="#chapter4-盒尺寸四大家族" class="headerlink" title="chapter4 盒尺寸四大家族"></a>chapter4 盒尺寸四大家族</h2><h3 id="content-与替换元素"><a href="#content-与替换元素" class="headerlink" title="content 与替换元素"></a>content 与替换元素</h3><p><code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;iframe&gt;</code>或者表单元素<code>&lt;textarea&gt;</code>和<code>&lt;input&gt;</code>都是典型的替换元素</p>
<p>vertical-align 在替换元素的基线定义为元素的下边缘</p>
<p><code>&lt;select&gt;</code> 也是替换元素</p>
<p><code>&lt;input&gt;</code>和<code>&lt;button&gt;</code>按钮的区别在钮默认的 white-space 值不一样,前者是 pre,后者是 normal</p>
<p>透明图片占位的替代方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[src]</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Firefox 浏览器,src 缺省的\<img\>不是替换元素,而是一个普通的内联元素,所以使用的就不是替换元素的尺寸规则,而是类似\<span\>的内联元素尺寸规则,宽高会无效。因此可以在 CSS 重置时加上下面一条</span\></img\></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>:before,:after 伪元素是非替换元素，其 content 属性若显示图片则显示的是图片的固有尺寸，不会因 width 和 height 更改</li>
<li>基于伪元素的图片内容生成技术 <a href="https://demo.cssworld.cn/4/1-2.php">链接</a></li>
<li>,使用 content 属性,我们还可以让普通标签元素变成替换元素。一般网站的标志使用的是 h1 标签，可以用 content 改变图片</li>
<li>使用 content 属性生成的文本无法选中，无法复制，像设置了 user-select:none 一样</li>
<li>:empty 伪元素依然会选取 有 content 属性的元素</li>
<li>动态加载效果</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">dot &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">dot<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;...\A..\A.&quot;</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">  <span class="attribute">animation</span>: dot <span class="number">3s</span> infinite step-start both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> dot &#123;</span><br><span class="line">  <span class="number">33%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">2em</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">66%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">1em</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="padding-属性"><a href="#padding-属性" class="headerlink" title="padding 属性"></a>padding 属性</h3><ul>
<li>内联的元素设置垂直 padding 依然有效果，如果父元素设置 overflow: auto，会显示滚动条。id 锚点元素可以设置为内联元素然后设置 padding-top 使得定位位置偏下</li>
<li>实际上,对于非替换元素的内联元素,不仅 padding 不会加入行盒高度的计算,margin 和 border 也都是如此,都是不计算高度,但实际上在内联盒周围发生了渲染。</li>
<li>padding 的百分比数值无论水平竖直都是相对父元素宽度计算的</li>
</ul>
<h3 id="margin-与元素尺寸以及相关布局"><a href="#margin-与元素尺寸以及相关布局" class="headerlink" title="margin 与元素尺寸以及相关布局"></a>margin 与元素尺寸以及相关布局</h3><ul>
<li>只有元素是“充分利用可用空间”状态的时候,margin 才可以改变元素的可视尺寸。因为只要宽度设定,margin 就无法改变元素尺寸。对于水平排列的列表，采用 float 方案，可以在 ul 设置负的 margin 数值，来增加可用宽度。</li>
<li>由于 Firefox 和 Chrome 浏览器对于子元素触发滚动条的方式不一样，滚动容器底部留白使用 padding 是不推荐的，可以接触 margin 的外部尺寸特性来实现底部留白</li>
<li>两栏等高</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.column-box</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-left</span>,</span><br><span class="line"><span class="selector-class">.column-right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">9999px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视觉层多了 9999px 高度可以使用的背景色，当任一栏的高度增加时，父元素总的高度增加</p>
<ul>
<li>margin 的百分比数值无论水平竖直都是相对父元素宽度计算的</li>
<li>margin 合并的 3 种场景<ul>
<li>相邻兄弟元素 margin 合并</li>
<li>父级和第一个/最后一个子元素</li>
<li>空块级元素的 margin 合并</li>
</ul>
</li>
<li>margin 合并的计算规则 “正正取大值”<br>“正负值相加”<br>“负负最负值”</li>
<li>由于 css 中 margin 初始值是 0，实现块级元素右对齐可以使用 margin-left:auto</li>
<li>实现块级元素垂直居中 绝对定位元素的格式化高度即使父元素 height:auto 也是支持的,</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f0f3f9</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#cd0000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>margin 无效<ul>
<li>display 计算值 inline 的非替换元素的垂直 margin 是无效的</li>
<li>表格中的<tr>和<td>元素或者设置 display 计算值是 table-cell 或 table-row 的 margin 是无效的</td></tr></li>
<li>margin 合并的时候,更改 margin 值可能是没有效果的</li>
<li>绝对定位元素非定位方位的 margin 值“无效”</li>
<li>定高容器的子元素的 margin-bottom 或者宽度定死的子元素的 margin-right 的失效</li>
</ul>
</li>
</ul>
<h3 id="border-属性"><a href="#border-属性" class="headerlink" title="border 属性"></a>border 属性</h3><ul>
<li>border-width 不支持半分比</li>
<li>透明边框技巧 使用透明 border 增加点击区域</li>
<li>图形构建 三角形效果</li>
<li>登高布局技术 <a href="http://demo.cssworld.cn/4/4-4.php">http://demo.cssworld.cn/4/4-4.php</a></li>
</ul>
<h2 id="charpter5-内联元素与流"><a href="#charpter5-内联元素与流" class="headerlink" title="charpter5 内联元素与流"></a>charpter5 内联元素与流</h2><p>ex 单位 对应 x-height，可用于图标与文字的对齐</p>
<p>line-height 的默认值是 normal,还支持数值、百分比值以及长度值。</p>
<p>无论内联元素 line-height 如何设置,最终父级元素的高度都是由数值大的<br>那个 line-height 决定的,我称之为“内联元素 line-height 的大值特性”</p>
<p>table-cell 元素设置 vertical-align 垂直对齐的是子元素,但是其作用的并不是子元素,而是 table-cell 元素自身</p>
<p>消除 strut 的影响 图片块状化 设置 lineheight 为 0 fontsize 足够小 图片设置 vertical-align</p>
<p>text-align:justify 文字向两侧对齐，对最后一行无效。</p>
<p>一个 inline-block 元素,如果里面没有内联元素,或者 overflow 不是 visible,<br>则该元素的基线就是其 margin 底边缘;否则其基线就是元素里面最后一行内联元素的基线。</p>
<p>vertical-align 的百分比数值是按照行高计算的</p>
<p>改造“幽灵空白节点”的基线位置可以使用 font-size：0</p>
<p>基于 vertical-align 属性的水平垂直居中弹框 <a href="http://demo.cssworld.cn/5/3-10.php">链接</a></p>
<h2 id="charpter6-流的破坏与保护"><a href="#charpter6-流的破坏与保护" class="headerlink" title="charpter6 流的破坏与保护"></a>charpter6 流的破坏与保护</h2><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul>
<li>float 导致的。float 都有哪些有意思的特性呢?具体如下:<ul>
<li>包裹性;</li>
<li>块状化并格式化上下文;</li>
<li>破坏文档流;</li>
<li>没有任何 margin 合并;</li>
</ul>
</li>
<li>设定了 float 的 inline-table 计算为 table，其他都为 block</li>
<li>clearfix</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bfc"><a href="#bfc" class="headerlink" title="bfc"></a>bfc</h3><ul>
<li>那什么时候会触发 BFC 呢?常见的情况如下:<ul>
<li><code>&lt;html&gt;</code>根元素;</li>
<li>float 的值不为 none;</li>
<li>overflow 的值为 auto、scroll 或 hidden;</li>
<li>display 的值为 table-cell、table-caption 和 inline-block 中的任何一个</li>
<li>position 的值不为 relative 和 static。</li>
</ul>
</li>
<li>尽量避免滚动容器设置 padding-bottom 值</li>
<li>永远不可能实现一个方向溢出剪裁或滚动,另一方向内容溢出显示的效果</li>
</ul>
<h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><ul>
<li>则当子元素内容超出容器宽度高度限制的时候, 剪裁的边界是 border box 的内边缘,而非 padding,box 的内边缘</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ell</span> &#123;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scrollbar"><a href="#scrollbar" class="headerlink" title="scrollbar"></a>scrollbar</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">我们平时开发中只用下面 <span class="number">3</span> 个属性:</span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  /* 血槽宽度 */</span><br><span class="line">  width: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  /* 拖动条 */</span><br><span class="line">  background-color: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  /* 背景槽 */</span><br><span class="line">  background-color: <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="chapter7-css-层叠规则"><a href="#chapter7-css-层叠规则" class="headerlink" title="chapter7 css 层叠规则"></a>chapter7 css 层叠规则</h2><p>!!!z-index 仅可以在定位元素上生效</p>
<ul>
<li>background/border 是装饰属性，浮动和块用作布局，而内联元素作为内容，自然在上面显示</li>
</ul>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠上下文 background/border<br>负 z-index<br>block 块状水平盒子<br>float 浮动盒子<br>inline/inline-block 水平盒子<br>z-index:auto/z-index:0<br>正 index</p>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>页面根元素称为根层叠上下文</li>
<li>z-index 为数值的定位元素是传统层叠上下文</li>
<li><p>css3 属性</p>
<ul>
<li>flex 的布局元素同时 z-index 不为 auto</li>
<li>opacity 不为 1</li>
<li>mix-blend-mode 不是 normal</li>
</ul>
</li>
<li><p>定位元素会层叠在普通元素的上面的原因是元素一旦成为定位元素， 其 z-index 就会自动生效，此时其 z-index 就是默认的 auto，也就是 0 级别。</p>
</li>
<li><p>opacity 动画问题，当 opacity 不为 1 的时候，其具有层叠上下文 z-index:auto，导致其显示于文字之上，解决方法是设置文字的 z-index 为正数值</p>
</li>
</ul>
<h4 id="负-index-应用"><a href="#负-index-应用" class="headerlink" title="负 index 应用"></a>负 index 应用</h4><ul>
<li>可访问性隐藏，可以隐藏元素，只需要层叠上下文内某一个父元素加背景色</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>dart-sass 和 ruby-sass 的区别</title>
    <url>/2019/09/10/CSS/dart-sass%E4%B8%8Enode-sass%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>sass 有多个版本，目前官方主推的是 dart-sass，因为 dart 在处理大型样式表的时候性能更佳。dart-sass 没有支持完整的 sass 语法功能。今天在使用 sass 的颜色运算的时候，发现 webpack 报错，一时摸不着头脑。搜索报错信息，也得不到什么相关信息。后来在 dart-sass 的 github 主页才发现原来 dart-sass 并不支持颜色的通道运算，以下是 dart-sass 与 ruby-sass 的主要不同点。</p>
<ul>
<li>@extend 仅仅接收一个选择器，并且将其作为 selector-extend() 的第二个参数</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  x: y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">  x: y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span><span class="selector-class">.b</span> &#123;</span><br><span class="line">  x: y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.c</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .a.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增加了对于 :has() 伪类的支持</li>
<li>缩进语法 (sass) 更灵活，不再要求全部文档保持同样的缩进</li>
<li>颜色不支持通道运算</li>
<li>无单位的数字不再 == 有单位的数字，map 的 键值比对遵循同样的逻辑</li>
<li>rgba() and hsla() 的百分比单位只支持百分比的形式</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span>&#123; <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.5</span>); &#125;</span><br><span class="line">should fail, but</span><br><span class="line"><span class="selector-class">.card</span>&#123; <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">50%</span>); &#125;</span><br><span class="line">should pass</span><br></pre></td></tr></table></figure>
<ul>
<li>给函数传递多于函数定义的参数数量会导致错误</li>
<li>支持 :maches()</li>
<li>selector-unify() 的结果现在具有对称性</li>
<li>只支持 UTF-8 格式的文档</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>块格式化上下文</title>
    <url>/2019/08/03/CSS/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="一致性-要求和建议"><a href="#一致性-要求和建议" class="headerlink" title="一致性 要求和建议"></a>一致性 要求和建议</h2><p>CSS 渲染模型中不考虑替换元素的内容。</p>
<p>在 CSS 2.1 中，只有替换元素才能具有内在维度。对于没有可靠分辨率信息的光栅图像，必须假设每个图像源像素的大小为 1 像素单位。</p>
<p>HTML 的元素名是大小写不敏感的 但是在 XML 中是大小写敏感的</p>
<p>0 长度单位后的单位是可选的</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>E[foo] 匹配设置了”foo”属性（无论值是什么）的 E 元素</p>
<p>E[foo=”warning”] 匹配所有”foo”属性值恰好是”wraning”的 E 元素</p>
<p>E[foo~=”warning”] 匹配所有”foo”属性值为一列空格分隔的值，且其中之一恰好是”warning”的 E 元素</p>
<p>E[lang|=”en”] 匹配所有”lang”属性值为一列以”en”开头（从左向右）用连字符分隔的值的 E 元素</p>
<p>link 伪类：:link 与:visited</p>
<p>动态伪类： :hover，:active 与:focus</p>
<p>:first-line 伪元素对段落内容的第一个格式化行应用特殊样式(选择器”P:first-line”不会匹配任何真实 HTML 元素。它匹配一个（与 CSS 规范）一致的用户代理将在每个段落的开头插入的伪元素) :first-line 伪元素只能用于块容器元素</p>
<p>:first-letter 伪元素必须选择一个块的第一行的第一个字母</p>
<p>当:first-letter 和:first-line 伪元素被应用在一个具有使用:before 和:after 生成内容的元素，它们应用于元素包括生成的内容在内的首字母或首行</p>
<h2 id="层叠和继承"><a href="#层叠和继承" class="headerlink" title="层叠和继承"></a>层叠和继承</h2><p>为了让用户代理能够避免为不支持的媒体类型检索资源，编写者可以指定带媒体依赖（media-dependent）的@import 规则。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;fineprint.css&quot;</span>) print;</span><br></pre></td></tr></table></figure>
<p>用户样式表，简单来说就是浏览器的使用者自己编写的一份默认样式表，编写者样式表，是网页的编写者编写的样式表，第一次听说这种说法</p>
<h2 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h2><p>Block-level 块级元素 包含以下类型 block list-item table list-item 会生成附加的盒子，相对于主盒子放置</p>
<p>block container box 只包含块级元素或者内联块级元素，</p>
<p>匿名块级盒子 当块级盒子同时包含内联的文本和块级元素时，我们认为这里有一个匿名的盒子包围了这些文本，如果一个块级盒子包含了块级盒子，我们强制让他只包含块级盒子</p>
<p>以@开头的规则（At-rules）需要以分号来结尾</p>
<p>CSS 2.1 用户代理必须忽略在块内或在除@cherset 或@import 规则之外的任何非忽略语句之后发生的任何“@import”规则。一下是非法的，解决方法是将样式的语法放在 At-rules 之后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;subs.css&quot;</span>;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;list.css&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><code>margin-top</code>, <code>margin-bottom</code> 这两个属性对非替换的行内元素无效</p>
<p>两个 margin 是相邻的，当且仅当</p>
<p>都属于流内（in-flow）块级盒，处于同一个块格式化上下文</p>
<ul>
<li>没有行框（line box），空隙，内边距和边框把它们隔开（注意，因此某些 0 高度行框（见 9.4.2）会被忽略）</li>
<li>都属于垂直相邻框边界（vertically-adjacent box edges），即形成下列某一对：<ul>
<li>盒的上边距与其第一个流内（in-flow）孩子的上边距</li>
<li>盒的下边距与其下一个流内紧挨着的兄弟的上边距</li>
<li>最后一个流内孩子的下边距与其 height 计算值为’auto’的父元素的下边距</li>
<li>盒的上边距和下边距，要求该盒没有建立新的块格式化上下文，并且’min-height’计算值为 0，’height’计算值为 0 或’auto’，还没有流内孩子</li>
</ul>
</li>
<li>margin 和 padding 的百分比数值都相对于包含块，border 不能设置百分比数值</li>
</ul>
<h2 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h2><p>以下方式会创建块格式化上下文</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content 或 strict 的元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中</li>
<li>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个 BFC 内的元素。浮动不会影响其它 BFC 中元素的布局，而清除浮动只能清除同一 BFC 中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一 BFC 的块级元素之间。</li>
<li>行内级元素是源文档中那些不会形成新内容块的元素，内容分布于多行 ‘display’属性的下列值能让一个元素变成行内级：’inline’，’inline-table’和’inline-block’。一个 inline-block 的内部会被格式化成一个块盒，而该元素本身会被格式化成一个原子行内级盒</li>
<li>display 为 table 系的元素的 postion:relative 效果是未定义的</li>
<li>盒偏移：’top’，’right’，’bottom’，’left’ 如果元素的’position’属性有一个除’static’外的值，就说它是定位元素（positioned） 百分比数值参照包含块的宽度</li>
<li>如果’left’和’right’都不是’auto’，位置就被过度约束（over-constrained）了，它们（’left’和’right’）其中有一个会被忽略。如果包含块的’direction’属性是’ltr’，那么’left’有效，’right’变成-‘left’（负的’left’）。如果包含块的’direction’属性是’rtl’，那么’right’有效，’left’被忽略</li>
<li>清除浮动的方法 overflow-hidden 创建了一个 BFC，BFC 在计算高度的 也计算浮动元素的高度</li>
<li>注意 ‘direction’属性，给表格列元素指定时，不会被列中的单元格继承，因为在文档树中，列不是单元格的祖先。因此，CSS 无法轻易获知[HTML4]的 11.3.2.1 节中”dir”属性的继承规则</li>
<li>direction 和 unicode-bidi 属性结合处理文本流方向问题（不仅，而且句子从右向左，单词也倒着写）</li>
</ul>
<h2 id="视觉格式化模型细节"><a href="#视觉格式化模型细节" class="headerlink" title="视觉格式化模型细节"></a>视觉格式化模型细节</h2><p>width 应用于除了非替换的行内元素，表格行和行组（row group） 外的所有元素,非替换的行内元素盒的内容宽度是它里面渲染的内容（的内容宽度）负值对于 width 是非法的。</p>
<p>行内非替换（non-replaced）元素 ‘width’属性不适用，其计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’。</p>
<p>行内替换元素 计算值为’auto’的’margin-left’或者’margin-right’对应的应用值为’0’ 如果’height’和’width’计算值都是’auto’，并且该元素还具有固有宽度，那么这个固有宽度就是’width’的应用值。</p>
<p>height 指定一个百分比高度。百分比参照生成盒的包含块的高度。如果包含块的高度没有显式指定（即取决于内容高度），并且该元素不是绝对定位的，则计算值为’auto’。根元素上的百分比高度是相对于初始包含块的 注意：对于那些包含块基于一个块级元素的绝对定位元素，百分比根据这个元素的内边距框（padding box）的高度来计算。这与 CSS1 不同，（CSS1 中）百分比总是根据父级元素的内容框（content box）来计算</p>
<p>line-height 的百分比参考元素自身的字体大小</p>
<p>vertical-align 的百分比是行高</p>
<h2 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h2><p><code>visibility hidden</code> 生成的盒是不可见的（完全透明，什么都不绘制），但仍然会影响布局。而且该元素具有<code>visibility: visible</code> 的后代将是可见的</p>
<h2 id="颜色与背景"><a href="#颜色与背景" class="headerlink" title="颜色与背景"></a>颜色与背景</h2><p>background-attachment 指定了它应该相对视口固定，还是随包含块滚动<br>文本<br>字母与单词间距 <code>letter-spacing’和’word-spacing</code><br><code>text-transform</code>属性 转换单词大小写<br><code>white-space</code>属性 决定如何处置换行符</p>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><p>cursor crosshair 简单十字 move 暗示可移动 text 暗示可选中的文本 wait 暗示正忙<br>outline 当元素具有焦点时，可应用轮廓属性，该属性不占用空间</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记-基础与特性总结</title>
    <url>/2019/03/02/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>Go 在用一个目录下不能有多个 package</li>
<li>Go 中立即返回函数中局部变量的地址也是安全的</li>
<li>Go 中 new 只是一个预定义的函数，不是一个关键字，因此可以将 new 重新定义为别的类型使用，这样将无法使用 new 函数</li>
<li>Go 的早期版本 GOMAXPROCS 可用核数被设置为 1 因此无法真正做到并行 而 go1.6 版本后 GOMAXPROCS 被设置为可用核心数目</li>
<li>Go 中++ —是语句 不是表达式，并且只有后缀形式，因此以下的代码是错的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">5</span></span><br><span class="line">b := a++ <span class="comment">//不能当做表达式使用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Go 不支持隐式类型转换</li>
<li>Go 不支持三元操作符</li>
<li>Go 只有值传递</li>
<li>Go 指针不能进行运算</li>
<li>特殊只写变量_用于忽略值占位</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Go 的基本类型有 Basic types<ul>
<li>bool</li>
<li>string golang 是没有 char 的 string 在 go 中属于基本数据类型 不可变类型</li>
<li>int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr</li>
<li>byte 是 uint8 的别名</li>
<li>rune 是 int32 的别名 代表一个 Unicode 码</li>
<li>float32 float64</li>
<li>complex64 complex128 Go 原生支持复数类型</li>
</ul>
</li>
<li>16 进制的转义形式是\xhh。8 进制的转移形式是\ooo，o 代表一个八进制数字，但是不能超过\377（对应十进制的 255）</li>
<li>无符号数往往只有在位运算或其他特殊的运算场景才会使用</li>
<li>%q 打印带有单引号的字符</li>
<li>函数外的每个语句都必须以关键字开始（<code>var</code>、<code>func</code>、等等），<code>:=</code> 结构不能使用在函数外。</li>
<li>字符串和字节 slice 可以相互转换 一个[]bytes 转换分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组</li>
<li>将一个整数转为字符串有两种方法，一种是用 fmt.Sprintf 返回一个格式化的字符串，另一种方法是用 strconv.Itoa</li>
<li>FormatInt(FormatUint) func(i int64, base int) string 可以用不同的进制格式化数字</li>
<li>strconv.ParseInt 或者 strconv.Atoi 可以用来解析一个字符串为证书，还有用于解析无符号整数的 ParseUint</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过自定义类型来实现枚举类型限制</li>
<li>math.NaN 与任何数都不相等</li>
<li>Go 语言中的许多常量并没有一个明确的基础类型，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可认为至少有 256bit 的运算精度。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Black Color = <span class="literal">iota</span> <span class="comment">//iota的初始值为0</span></span><br><span class="line">    Red</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Color)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := Black</span><br><span class="line">    test(c)</span><br><span class="line">    x:=<span class="number">1</span></span><br><span class="line">    test(x) <span class="comment">//报错</span></span><br><span class="line">    test(<span class="number">1</span>) <span class="comment">// 常量会被自动转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>go 作为编译型语言，不允许重复声明，但有一种特殊情况，即有新的变量被定义，如下</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&quot;hellp&quot;</span></span><br><span class="line">a,b := <span class="string">&quot;hel&quot;</span>,<span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="选择-循环结构"><a href="#选择-循环结构" class="headerlink" title="选择 循环结构"></a>选择 循环结构</h3><ul>
<li>跟 for 一样，<code>if</code> 语句可以在条件之前执行一个简单的语句 由这个语句定义的变量的作用域仅在 if 范围之内。</li>
<li>go range 只有一个接收参数的时候遍历的是 index</li>
<li>go 中 range 会复制对象，k，v 都是从复制的对象中取出的，所以 a[k]和 v 实际是两个变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[k] = <span class="number">4</span></span><br><span class="line">    a[k] = v + <span class="number">1</span></span><br><span class="line">    fmt.Print(a[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br>2345</p>
<ul>
<li>控制流 if 支持初始化语句，定义代码块局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a := <span class="number">5</span>; a &gt; <span class="number">4</span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带有 flag 的双重循环，可以实现准层数确的 continue 和 break</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">L1:</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">3</span>; x++ &#123;</span><br><span class="line">    L2:</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">5</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y &gt; <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> L2</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> L1</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(x, <span class="string">&quot;:&quot;</span>, y, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组-amp-amp-切片"><a href="#数组-amp-amp-切片" class="headerlink" title="数组&amp;&amp;切片"></a>数组&amp;&amp;切片</h3><ul>
<li>make([]T, length, capacity)使用 make 创建切片</li>
<li>切片的 cap 为切片起始位置到底层数组末尾的长度</li>
<li>golan 数组传值默认使用值拷贝，但是会造成性能问题，通常会建议使用 slice 或者数组指针</li>
<li>内置函数 len 和 cap 都能返回数组长度</li>
<li>reslice 是在 slice 的基础上创建新的 slice 对象，新的对象依旧指向原先底层数组</li>
<li>append 是向 slice 尾部添加数据，返回新的 slice 对象，一旦超市原 slice 的 cap 就会重新分配底层数组</li>
<li>copy(dst,src)复制 slice，两个 slice 可以指向不同的数组</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>map 查找，类型断言或者通道接受出现在赋值语句右边不一定是产生两个结果，也可能只产生一个结果</li>
<li>支持== !=等操作符 可用作 map 键类型 相等的判断依据是值相等而非指针相等</li>
<li>结构体可作为 map 的 key 和 value</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]people&#123;</span><br><span class="line">    <span class="number">1</span>: &#123;<span class="string">&quot;user1&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;<span class="string">&quot;user2&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>golang 结构体作为 map 的元素时，不能够直接赋值给结构体的某个字段。因为在 Go 里面所有的都是值 copy，map[“name”]取值的时候实际上是里面的 struct 的值完整的一个 copy，如果允许了这样的操作 list[“name”].XXX 这样的操作，那么实际上你修改的东西没有复制回原来的 struct，所以你可以采用 map[key]*struct 的定义来进行操作，如下所示是可以正确操作的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]*A&#123;<span class="string">&quot;a&quot;</span>: &amp;A&#123;<span class="string">&quot;hello&quot;</span>&#125;&#125;</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>].Name = <span class="string">&quot;Asta&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过双赋值检测某个键存在：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>
<ul>
<li>*[]int 指向数组的指针 []*int 指针数组</li>
<li>make 函数可以用于创建 map，预先给 make 函数一个合理的数量参数，有助于提升性能</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok :=m[<span class="string">&quot;a&quot;</span>];ok&#123;</span><br><span class="line">    <span class="built_in">println</span>(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 range 迭代 map 不能保证迭代次序</li>
</ul>
<h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><ul>
<li>go 结构体以%v 形式打印，直接输出，指针以%v 形式打印，会在结构体{}之前加上一个&amp;</li>
<li>go 结构体的几种初始化方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">float64</span></span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line">rect1 := <span class="built_in">new</span>(Rect)</span><br><span class="line">rect2 := &amp;Rect&#123;&#125;</span><br><span class="line">rect3 := &amp;Rect&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line">rect4 := &amp;Rect&#123;width:<span class="number">100</span>, height:<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这几个变量全部为指向 Rect 结构的指针(指针变量)，因为使用了 new()函数和&amp;操作符。而如果使用方法，那么则表示这个是一个 Rect{}类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := Rect&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内置函数 new 计算类型大小，返回指针，make 会被编译器翻译成具体的创建函数，返回对象</li>
<li>使用 `` 定义不做转义处理的原始字符串，支持跨行</li>
<li>使用 ‘’ 表示 Unicode Code Point 字符常量 如 ‘u6211’ 要修改字符串 可以先转换成 []rune 或者[]byte</li>
</ul>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>命名返回参数可以被同名局部变量遮蔽，此时需要显式返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">//必须显式返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>defer 与 return 执行顺序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(x,y <span class="keyword">int</span>)</span><span class="params">(z <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(z)</span><br><span class="line">    &#125;()</span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">//执行顺序 (z = z + 200) -&gt; call defer -&gt; ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x, y := <span class="number">10</span>,<span class="number">20</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;defer&quot;</span>,i, y)</span><br><span class="line">    &#125;(x)</span><br><span class="line">    x += <span class="number">10</span></span><br><span class="line">    y += <span class="number">100</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;x=&quot;</span>,x,<span class="string">&quot;y=&quot;</span>,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>x=20 y=120<br>defer: 10 120</p>
<ul>
<li>go 学习笔记的一个错误，method value 并不会复制 receiver，而是指向同一个结构体</li>
<li>延迟调用中引发的错误，可以被后续延迟调用捕获，但是只有最后一个错误可以被捕获</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><ul>
<li>空接口没有任何方法签名，这意味着任何类型都实现了空借口，其作用类似面向对象语言中的根对象 object</li>
<li>匿名接口可以用作变量类型，或者结构成员</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul>
<li>go 的错误处理有 panic 和 error 两种方式，当关键流程出现不可修复性错误使用 panic，其他情况使用 error</li>
</ul>
<h3 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h3><ul>
<li>fmt.Sprintf 返回一个格式化的字符串，但是不输出，fmt.Println 直接输出</li>
<li>命令行程序，必须在使用标志参数对应的变量前调用 flag.Parse()，用于更新每个标识变量的值（之前是默认值）</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HandleFunc func(pattern string, handler func(ResponseWriter, *Request)) 如果你的 pattern 是”/“，那么请求的 URL 都是匹配该函数，如果你请求根目录”/“，那么处理函数将会执行两次</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>当只想执行包的 init 函数的时候，在其在 import 的包名设置为 _，这将会使 go 编译器忽略未引用的错误，但是仍然会执行 init 函数</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>decorator</title>
    <url>/2020/10/01/javascript/decorator/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/lyt_angularjs/article/details/101061998">typescript 深入理解装饰器</a></p>
<p>这篇文章总结的很好</p>
<p>装饰器使用一种特殊的 @expression 声明使用，它必须被解析为一个函数，以在运行时调用</p>
<h2 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h2><p>如果你想要更灵活的使用装饰器，可以使用装饰器工厂方式，装饰器工厂返回一个装饰器函数，以在运行时被调用。使用装饰器工厂意味着你可以向装饰器工厂函数传入参数，以生成不同行为的装饰器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params">value: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this is the decorator factory</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this is the decorator</span></span><br><span class="line">    <span class="comment">// do something with &#x27;target&#x27; and &#x27;value&#x27;...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>装饰器调用顺序<br>实例属性的方法参数装饰器，方法装饰器，存取装饰器，属性装饰器<br>静态属性的方法参数装饰器，方法装饰器，存取装饰器，属性装饰器<br>构造函数的参数装饰器<br>类装饰器</p>
<hr>
<blockquote>
<ol>
<li>Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each instance member.</li>
<li>Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.</li>
<li>Parameter Decorators are applied for the constructor.</li>
<li>Class Decorators are applied for the class.</li>
</ol>
</blockquote>
<p>定义（工厂方法）：相同装饰器按从上到下方式执行工厂方法返回装饰器函数前的语句<br>执行：相同装饰器在运行时按照从下到上的顺序执行</p>
<blockquote>
<ol>
<li>The expressions for each decorator are evaluated top-to-bottom.</li>
<li>The results are then called as functions from bottom-to-top.</li>
</ol>
</blockquote>
<h2 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h2><p>允许对一个属性的描述进行检索，在 js 中属性由一个字符串类型的名字和一个属性描述符构成</p>
<blockquote>
<ol>
<li>value 该属性的值</li>
<li>writable 当且仅当属性的值可以被改变时为 true。(仅针对数据属性描述有效)</li>
<li>get 获取该属性的访问器函数（getter）。如果没有访问器， 该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)</li>
<li>set 获取该属性的设置器函数（setter）。 如果没有设置器， 该值为 undefined。(仅针对包含访问器或设置器的属性描述有效)</li>
<li>configurable 当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为 true。</li>
<li>enumerable 当且仅当指定对象的属性可以被枚举出时，为 true。</li>
</ol>
</blockquote>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>被应用于类的构造函数并且可以被用来观察，修改或者替换类的定义。类修饰器不能被用在声明文件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 属性装饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>targetPrototype 构造函数的原型</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>propName 属性名称</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propDecorator1</span>(<span class="params">targetPrototype: any, propName: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;属性装饰器 1:&quot;</span>, targetPrototype, propName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propDecorator2</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;属性装饰器 2 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">targetPrototype: any, propName: string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// targetPrototype[propName]是在原型链上查找实例属性，永远为 undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">&quot;属性装饰器 2:&quot;</span>,</span><br><span class="line">      targetPrototype,</span><br><span class="line">      propName,</span><br><span class="line">      targetPrototype[propName]</span><br><span class="line">    );</span><br><span class="line">    targetPrototype[propName] = <span class="string">&quot;会在原型上面添加该属性并赋值，不是实例对象&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propDecorator3</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;属性装饰器 3 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">targetPrototype: any, propName: string</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;属性装饰器 3:&quot;</span>, targetPrototype, propName);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 方法装饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>targetPrototype 构造函数的原型</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>methodName 方法名称</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>descr 方法的描述</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">methodDecorator1</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法装饰器 1:&quot;</span>, targetPrototype, methodName, descriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> methodDecorator2: any = <span class="function"><span class="keyword">function</span> (<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法装饰器 2 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;方法装饰器 2:&quot;</span>, targetPrototype, methodName, descriptor);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> methodDecorator3: any = <span class="function"><span class="keyword">function</span> (<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法装饰器 3 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;方法装饰器 3:&quot;</span>, targetPrototype, methodName, descriptor);</span><br><span class="line">    <span class="keyword">let</span> originalMethod = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args: any[]</span>) </span>&#123;</span><br><span class="line">      args = args.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (item += <span class="string">&quot; test&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> originalMethod.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 方法参数装饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>targetPrototype 构造函数的原型</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>methodName 方法名称</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param </span>paramIndex 参数在 arguments 中的下标</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDecorator1</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  paramIndex: number</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法参数装饰器 1:&quot;</span>, targetPrototype, methodName, paramIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDecorator2</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法参数装饰器 2 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    paramIndex: number</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;方法参数装饰器 2:&quot;</span>, targetPrototype, methodName, paramIndex);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDecorator3</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;方法参数装饰器 3 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    paramIndex: number</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;方法参数装饰器 3:&quot;</span>, targetPrototype, methodName, paramIndex);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 静态属性修饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">targetPrototype</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">propName</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">staticPropDecorator</span>(<span class="params">param: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;静态属性修饰器 before:&quot;</span>, param);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">targetPrototype: any, propName: string</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">&quot;静态属性修饰器:&quot;</span>,</span><br><span class="line">      targetPrototype,</span><br><span class="line">      propName,</span><br><span class="line">      targetPrototype[propName]</span><br><span class="line">    );</span><br><span class="line">    targetPrototype[propName] = <span class="string">&quot;静态属性初始值被修改了！&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 静态方法修饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">targetPrototype</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">methodName</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">descriptor</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">staticMethodDecorator</span>(<span class="params">param: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;静态方法修饰器 before:&quot;</span>, param);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    targetPrototype: any,</span></span></span><br><span class="line"><span class="params"><span class="function">    methodName: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;静态方法修饰器:&quot;</span>, targetPrototype, methodName, descriptor);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 类装饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">targetClass</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator1</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;类装饰器 1:&quot;</span>, <span class="title">constructor</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator2</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;类装饰器 2 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;类装饰器 2:&quot;</span>, <span class="title">constructor</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator3</span>(<span class="params">params: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;类装饰器 3 before:&quot;</span>, params);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;类装饰器 3:&quot;</span>, <span class="title">constructor</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 存取器装饰器</span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">propertyKey</span></span></span></span><br><span class="line"><span class="comment">- <span class="doctag">@param <span class="variable">PropertyDescriptor</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accessorDecorator</span>(<span class="params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.get = <span class="function">() =&gt;</span> <span class="string">&quot;存取器修饰后的值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@classDecorator1</span><br><span class="line">@classDecorator2(<span class="string">&quot;params2&quot;</span>)</span><br><span class="line">@classDecorator3(<span class="string">&quot;params3&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  @propDecorator1</span><br><span class="line">  @propDecorator2(<span class="string">&quot;param2&quot;</span>)</span><br><span class="line">  @propDecorator3(<span class="string">&quot;param3&quot;</span>)</span><br><span class="line">  public msg: string = <span class="string">&quot;属性初始值&quot;</span>;</span><br><span class="line"></span><br><span class="line">  @staticPropDecorator(<span class="string">&quot;静态属性&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> title: string = <span class="string">&quot;静态属性初始值&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">msg: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.msg = msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @methodDecorator1</span><br><span class="line">  @methodDecorator2(<span class="string">&quot;param2&quot;</span>)</span><br><span class="line">  @methodDecorator3(<span class="string">&quot;param3&quot;</span>)</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    @paramDecorator1 str1: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    @paramDecorator2(<span class="string">&quot;param2&quot;</span>) str2: string,</span></span></span><br><span class="line"><span class="params"><span class="function">    @paramDecorator3(<span class="string">&quot;param3&quot;</span>) str3: string</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;toString:&quot;</span>, str1, str2, str3);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @staticMethodDecorator(<span class="string">&quot;静态方法&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticToString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.title);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @accessorDecorator</span><br><span class="line">  <span class="keyword">get</span> <span class="title">msg1</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.msg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t: any = <span class="keyword">new</span> Test(<span class="string">&quot;this is a msg.&quot;</span>);</span><br><span class="line">t.toString(<span class="string">&quot;ss&quot;</span>, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ff&quot;</span>); <span class="comment">//methodDecorator3 装饰器对该方法进行了重写</span></span><br><span class="line"><span class="built_in">console</span>.log(t.msg, t.proto, t.msg, t.msg1);</span><br><span class="line">Test.staticToString();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性装饰器2 before: param2</span><br><span class="line">属性装饰器3 before: param3</span><br><span class="line">属性装饰器3: Test &#123; toString: [Function] &#125; msg</span><br><span class="line">属性装饰器2: Test &#123; toString: [Function] &#125; msg undefined</span><br><span class="line">属性装饰器1: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; msg</span><br><span class="line">方法装饰器2 before: param2</span><br><span class="line">方法装饰器3 before: param3</span><br><span class="line">方法参数装饰器2 before: param2</span><br><span class="line">方法参数装饰器3 before: param3</span><br><span class="line">方法参数装饰器3: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString 2</span><br><span class="line">方法参数装饰器2: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString 1</span><br><span class="line">方法参数装饰器1: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString 0</span><br><span class="line">方法装饰器3: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString &#123; value: [Function],</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">方法装饰器2: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString &#123; value: [Function],</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">方法装饰器1: Test &#123; toString: [Function], msg: &#x27;会在原型上面添加该属性并赋值，不是实例对象&#x27; &#125; toString &#123; value: [Function],</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">静态属性修饰器 before: 静态属性</span><br><span class="line">静态属性修饰器: function Test(msg) &#123;</span><br><span class="line">        this.msg = &quot;属性初始值&quot;;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125; title 静态属性初始值</span><br><span class="line">静态方法修饰器 before: 静态方法</span><br><span class="line">静态方法修饰器: function Test(msg) &#123;</span><br><span class="line">        this.msg = &quot;属性初始值&quot;;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125; staticToString &#123; value: [Function],</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">类装饰器2 before: params2</span><br><span class="line">类装饰器3 before: params3</span><br><span class="line">类装饰器3: function Test(msg) &#123;</span><br><span class="line">        this.msg = &quot;属性初始值&quot;;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">类装饰器2: function Test(msg) &#123;</span><br><span class="line">        this.msg = &quot;属性初始值&quot;;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">类装饰器1: function Test(msg) &#123;</span><br><span class="line">        this.msg = &quot;属性初始值&quot;;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">toString: ss test dd test ff test</span><br><span class="line">this is a msg. undefined this is a msg. 存取器修饰后的值</span><br><span class="line">静态属性初始值被修改了！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6class的一些迷惑点</title>
    <url>/2020/07/18/javascript/es6class%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%B7%E6%83%91%E7%82%B9/</url>
    <content><![CDATA[<p>今天在看 ts 的装饰器文档的时候，对于类装饰器的一节的官方示例感到非常迷惑</p>
<p>类装饰器接受一个参数，为类的 constructor，你可以观察，修改或者替换它。如果类装饰器返回了一个值，他会用提供的类的构造函数替换类的声明</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]): &#123;&#125; &#125;&gt;(</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">T</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">constructor</span> </span>&#123;</span><br><span class="line">    newProperty = <span class="string">&quot;new property&quot;</span>;</span><br><span class="line">    hello = <span class="string">&quot;override&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最让我迷惑的是 <strong><code>return class extends constructor</code></strong>，为什么可以继承构造函数？要求的返回值是构造函数，但是这里返回的是一个类的声明？</p>
<p>说到底还是自己对于 es6 的 class 理解不够透彻。我又去看了一下阮一峰的 es6 入门的 class 章节，上面说明 ES6 的 class 只是 es5 对象原型写法的语法糖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point; <span class="comment">// &quot;function&quot;</span></span><br><span class="line">Point === Point.prototype.constructor; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>看到这里，感觉到就豁然开朗了。类名变量实际上就是类的构造函数，extends 类名变量 和 extends 构造函数的写法实质上是等价。</p>
<p>es6 类声明语法的返回值也是类的构造函数，所以返回匿名类的语法也可以理解了。</p>
<p>同时因为继承的是构造函数，所以 extends 的可以是一个构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">A.prototype.test = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B().test);</span><br><span class="line"><span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，要获取类的构造函数，应该使用 类名.prototype.constructor，我一直以为是 类名.constructor。类名变量是构造函数，实际上构造函数的 constructor 是函数原型对象的 constructor。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>es6 学习笔记 2</title>
    <url>/2019/08/16/javascript/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li>不存在变量提升</li>
<li>构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。</li>
<li>prototype 对象的 constructor 属性，直接指向“类”的本身，constructor()方法默认返回实例对象（即 this），完全可以指定返回另外一个对象。</li>
</ul>
<h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul>
<li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。与 ES5 一样，类的所有实例共享一个原型对象。</li>
</ul>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，Me 只在 Class 内部有定义。<br>采用 Class 表达式，可以写出立即执行的 Class。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> (<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，person 是一个立即执行的类的实例。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul>
<li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li>
</ul>
<h4 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h4><ul>
<li>实例属性除了定义在 constructor()方法里面的 this 上面，也可以定义在类的最顶层，这时不需要在之前加 this。</li>
</ul>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul>
<li>静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>new 是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令或 Reflect.construct()调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p>子类继承父类时，new.target 会返回子类。</p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>用于获取父类</p>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>有两种用法　当做函数代表父类的构造函数，当做对象，在普通方法中，指向父类的原型对象，在静态方法中指向父类<br>需要注意的是，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="继承链"><a href="#继承链" class="headerlink" title="继承链"></a>继承链</h4><ul>
<li>1 子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</li>
<li>2 子类 prototype 属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的 prototype 属性。</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>rxjs</title>
    <url>/2020/10/01/javascript/rxjs/</url>
    <content><![CDATA[<h2 id="什么是-rxjs"><a href="#什么是-rxjs" class="headerlink" title="什么是 rxjs"></a>什么是 rxjs</h2><p>一组可以用来处理非同步或事件的 js 函数库</p>
<h3 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h3><ul>
<li>ajax/XHR/fetch</li>
<li>Service Worker/ Node Stream</li>
<li>setTimeout /setInterval</li>
<li>Promise</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>DOM 事件 click dbclick keyup</li>
<li>CSS 动画事件</li>
<li>HTML5 Geolocation /websockets/server send event</li>
</ul>
<h3 id="Observable-可观察的物件"><a href="#Observable-可观察的物件" class="headerlink" title="Observable 可观察的物件"></a>Observable 可观察的物件</h3><p>代表一组未来即将产生的事件资料</p>
<h3 id="Observer-观察者物件"><a href="#Observer-观察者物件" class="headerlink" title="Observer 观察者物件"></a>Observer 观察者物件</h3><p>代表一个用来接收观察结果的物件<br>观察者物件包含 3 个含有回调函数的属性 next error complete</p>
<h3 id="Subscription-订阅物件"><a href="#Subscription-订阅物件" class="headerlink" title="Subscription 订阅物件"></a>Subscription 订阅物件</h3><p>代表正在执行 Observable/Observer 的执行个体 可用来取消订阅</p>
<h3 id="Operators-运算子"><a href="#Operators-运算子" class="headerlink" title="Operators 运算子"></a>Operators 运算子</h3><p>必须拥有函数编程所定义的纯函数特性<br>主要用来处理一系列的事件资料合集<br>常见的运算子包含 map，filter，concat，flatMap，switchMap</p>
<h3 id="Subject-主题物件"><a href="#Subject-主题物件" class="headerlink" title="Subject 主题物件"></a>Subject 主题物件</h3><p>如同 EventEmitter 一样，主要用来广播收到的事件资料给多为 Observer (观察者)</p>
<h3 id="schedulers-排程调度器"><a href="#schedulers-排程调度器" class="headerlink" title="schedulers 排程调度器"></a>schedulers 排程调度器</h3><p>用来集中管理与调度多重事件之间的资料，一控制事件并发情况</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>rxjs</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js上卷学习笔记</title>
    <url>/2019/08/05/javascript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E4%B8%8A%E5%8D%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h4 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h4><h5 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h5><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>
<p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是， ReferenceError 是非常重要的异常类型。</p>
<p>相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<p>如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。</p>
<p>js 没有块级作用域，而其他语言 if while for 等块级结构一般都有独立的作用域，js 的函数的作用域是独立的</p>
<p>js 没有块作用域的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>, c); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>
<h5 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h5><p>作用域是根据名称查找变量的一套规则。当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError<br>异常。</p>
<p>ES5 中引入了“严格模式”。在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。</p>
<p>如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。</p>
<h4 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a>第二章 词法作用域</h4><h5 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h5><p>大部分标准语言编译器的第一个工作阶段叫作词法化，词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。</p>
<p>可以大致认为每一个函数都会创建一个新的作用域。</p>
<h5 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h5><p>eval 可以欺骗词法作用域，对词法作用域进行修改，但是严格模式下，eval 有自己的作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str); <span class="comment">// 欺骗！</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo(<span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span>); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>
<p>with 的用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复 &quot;obj&quot;</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 简单的快捷方式</span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  b = <span class="number">4</span>;</span><br><span class="line">  c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p>
<h4 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 函数作用域和块作用域"></a>第三章 函数作用域和块作用域</h4><h5 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h5><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</p>
<p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p>
<h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p>try / catch 的 catch 分句会创建一个块作<br>用域，其中声明的变量仅在 catch 内部有效。</p>
<p>块作用域与内存垃圾收集机制也有相关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">process( someReallyBigData );</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">&quot;my_button&quot;</span> );</span><br><span class="line">btn.addEventListener( <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>click 函数的点击回调不需要 someReallyBigData ，但是由于 click 函数形成了一个覆盖整个作用域的闭包，js 引擎极有可能依然保存着这个结构。</p>
<p>使用块作用域来解决这个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块中定义的内容可以销毁了！</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">&quot;my_button&quot;</span> );</span><br><span class="line">btn.addEventListener( <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<h4 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 提升"></a>第四章 提升</h4><p>var a = 1 实际 js 引擎会当作两部分处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 这一部分在编译阶段进行</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>函数声明和变量声明都会被提升。函数会首先被提升，然后才是变量。</p>
<p>js 不存在函数重载，后声明的函数会覆盖掉前面。</p>
<p>函数表达式不会被提升。</p>
<h4 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a>第五章 作用域闭包</h4><p>for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 1 2 3 4 5</p>
<p>单例模式的实现，可以将函数转换为 IIFE</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(another.join(<span class="string">&quot; ! &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doAnother</span>: doAnother,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="附录-C"><a href="#附录-C" class="headerlink" title="附录 C"></a>附录 C</h5><p>箭头函数的 this 指向的是当前的词法作用域</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h4 id="第一章-关于-this"><a href="#第一章-关于-this" class="headerlink" title="第一章 关于 this"></a>第一章 关于 this</h4><h5 id="为什么要使用-this"><a href="#为什么要使用-this" class="headerlink" title="为什么要使用 this"></a>为什么要使用 this</h5><p>this 提供了一种优雅的方式隐式传递一个对象引用，因此可以将 api 设计的更加简洁和易于复用。</p>
<h5 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h5><p>this 在任何情况下都不指向函数的词法作用域</p>
<p>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 调用位置就在当前正在执行的函数的前一个调用</p>
<p>在浏览器环境下，默认 this 指向 window 对象，在全局作用域下定义的变量和函数也会绑定到 window 下，用 this 可以访问，但是在 node 的环境下就截然不同</p>
<p>独立函数调用采用默认绑定</p>
<p>而对象的方法调用会将 this 隐式绑定到对象上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>不能把 this 和词法作用域的查找混合使用时，这是无法实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>显式绑定 apply 和 call 方法，call 接受参数列表，apply 接受一个参数数组。 Function.prototype.bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>
<p>关于 var self = this 的写法的解释，在内部作用域无法取到外部作用域的 this， 所以要使用一个变量保存起来。</p>
<p>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this 。换句话说，函数内的 this 指向的是 这个新对象</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<h5 id="this-到底是什么"><a href="#this-到底是什么" class="headerlink" title="this 到底是什么"></a>this 到底是什么</h5><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<h4 id="第二章-this-全面解析"><a href="#第二章-this-全面解析" class="headerlink" title="第二章 this 全面解析"></a>第二章 this 全面解析</h4><p>下面这个例子中，this 运行时绑定的是 settimeout（该函数在 settimeout 中调用），使用箭头函数可以绑定为 foo 的词法作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h4><h5 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h5><ul>
<li>如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo = “bar” 赋值操作会出现的三种情况<br><em> 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没<br>有被标记为只读（ writable:false ），那就会直接在 myObject 中添加一个名为 foo 的新<br>属性，它是屏蔽属性。
</em> 如果在 [[Prototype]] 链上层存在 foo ，但是它被标记为只读（ writable:false ），那么<br>无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会<br>抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 * 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会<br>调用这个 setter。 foo 不会被添加到（或者说屏蔽于） myObject ，也不会重新定义 foo 这<br>个 setter。</li>
<li>一些随意的对象属性引用，比如 a1.constructor ，实际上是不被信任的，它们不一<br>定会指向默认的函数引用</li>
</ul>
<h4 id="part6-行为委托"><a href="#part6-行为委托" class="headerlink" title="part6 行为委托"></a>part6 行为委托</h4><p>待完成</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈js作用域</title>
    <url>/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>写这篇文章的契机，是最近有看 react 源码的想法。先是看了这篇文章 <a href="https://juejin.im/post/5afe3735518825426539afce">如何阅读大型前端开源项目的源码</a> 学习了一波姿势，然后开始下载 react 工程鼓捣起来。源码打断点，构建 umd 代码，然后看函数调用栈，执行到这一步，看到了这个页面，发现都是我不熟悉的东西。比如这个 Scope，虽然大体知道是作用域，但是具体是按照什么规则得到的，就不是很清楚了。所以决定先搞清一下 js 的作用域问题。</p>
<p><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/这都啥玩意啊.png" alt="这都啥玩意啊"></p>
<p>js 的作用域，是一个老生常谈的问题了，也是面试常考的内容。以前也通过看 js 高程，你不知道的 js 这些书对此有过据较为深入的学习，刷一些面试题的时候也背了一些“标准答案”，但是时间一长，也忘掉大半了。现在要我真说道说道，大概是说不出个所以然来的。今天搜索相关信息时看到这个博客的一一系列博文讲的真不错 <a href="https://blog.csdn.net/q1056843325/category_9267514.html">https://blog.csdn.net/q1056843325/category_9267514.html</a> ，自己对这一块其实挺欠缺的。纸上得来终觉浅，觉知此事要躬行。这次主要借鉴这位博主的文章内容，借助 Chrome 的开发者工具好好探究一下这个问题。</p>
<h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><h3 id="预编译，变量提升与-let，const"><a href="#预编译，变量提升与-let，const" class="headerlink" title="预编译，变量提升与 let，const"></a>预编译，变量提升与 let，const</h3><p>脚本执行时，js 引擎会做下面三件事。</p>
<ol>
<li>语法分析 引擎检查代码是否包含低级语法错误</li>
<li>预编译 在内存中开辟一些空间，存放变量与函数</li>
<li>解释执行</li>
</ol>
<p>语法分析很简单，就是引擎检查你的代码有没有什么低级的语法错误<br>解释执行顾名思义便是执行代码了<br>预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数</p>
<h4 id="预编译的发生时间"><a href="#预编译的发生时间" class="headerlink" title="预编译的发生时间"></a>预编译的发生时间</h4><p>我之前也以为预编译主要就是做了变量提升这件工作，也就是在脚本解释执行前执行一次。但实际上，在函数执行前都会进行预编译。</p>
<p>先看一下我之前理解的预编译，在 v8 引擎中时怎么做的。</p>
<p><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/预编译1.png" alt="预编译1"></p>
<p>在脚本第一行执行前插入了 debugger 语句，这个时候预编译已经完成。我们看到 Scope 的 Global 作用域（浏览器中的 window 对象）中已经有了以下的属性，符合我们的认知，对于 let 声明的属性，预编译的时候是没有处理的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">b</span>:ƒ b(y),</span><br><span class="line">  <span class="attr">c</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后继续执行，直到执行完了，我们看到 Scope 中多了一个 Script 的标签，其中保存了 aa 的值。这个按我的理解，也可以把它当作全局作用域，与 Global 不同的是，你没法在 window 对象上访问它。</p>
<p><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/预编译2.png" alt="预编译2"></p>
<p>接下来就要执行函数了，在此之前，需要插入一点另外的知识</p>
<p><strong>函数的 <code>[[Scope]]</code> 属性</strong><br>函数是特殊的可执行对象。既然是对象，就可以拥有属性。函数中存在这一个内部属性<code>[[Scope]]</code>（我们不能使用，供 js 引擎使用）函数被创建时，这个内部属性就会包含函数被创建的作用域中对象的集合。这个集合呈链式链接，被称为函数的作用域链。按照我的理解，这和词法作用域是一个概念。这个 <code>[[Scope]]</code>是会随着代码执行动态变化的。在这个例子中，b 函数的 <code>[[Scope]]</code> 一开始是没有 Script 的，在 let 声明执行后，Script 就被添加上了。</p>
<p><strong>函数的执行环境</strong><br>在函数执行时，会创建一个叫做执行环境/执行上下文（execution context）的内部对象，它定义了一个函数执行时的环境。函数每次执行时的执行环境独一无二，多次调用函数就多次创建执行环境，并且函数执行完毕后，执行环境就会被销毁，执行环境有自己的作用域链，用于解析标识符。</p>
<p><code>[[Scope]]</code>和执行期上下文虽然保存的都是作用域链，但不是同一个东西。<code>[[Scope]]</code>属性是函数创建时产生的，会一直存在,而执行上下文在函数执行时产生，函数执行结束便会销毁。</p>
<p><strong>预编译发生在每次函数执行前这个创建执行上下文的过程</strong><br>预编译生成了下图中的 Local 作用域。而 Script 和 Global 作用域，则是函数属性 <code>[[Scope]]</code>的拷贝。<br><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/预编译3.png" alt="预编译3"></p>
<p>这个博主的文章，里面多次提到了 AO 活动对象的概念，实际上这是 ES3 的说法了，还是以开发者工具的展现为准，这样更好理解一点。<br>至此，关于预编译的问题解决。</p>
<p><strong>性能优化</strong></p>
<p>js 引擎查找作用域链是为了解析标识符，变量在执行环境作用域链的位置越深，读写速度就越慢，因此应该多用局部变量（缓存）。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>以前看过这样一个对于闭包的解释。当在一个函数中返回一个函数的时候，这个被返回的时候就可以保有当前函数作用域的变量的引用，这就形成了闭包。</p>
<p>但这样的理解是不充分的。实际上，只要是在函数的作用域内定义了函数，这个被定义的函数就具有闭包作用域。</p>
<p><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/闭包1.png" alt="闭包1"></p>
<p>因此闭包的一大用途，就是实现私有变量。我们知道函数如果返回一个对象，在对它进行构造调用时，结果返回的就是该对象。不过使用这种方式，this 赋值的属性和原型绑定就失效了。</p>
<p><img src="/2020/07/22/javascript/%E5%86%8D%E8%B0%88js%E4%BD%9C%E7%94%A8%E5%9F%9F/闭包2.png" alt="闭包2"></p>
<p>可以看到，当执行以这种方式返回的函数时，可以通过闭包的方式访问执行构造调用时的 Local 作用域。<br>再回想一下之前说过的，函数每次执行时的执行环境独一无二，多次调用函数就多次创建执行环境，和 settimeout 打印的经典问题，顿时感觉豁然开朗了啊。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/04/04/javascript/%E5%AE%9E%E7%8E%B0Promise/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>JS 中 函数是一等公民<br>函数可以作为参数和返回值传递</p>
<h3 id="回调函数的问题"><a href="#回调函数的问题" class="headerlink" title="回调函数的问题"></a>回调函数的问题</h3><ol>
<li>不能 trycatch</li>
<li>不能 return</li>
<li>回调地狱</li>
</ol>
<h3 id="解决回调地狱"><a href="#解决回调地狱" class="headerlink" title="解决回调地狱"></a>解决回调地狱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> eve = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="keyword">let</span> html = &#123;&#125;</span><br><span class="line">eve.on(<span class="string">&quot;ready&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  html[key] = value;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(html).length === <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;ok)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fs.readFile(&quot;</span>./node/template.txt<span class="string">&quot;, &quot;</span>utf8<span class="string">&quot;, function(err, data) &#123;</span></span><br><span class="line"><span class="string">  eve.emit(&quot;</span>ready<span class="string">&quot;, &quot;</span>template<span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">fs.readFile(&quot;</span>./node/data.txt<span class="string">&quot;, &quot;</span>utf8<span class="string">&quot;, function(err, data) &#123;</span></span><br><span class="line"><span class="string">  eve.emit(&quot;</span>ready<span class="string">&quot;, &quot;</span>data<span class="string">&quot;, data);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>哨兵函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  html[key] = value;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(html).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./node/template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;template&quot;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">&quot;./node/data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>进一步优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">length,cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">        html[key] = value</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(html).length === length)&#123;</span><br><span class="line">            cb()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span> = <span class="title">render</span>(<span class="params"><span class="number">2</span>,<span class="keyword">function</span>()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">fs</span>.<span class="title">readFile</span>(<span class="params"><span class="string">&quot;./node/template.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="keyword">function</span>(err, data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  done(<span class="string">&quot;template&quot;</span>, data);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)</span>;</span><br><span class="line">fs.readFile(<span class="string">&quot;./node/data.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>生成器是一个函数，可以用来生成迭代器，生成器函数和普通函数不同，生成器函数中间可以暂停</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> template = <span class="keyword">await</span> readFile(<span class="string">&#x27;./template.txt)</span></span><br><span class="line"><span class="string">    let data = await readFile(&#x27;</span>./data.txt<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    return template + data</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 等同于</span></span><br><span class="line"><span class="string">return read()&#123;</span></span><br><span class="line"><span class="string">    return co(function*()&#123;</span></span><br><span class="line"><span class="string">        let template = yield readFile(&#x27;</span>./template<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">        let data = yield readFile(&#x27;</span>./data<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">        return template + data</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="co"><a href="#co" class="headerlink" title="co"></a>co</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = gen();  <span class="comment">// gen是一个genarator函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        !<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">lastVal</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>&#123;value,done&#125; = it.next(lastVal);</span><br><span class="line">            <span class="keyword">if</span>(done)&#123;</span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                value.then(next,reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-详解"><a href="#Promise-详解" class="headerlink" title="Promise 详解"></a>Promise 详解</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Promise 的生命周期，初始为 pending state，表示异步操作尚未结束。挂起状态可以认为是未决的 unsettled，一旦异步操作结束， Promise 就会被认为是 已决的，进入两种可能状态</p>
<ul>
<li>已完成( fulfilled ): Promise 的异步操作已成功结束;</li>
<li>已拒绝( rejected ): Promise 的异步操作未成功结束,可能是一个错误,或由其他原<br>因导致。<br>then()方法在所有的 Promise 上都存在,并且接受两个参数。第一个参数是 Promise 被完成时要调用的函数,与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是 Promise 被拒绝时要调用的函数,与完成函数相似,拒绝函数会被传入与拒绝相关联的任何附加数据。用这种方式实现 then() 方法的任何对象都被称为一个 thenable 。所有的 Promise 都是<br>thenable ,反之则未必成立。<br>Promis 也具有一个 catch() 方法,其行为等同于只传递拒绝处理函数给 then()。</li>
</ul>
<h3 id="创建未决的-Promise"><a href="#创建未决的-Promise" class="headerlink" title="创建未决的 Promise"></a>创建未决的 Promise</h3><p>使用 Promise 构造函数，Promise 执行器被调用的时候立即运行，当 resolve 或 reject 在执行器内部被调用时，一个作业被添加到作业队列，以决议这个 Promise。这和 setTimeout 或 setInterval 类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Resolved.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出:<br>Promise<br>Hi!<br>Resolved</p>
<p>完成处理函数与拒绝处理函数总是会在执行器的操作结束后被添加到作业队列的尾部，所以 then 中的操作会在最后执行。</p>
<h3 id="创建已决的-Promise"><a href="#创建已决的-Promise" class="headerlink" title="创建已决的 Promise"></a>创建已决的 Promise</h3><p>使用 Promise.resolve 或者 Promise.reject</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>经过我自己的测试，书上内容有误。以下为我自己测试的结果<br>若传入的 Promise 为挂起态,则 Promise.resolve 调用会将该 Promise 原样返回。此后如果决议原 Promise，在 then() 中可以接收到参数，如果拒绝，可以在 catch 中接收到参数。<br>Promise.resove 始终会返回原 Promise，而 Promise.reject 始终会对 Promise 重新包装，包装后的 Promise 处于拒绝态，且其 catch 接受的参数是原先处于拒绝态度的 Promise</p>
<h3 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h3><p>当一个对象拥有一个能接受 resolve 与 reject 参数的 then() 方法,该对象就会被认为是一个非 Promise 的 thenable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise.resolve 方法会将其转换为 Promise，其状态为 Thenable 的 then 方法返回的状态，而 Promise.reject 方法会始终返回一个 reject 态的 Promise，传递给 catch 的参数为原 Thenable 对象</p>
<h3 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h3><p>如果在执行器内部抛出了错误,那么 Promise 的拒绝处理函数就会被调用。</p>
<h2 id="Promise-A-实现"><a href="#Promise-A-实现" class="headerlink" title="Promise A+ 实现"></a>Promise A+ 实现</h2><p>对照 <a href="https://promisesaplus.com/">https://promisesaplus.com/</a>实现就好。</p>
<p>需要注意的规范中的 3.1 注明了 then 中的 onFulfilled and onRejected 需要在本次事件循环结束后方可执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>; <span class="comment">// 缓存 promise 实例</span></span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.value = value;</span><br><span class="line">        self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.value = reason;</span><br><span class="line">        self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 then 的传入处理函数 决定 then 返回的 promise 的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Circular reference&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(vzlue);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res, rej;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    res = resolve;</span><br><span class="line">    rej = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    promise,</span><br><span class="line">    <span class="attr">resolve</span>: res,</span><br><span class="line">    <span class="attr">reject</span>: rej,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写代码</title>
    <url>/2020/12/31/javascript/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><ul>
<li>对于数组和对象做不同的处理</li>
<li>为了解决循环引用的问题，缓存已经访问过的引用类型，如果已经存在，使用缓存值</li>
<li>Object.keys() 遍历的是对象自身的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, cache = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> hit = cache.filter(<span class="function">(<span class="params">c</span>) =&gt;</span> c.original === obj)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (hit) &#123;</span><br><span class="line">    <span class="keyword">return</span> hit.copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> copy = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  cache.push(&#123;</span><br><span class="line">    <span class="attr">original</span>: obj,</span><br><span class="line">    copy,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    copy[key] = deepCopy(obj[key], cache);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line">a.self = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = deepCopy(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul>
<li>异常处理 如果调用者不是函数，抛出异常</li>
<li>如果是构造调用，则返回构造调用的结果</li>
<li>否则，使用 apply 改变函数绑定的 this</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...arg, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, arg.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h3><ul>
<li>异常处理 如果调用者不是函数，抛出异常</li>
<li>在 context 上添加 fn 为当前函数，进行调用得到结果，之后需要删除 context 上的 fn</li>
<li>返回结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.concat.mycall([], [<span class="number">1</span>], [<span class="number">2</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.concat.myapply([], [[<span class="number">1</span>], [<span class="number">2</span>]]));</span><br></pre></td></tr></table></figure>
<h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><ul>
<li>引入 immediate ，immediate 为 true，需要在 timer = null 时执行函数，而 immediate 为 false 时，需要在延时回调函数中执行函数，因此还需要在闭包中保存 context 和 传参信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(fn, wait = 50, immediate = true) &#123;</span><br><span class="line">  let timer, context, args;</span><br><span class="line">  const later = () =&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      timer = null;</span><br><span class="line">      if (!immediate) &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">        context = args = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, wait);</span><br><span class="line"></span><br><span class="line">  return function (...params) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = later();</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        fn.apply(this, params);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context = this;</span><br><span class="line">        args = params;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = later();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dfn = debounce((arg) =&gt; console.log(arg), 500, true);</span><br><span class="line"></span><br><span class="line">dfn(1);</span><br><span class="line">dfn(2);</span><br><span class="line">dfn(3);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  dfn(&quot;aa&quot;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h3 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, gutter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt; gutter) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, params);</span><br><span class="line">      prev = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfn = throttle(<span class="function">(<span class="params">arg</span>) =&gt;</span> <span class="built_in">console</span>.log(arg), <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  tfn(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul>
<li>简单的递归过程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function">(<span class="params">arr</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.isArray(arr)</span><br><span class="line">    ? arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> [...prev, ...flattenDeep(cur)], [])</span><br><span class="line">    : [arr];</span><br></pre></td></tr></table></figure>
<h3 id="实现-new"><a href="#实现-new" class="headerlink" title="实现 new"></a>实现 new</h3><ul>
<li>创建一个对象，其 <code>__proto__</code> 指向构造函数的原型</li>
<li>调用该函数，函数的 this 绑定上一步创建的对象</li>
<li>只要函数的返回值不为对象，返回之前创建的对象，否则返回函数返回的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    res.__proto__ = func.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = func.apply(res, [...arguments].slice(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> ret === <span class="string">&quot;function&quot;</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(New(A));</span><br></pre></td></tr></table></figure>
<h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h3><ul>
<li>沿着原型链循环判断</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化函数接收到足够参数后，就会执行原函数，那么我们如何去确定何时达到足够的参数呢？</p>
<ul>
<li>柯里化函数需要记住你已经给过他的参数，如果没给的话，则默认为一个空数组。</li>
<li>接下来每次调用的时候，需要检查参数是否给够，如果够了，则执行 fn，没有的话则返回一个新的 curry 函数，将现有的参数塞给他。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> a + b + c + d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curry = <span class="function">(<span class="params">fn, ...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = fn.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> combineArgs = [...arr, ...args];</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= combineArgs.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...combineArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> curry(fn, ...combineArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cfn = curry(sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cfn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="eventbus"><a href="#eventbus" class="headerlink" title="eventbus"></a>eventbus</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  all = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers = <span class="built_in">this</span>.all.get(type);</span><br><span class="line">    <span class="keyword">const</span> added = handlers &amp;&amp; handlers.push(handler);</span><br><span class="line">    <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">      <span class="built_in">this</span>.all.set(type, [handler]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers = <span class="built_in">this</span>.all.get(type);</span><br><span class="line">    <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">      handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, evt</span>)</span> &#123;</span><br><span class="line">    (<span class="built_in">this</span>.all.get(type) || []).slice().map(<span class="function">(<span class="params">handler</span>) =&gt;</span> &#123;</span><br><span class="line">      handler(evt);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>傻逼记录</title>
    <url>/2019/04/22/misc/%E5%82%BB%E9%80%BC%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>昨天新买的笔记本到了，折腾了一下午安装 windows 下的软件，尝试了把自己装了 archlinux 移动固态接到笔电上，提示找不到分区 UUID。因为之前一直接在台式用，所以 fstab 上有台式机硬盘的记录，于是换上台式进 arch，把 fstab 里台式的分区都注释了（伏笔）。折腾一番可以进系统了，输完账号密码后，黑屏，是的它黑屏了。<br>开始猜测是显卡驱动的问题，切到字符 tty，安装上 amd 的显卡驱动，重启，依然不行。之后就是漫长的百度与谷歌时间。gnome 桌面是跟着教程安装的，一直以来都是 gdm 启动，所以我对于 X11 的启动过程基本是一窍不通。尝试使用 startx 手动启动，发现 root 可以进入，自己的用户进去就是黑屏。网上的一些方案有删除 gnome 插件，检查 PATH 设置，检查.Xauthority 文件权限，我都尝试了。更令我不能理解的是我换回台式机，它也黑屏了，我只好把自己对系统作的更改一条一条还原。这时看到网上一条评论说 X11 启动会读取用户目录下.x 目录下配置文件，既然 root 能进说明驱动啥的都没问题啊，可能就是配置文件的问题。我看了一下，arch 下没有.x 文件夹，不过在.config 文件下有很多 gnome 的文件夹。我突然想到自己之前因为空间不足，把用户目录下的.cache 和.config 都挂载硬盘的另一个分区上了。cd 到挂载目录，ls 显示目录为空。果然人一傻逼起来是没有救的，看了一下 fstab，果然那个分区的挂载注释掉了。修改之后重启，一切正常，此时已经是夜里 2 点钟。<br>谨以此记录一下我因为傻逼而浪费掉的 4 个小时的人生。<br>另如果想要在移动存储设备上安装 linux，务必参考官方 wiki<a href="https://wiki.archlinux.org/index.php/Installing_Arch_Linux_on_a_USB_key">在 USB 设备上安装 Arch Linux</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>傻逼记录</tag>
      </tags>
  </entry>
  <entry>
    <title>《孤独的人群》读后感</title>
    <url>/2019/02/24/misc/%E5%AD%A4%E7%8B%AC%E7%9A%84%E4%BA%BA%E7%BE%A4%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>《孤独的人群》曾被誉为“当代最有影响的著作之一”，是美国社会学家大卫・理斯曼在同事的协助下完成的一部经典学术著作。本书主旨是讨论美国人社会性格的形成及演变。作者根据传统导向、内在导向和他人导向的社会性格类型对具体的社会阶层――美国中产阶级的性格形成和演变进行了全面阐述。理斯曼认为父母、家庭、学校是性格形成的主要原因，而社会性格最终体现为一定的生活方式，在工作、娱乐、政治生活和子女教育等活动表现出来<br>　　作者着重探讨了 19 世纪美国占主导地位的内在导向性格如何被 20 世纪中叶的他人导向性格所取代的过程，研究了这一取代的原因、过程以及对美国当代主要社会生活领域的影响。</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>全书分为 3 编，主题分别为性格、政治和自主性。在第 1 编的开始，作者首先提出了社会性格的概念。按照作者的解释，这是指个人用来接触世界和他人的一种定型。不同时代的人的社会性格，呈现出有着深深时代烙印的不同特点。<br>　　作者援引谨精神分析心理学家弗洛姆的观点——为了使社会正常地发挥自己的作用，社会成员必须获得某种性格，从而使他们愿意按照社会成员或社会中特定阶层所必须遵奉的行为方式去行动。即人顺从于社会。这种顺从方式可以追溯到人的童年。顺从不能代表整个社会性格，如创造方式是社会性格的重要部分，没有创造性，社会和个人的生活将会枯燥，但是能生存下去，但没有顺从方式，人们则不能生存下去。<br>　　作者运用人口统计学分析了西方自中世纪以来的人口变化，将其分为高度增长潜力时期，过渡时期，早期人口减少时期三个阶段。这三个阶段的社会中的人，分别呈现出传统引导、内部引导和他人引导的性格特点。<br>　　在高度增长潜力时期的社会，尚未受到工业化的影响，社会的生产处于低水平，而人口的出生率和死亡率都处于相当高的水平。这种社会的秩序相对稳定，处在这种社会中的人呈现出传统引导的特点，个人的顺从性易受同龄人和种族的影响，个人学会和理解并且选择持续了几个世纪之久的传统行为模式。在传统引导的社会，社会的分工较为简单，因此不存在无用的人，只要选择从属于社会，就可以在社会中扮演一个角色。阶级的区别是牢固的，农民的孩子未来仍会是农民，而上层贵族家庭的孩子则从小被鼓励建立起某种个性，以符合其贵族身份。从总体上看，整个社会中个人的选择空间是非常有限的。<br>　　而在过渡时期，因为粮食产量提高和医疗卫生条件改善等因素，人口死亡率大大降低，出生率和死亡率不再平衡，这种变化催生出内部引导这一社会性格。内在引导的人不再沿着以往的既定人生轨道，而由其性格类型所引导。这个时期的社会给予成员更多的选择，如金钱，财产，权利，知识，名誉，善行等。这一时期的社会具有流动性，内部引导者可以凭借自身坚毅的品质和努力奋斗实现阶级的跨越，这一时期的工厂主，银行家是这一类人的代表。<br>　　社会发展进入一定阶段后，随着中产阶级队伍逐渐壮大，社会的出生率降低，社会进入了初期人口下降阶段。人们需要工作的时间减少，享乐主义开始盛行，内部引导者所具有的忍耐心和进取心开始不大重要了。这时的新中产阶级呈现出他人引导型的社会性格——他们把同龄人当做个人引导的来源，他人引导所追求的目标随着这种引导的不同而改变，而追求过程本身和密切注意他人态度的过程在一生中保持不变。<br>　　在这三个阶段，父母、老师和同辈人的作用也有很大的不同。<br>　　在传统引导阶段，社会的流动性很低，成人的角色一代一代稳定不变。大多数成人的生活不要求复杂的技巧和文字知识，儿童通过模仿大人可以很快走向社会成熟。性格形成的主要动因是延续维护家庭或团体的存在，儿童所模仿的通常是大人的整个团体而不是自己的父母。<br>　　到了内部引导阶段，阶级不再固定，社会不再要求个人必须顺应社会。父母在孩子儿童时期便向他们灌输和推行理想和目标。这些理想和目标被孩子所内化，当他们长大后被这种力量驱动，追求有限的价值，财富和权利。劳动分工的进步意味着儿童不再以父母当做学习的榜样。父母不能确定孩子未来的生活方式，但是仍有意识地对孩子进行性格训练，常常更严厉地要求孩子。与传统引导相比，父母培养孩子所需要的时间更长了，儿童在社会化的过程中，承受的压力更大了，孩子是被培养大的，而不是爱大的。在内部引导的后期，上学不再是上层阶级孩子的特权。在为了大量培养工业化时代所需要的人才，政府为普通家庭的孩子提供强制的义务的教育，学校开始大批出现。这一阶段教师的主要任务是培养孩子按照中产阶级的标准去说话做事，教师并不关心孩子的情绪生活，认为自己的工作只限于教孩子读书，并且向学生灌输注重学业的评价标准。这种教育对于那些学业失败者有着巨大的损害，因为他们也认同这种标准。内部引导的孩子希望将友谊局限于同社会阶层的人，他们的友谊往往基于共同的爱好，并且只有少数要好的朋友。这一时期，同侪团体的道德约束力，吸引力或威吓力十分衰弱，但是父母甚至老师却可以打破道德权威。<br>　　而在他人引导阶段，社会的流动性仍然存在，但是这种流动性更依赖于他人的看法，以及个人如何操纵他人或为人所操纵，而不大依赖个人是什么和做什么。父母对于如何培养自己的孩子感到不知所措，开始求助于知名人物或者大众媒体，甚至交给孩子本人。他们将焦虑传递给孩子，当孩子表现出乖巧时，会给予赞扬，但其实是在讨好孩子。通过接触大众传播媒介，孩子可以轻易了解父母的行为规范，父母不再具有权威性，其重要性有所降低，而孩子的地位有所提高。在上层中产阶级，父母以克制的讲道理的方式操纵孩子，孩子则以相同的方式回报父母。这一时期的教育更集中于促使孩子全面发展，注重发展人的个性。2-5 岁的孩子也开始进入学校，他们接触的老师是理解他的，陪他玩的大人，这些新老师高度专业化，了解儿童的心理特点，加入学生的各种社会化过程，如消费，友谊，幻想等。环境鼓励孩子的创造性型与个性，但是学校本身仍是扼杀儿童想象力的场所。老师不大关心教学的内容，情绪和精力投入到团体关系领域。当代学校小班级的教师角色，和现代工厂职工关系部的角色极为相似。学校教育他人引导的儿童要准备步入一个重视团体内部关系和道德规范，不太重视产品的社会。这一时期的同侪团体的权利如同美国的陪审团在审判中拥有无上的权利。孩子们常常受到他人意见的摆布，但同侪团体本身常常是充满友谊和忍耐性的。内部引导时期同侪团体中的竞争转变为获取同侪团体赞同，或获取这种赞同的安全感而进行的竞争。同伴成为衡量一切事物的标准。<br>　　大众传媒也是影响社会性格的一个重要因素。传统引导阶段的社会利用家史，神话，传说等形式传播其相对稳定的社会价值观。这些神话与传说中，有些充满了反抗精神。故事里正反两个方面的悖论有助于年轻人综合自己被压抑的冲动，认识到冲动是人类合理的部分，从而不会真正干出有违传统的事。而到了内部引导时期，正式的学校教育机会增加了，更多年轻人学会了读书，出现了对印刷品和书籍的渴求。印刷物帮助他们建立个人与新的社会之间的联系，他们通过印刷物了解道理，所以能够建立一种新的性格结构，使他们能自愿劳动更长时间。印刷物和其他流行的文化形式，通过促使他们回想起父母对自己寄与的愿望以及为他们成功之路提供各种特殊指导，来满足这些开拓者的要求，指导着人们成功之途径。传记和小说促使内部引导社会的孩子试图在想象中离开家庭，步入社会。个人主义的追求在小说和戏剧所描述的各种生活道路上得到了支持和过度支持，独自看书变成了一种孤独的新方式。<br>　　在对待工作和娱乐的态度上，内部引导的人在青年时期往往面临着物质上的贫困，但同时他们有着儿童时期内化了的雄心壮志，这使得他们信奉吃得苦中苦，方为人上人的准则。他们将工作当做生活的主旋律，认为娱乐只是次要的，他们为了自我赞同而奋斗。他人引导的社会，娱乐活动和内部引导时期没有多少变化，但所不同的是人的社会性格发生了变化。新兴的工业革命更看中沟通和操纵人的技术，而把生产工具和技术的改进看作是第二位的。社会上消费主义开始盛行，他人引导者在儿童时期就被培养成为一名消费者。这个时期，个人在工作中若想一枝独秀，光彩夺目，有时是危险的，人们必须学会通过彻底的合作来保持工作上的竞争。而娱乐也不再被看做浪费时间，生产和消费，顺应团体和为个人兴趣服务，以及工作和娱乐之间没有清楚的界限。<br>　　以上是我粗略地总结了书中第一编的内容，在本书的第二编政治部分，作者探讨了这三种人在美国政治生活上的行为与态度。第三编自主性部分，则在更深层次上探究了不同时期人的自主性，包括工作和娱乐的自主性。美国作为一个移民国家，没有封建统治的历史，其政治结构也与我们国家有很大不同，对于这部分内容，我的感触不多。不过从中，我们还是可以了解到不同时期美国人对政治态度的变化，也更可以理解为何现在的美国人都热衷于政治话题——政治已经成为消费文化的一部分。</p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>虽然本书研究的是美国的社会性格变化过程，但是在阅读的过程中，却常常引起我的强烈共鸣。这或许就是社会学的魅力所在，社会学家用一种新的思考方式和分析问题的方法解释周围发生的事情，这往往是普通人所注意不到的。虽然中美所代表的中西方在文化上有巨大差异，但是在社会发展的历程上，却有着很多的共同点。书中所定义的传统引导型社会，对应于欧洲的中世纪，而中国则是经历了长达 2000 年的封建王朝统治时代，这一时期的中国人民，正如书中所刻画的传统引导者的形象，守序而一成不变。十九世纪的美国人，在昭昭天命的引领下，背井离乡，来到那时还是一片荒野的美国西部，希望成就自己的一番事业，他们的社会性格呈现出明显的内部引导的特点。而社会主义建设初期的青年们，尤其是那些参与开发北大荒或是支援新疆建设的青年们，也呈现出相同的性格特点。书中所定义的他人引导的社会性格，随着我国现代化建设的推进，也开始在大城市的市民中出现。<br>　　新中国成立后，我们用半个多世纪走过了西方 200 年走过的现代化道路。在书中所述的美国社会变迁中，我们可以感受到其中的撕裂感。一个在旧的传统社会成长起来的人，往往无法适应新的社会发展。而在新中国的发展历程中，这种撕裂感则更为明显，并且不仅仅是时间轴纵向的，还有横向的。中国拥有广阔的国土和世界上最多的人口，各个地区之间的发展有着巨大的差距。在偏远落后的农村，那里的社会还处于传统引导的阶段，而在小城镇，人们的性格处于内部引导阶段，而在北上广深这样的大都会，一些市民的社会性格已经达到了他人引导的阶段。社会整体的流动性依然存在，生活在农村传统社会的人可以通过努力学习实现阶级跨越，成为大城市的新市民，在他的人生的不同阶段，我们可以看到 3 种不同的性格导向特点。中国的这种快速发展在世界上是前所未有的，但是这种不平衡的发展，所带来的伤痛也是不容忽视的。有时我会觉得，中国的大都市和落后乡村，好似是两个世界。虽然同是炎黄子孙，讲着相同的语言，但是生活在那里的人的人生轨迹却完全不同。大城市中产阶级家庭的孩子，他们的人生早被父母规划好，得益于更好的教育资源，他们往往可以进入更好的高等院校，家庭条件更好的孩子，还可以选择出国留学的道路。农村的孩子，除却少部分人通过高考这条上升通道飞上枝头变成了金凤凰，大部分年轻人辍学来到大城市打工，充当了经济发展的廉价劳动力。他们虽也在大城市生活，但是大城市并不接纳他们，他们结婚生子后，往往因无力承担孩子在大城市的教育而将孩子送回老家，形成了数量庞大的留守一代。父母教育和爱的缺失，让留守一代的成长，尤其是心理健康，成为巨大的社会问题。而他们的人生命运，我想大部分也会和他们的父母一样。没有人会认为这种差异是理所应当的。现代化摧枯拉朽般摧毁了传统的体系，却没有给人以足够的时间去适应，社会整体的发展还未达到较高的水平，阶级却已经开始固化，城市和农村愈发对立，形成不同的文化孤岛。中国社会发展的成果瞩目，但背后隐含的伤痛，可能需要几代人的时间去消解。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>阅读这本书的契机，是一次与一位敬重的朋友的闲谈中，他偶然提及了他对于社会心理学的研究。在此之前，我从未听说过有社会心理学这门学科，但对于心理学，我是一直有着浓厚的兴趣的。于是我下载了几本知名的社会心理学的著作到我的 ipad 中，但是学习生活的繁忙，使得我很少能抽出时间阅读。利用这次假期和开学的这段时间，我阅读了这本足足有 400 页的著作。虽然这是一本学术著作，但阅读的过程却十分有趣。作者举了大量生动有趣的例子，使书中的道理变得浅显易懂。通过阅读这本书，在了解了这么多社会性格的同时，我也更加了解自己。人创造了社会，人无法脱离社会生存，因而要了解社会，最终使自己融入社会，完成自我的社会化，我想这大概是我这个外行涉猎这门科学的意义所在吧。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记录笔记的原因</title>
    <url>/2019/08/16/misc/%E8%AE%B0%E5%BD%95%E7%AC%94%E8%AE%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>其实我向来不是一个学习努力的人，高中时就不喜欢记笔记，高中的时候课堂管理严格，多多少少还是能记录下一些东西。<br>上了大学以后，我更是很少去做课堂笔记了，主要原因是我根本不听 O(∩_∩)O~。不过上了大学以后，我能明显感受到记忆力的衰退。记笔记确实是一种有效的学习方法，在学习技术的时候，我也是有在记录笔记的，一开始是记在本子上的，后来觉得这样很麻烦，开始使用有道云，最后开了这个博客，倒不是希望能被人看到，只是 hexo 用 VSCode 打开真的很好管理和编辑，然后哪天高兴了，随手 push 上去就好。<br>记录笔记其实是一件节省时间的事情，一般我只会记录我在学习的时候遇到的重难点的核心知识，自己已经理解的就不会记录了，之后遇到问题，只要搜索自己的笔记，省去了翻阅原书/文档的时间。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>自述</tag>
      </tags>
  </entry>
  <entry>
    <title>reactRouter学习</title>
    <url>/2020/04/18/react/reactRouter%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>记录一下学习 React 全家桶中的 react-router</p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>通过 hooks 获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; id &#125; = useParams();</span><br></pre></td></tr></table></figure>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><h4 id="route-props"><a href="#route-props" class="headerlink" title="route props"></a>route props</h4><p>所有渲染方式会传递以下三种 props</p>
<ul>
<li>match</li>
<li>location</li>
<li>history<br>会在 props 接受这三个 props</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="component"></a>component</h5><p>当你使用 component 时，router 使用 React.CreateElement 根据传递的 component 创建一个新的 React element 。这意味着如果你提供了一个内联的函数给 component 属性，你会在每次 render 的时候都创建这个组件，这会导致旧组件的 unmount 和 新组建的 mount</p>
<p>其背后的原理在于，react 在比较组件状态以便决定如何更新 dom 节点时，首先要比较组件的 type 和 key。在使用<code>&lt;Route component=&#123;() =&gt; (&lt;Bar idx=&#123;this.state.idx&#125;/&gt;)&#125;/&gt;</code>时，由于调用了 React.createElement，组件的 type 不是 Bar 这个类，而是一个匿名函数。App 组件每次 render 时都生成一个新的匿名函数，导致生成的组件的 type 总是不相同，所以会产生重复的 unmounting 和 mounting。</p>
<h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>允许方便的内联渲染，避免不必要的重新挂载。当路由匹配的时候，这个函数会被调用。函数可以访问所有的 props。</p>
<p><code>&lt;Route component&gt;</code> 优先级高于 <code>&lt;Route render&gt;</code></p>
<h5 id="children"><a href="#children" class="headerlink" title="children"></a>children</h5><p>有时你需要渲染渲染子组件，不管路由是否匹配。这种情况下，可以使用 children 。</p>
<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><p>当为 true，进行精确匹配。</p>
<h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p>当为 true，路径中的 slash 也必须精确匹配。</p>
<h4 id="sensitive"><a href="#sensitive" class="headerlink" title="sensitive"></a>sensitive</h4><p>当为 true，大小写敏感。</p>
<h3 id="history-是可变对象"><a href="#history-是可变对象" class="headerlink" title="history 是可变对象"></a>history 是可变对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// will be true</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = <span class="built_in">this</span>.props.location !== prevProps.location;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// INCORRECT, will *always* be false because history is mutable.</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged =</span><br><span class="line">      <span class="built_in">this</span>.props.history.location !== prevProps.history.location;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Route component=&#123;Comp&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><p>可以是一个路径字符串，也可以是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">pathname</span>:<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>:<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">hash</span>:<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">state</span>:<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以是一个函数，传递当前的 location，返回一个字符串或者对象</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>当为 true，替换历史栈中的当前记录，而不是添加一条记录</p>
<h3 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h3><h4 id="activeClassName"><a href="#activeClassName" class="headerlink" title="activeClassName"></a>activeClassName</h4><p>默认的类名是 active，这将会被连接到 className 属性后</p>
<h4 id="link-exact"><a href="#link-exact" class="headerlink" title="link-exact"></a>link-exact</h4><p>当为 true，activeClassName 和 activeStyle 只会在精确匹配时生效</p>
<h4 id="link-strict"><a href="#link-strict" class="headerlink" title="link-strict"></a>link-strict</h4><p>结合 Route 的 strict，会跳转到严格匹配的路由</p>
<h4 id="isActive"><a href="#isActive" class="headerlink" title="isActive"></a>isActive</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;/events/123&quot;</span></span><br><span class="line">  isActive=&#123;<span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line">    <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Event <span class="number">123</span></span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>reselect源码分析</title>
    <url>/2020/10/01/react/reselect%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="reselect-是什么"><a href="#reselect-是什么" class="headerlink" title="reselect 是什么"></a>reselect 是什么</h2><p>reselect 是 redux 的一个中间件，它用于创建 selectors，根据官方仓库的说明</p>
<blockquote>
<p>Selectors can compute derived data, allowing Redux to store the minimal possible state.<br>选择器可以计算派生数据，从而允许 Redux 存储尽可能少的状态。<br>Selectors are efficient. A selector is not recomputed unless one of its arguments changes.<br>选择器是高效的。除非选择器的一个参数发生更改，否则不会重新计算选择器。<br>Selectors are composable. They can be used as input to other selectors.<br>选择器是可组合。它们可以用作其他选择器的输入。</p>
</blockquote>
<p><a href="https://github.com/reduxjs/reselect">reselect 项目仓库地址</a></p>
<p>reselect 的源码只有 100 行。可以说是非常简单易懂的，但是以我目前的水平，阅读起来还是略有吃力，函数式编程就是绕啊。</p>
<p>尝试了一下将代码拷贝到本地 vscode 中进行调试运行，效果感觉还行，运行了几遍，整个流程就搞懂了。感觉这种小的工具库都可以用这种方式去分析它的源码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createSelector = <span class="comment">/* #__PURE__ */</span> createSelectorCreator(</span><br><span class="line">  defaultMemoize</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这是这个库暴露的主要的 api，它是由 <code>createSelectorCreator</code> 这个工厂函数创建出来的，他接受一个 memoize 函数，同时可以接受选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createSelectorCreator</span>(<span class="params">memoize, ...memoizeOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> recomputations = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> resultFunc = funcs.pop();</span><br><span class="line">    <span class="keyword">const</span> dependencies = getDependencies(funcs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> memoizedResultFunc = memoize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      recomputations++;</span><br><span class="line">      <span class="comment">// apply arguments instead of spreading for performance.</span></span><br><span class="line">      <span class="keyword">return</span> resultFunc.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ...memoizeOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a selector is called with the exact same arguments we don&#x27;t need to traverse our dependencies again.</span></span><br><span class="line">    <span class="keyword">const</span> selector = memoize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> params = [];</span><br><span class="line">      <span class="keyword">const</span> length = dependencies.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// apply arguments instead of spreading and mutate a local list of params for performance.</span></span><br><span class="line">        params.push(dependencies[i].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// apply arguments instead of spreading for performance.</span></span><br><span class="line">      <span class="keyword">return</span> memoizedResultFunc.apply(<span class="literal">null</span>, params);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    selector.resultFunc = resultFunc;</span><br><span class="line">    selector.dependencies = dependencies;</span><br><span class="line">    selector.recomputations = <span class="function">() =&gt;</span> recomputations;</span><br><span class="line">    selector.resetRecomputations = <span class="function">() =&gt;</span> (recomputations = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面默认的 momize 的实现，momize 接受一个函数，通过闭包保存上一次调用该函数的参数和结果，如果参数相等，直接返回结果。<br>默认的实现的相等比较是浅相等，对于对象比较的是它们的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultMemoize</span>(<span class="params">func, equalityCheck = defaultEqualityCheck</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> lastResult = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// we reference arguments instead of spreading them for performance reasons</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">      <span class="comment">// apply arguments instead of spreading for performance.</span></span><br><span class="line">      lastResult = func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> lastResult;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在返回的 selector 和 resultFunc 的计算中，使用到了 momize。这个库做了两次的记忆化处理，第一层是如果 selector 接受的参数相等，那么就不再计算 resultFunc 的依赖。第二层是 resultFunc 的依赖计算完成后，如果与之前计算的结果相同，不会再次执行 resultFunc。</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli学习和debug配置</title>
    <url>/2019/08/31/vue/vue-cli%E5%AD%A6%E4%B9%A0%E5%92%8Cdebug%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h4><p>如果有依赖需要 polyfill，你有几种选择：</p>
<ul>
<li>如果该依赖基于一个目标环境不支持的 ES 版本撰写: 将其添加到 vue.config.js 中的 transpileDependencies 选项。这会为该依赖同时开启语法语法转换和根据使用情况检测 polyfill。</li>
<li>如果该依赖交付了 ES5 代码并显式地列出了需要的 polyfill: 你可以使用 @vue/babel-preset-app 的 polyfills 选项预包含所需要的 polyfill。注意 es6.promise 将被默认包含，因为现在的库依赖 Promise 是非常普遍的。</li>
<li>如果该依赖交付 ES5 代码，但使用了 ES6+ 特性且没有显式地列出需要的 polyfill (例如 Vuetify)：请使用 useBuiltIns: ‘entry’ 然后在入口文件添加 import ‘@babel/polyfill’。这会根据 browserslist 目标导入所有 polyfill，这样你就不用再担心依赖的 polyfill 问题了，但是因为包含了一些没有用到的 polyfill 所以最终的包大小可能会增加。</li>
</ul>
<h4 id="环境变量和模式"><a href="#环境变量和模式" class="headerlink" title="环境变量和模式"></a>环境变量和模式</h4><p>你可以替换你的项目根目录中的下列文件来指定环境变量：<br>.env # 在所有的环境中被载入<br>.env.local # 在所有的环境中被载入，但会被 git 忽略<br>.env.[mode] # 只在指定的模式中被载入<br>.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略</p>
<p>模式是 Vue CLI 项目中一个重要的概念，默认情况下，一个 Vue CLI 项目有三个模式：</p>
<ul>
<li>development 模式用于 vue-cli-service serve</li>
<li>production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e</li>
<li>test 模式用于 vue-cli-service test:unit<br>可以通过传递 —mode 选项参数为命令行覆写默认的模式</li>
<li>“dev-build”: “vue-cli-service build —mode development”</li>
</ul>
<p>只有以 VUE_APP 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们：</p>
<ul>
<li>console.log(process.env.VUE<em>APP_SECRET)<br>除了 VUE_APP</em>* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量：</li>
<li>NODE_ENV - 会是 “development”、”production” 或 “test” 中的一个。具体的值取决于应用运行的模式。</li>
<li>BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。<br>所有解析出来的环境变量都可以在 public/index.html 中以 HTML 插值中介绍的方式使用。</li>
</ul>
<h4 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h4><h5 id="URL-转换规则"><a href="#URL-转换规则" class="headerlink" title="URL 转换规则"></a>URL 转换规则</h5><p>如果 URL 是一个绝对路径 (例如 /images/foo.png)，它将会被保留不变。<br>如果 URL 以 . 开头，它会作为一个相对模块请求被解释且基于你的文件系统中的目录结构进行解析。<br>如果 URL 以 ~ 开头，其后的任何内容都会作为一个模块请求被解析。这意味着你甚至可以引用 Node 模块中的资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~some-npm-package/foo.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 URL 以 @ 开头，它也会作为一个模块请求被解析。它的用处在于 Vue CLI 默认会设置一个指向 projectRoot/src 的别名 @。(仅作用于模版中)</p>
<h3 id="Debug-配置"><a href="#Debug-配置" class="headerlink" title="Debug 配置"></a>Debug 配置</h3><p>效果：在 vscode 中的终端输出 Chrome 的控制台信息，可以在 vscode 中进行断点调试<br>首先需要安装插件 Debugger for Chrome<br>新增 Debug 配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;attach to chrome&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">        <span class="string">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">9222</span>,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://localhost:8080&quot;</span>,</span><br><span class="line">        <span class="string">&quot;webRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/src&quot;</span>,    <span class="comment">// 这个webRoot应该是指webpack打包js文件的目录</span></span><br><span class="line">        <span class="string">&quot;sourceMaps&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;sourceMapPathOverrides&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;webpack:///src/*&quot;</span>: <span class="string">&quot;$&#123;webRoot&#125;/*&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>启动 chrome，附加启动参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">google-chrome-stable  --remote-debugging-port=<span class="number">9222</span></span><br></pre></td></tr></table></figure>
<p>如果使用的是 vue-cli，需要在 vue.config.js 中添加相应配置，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">        <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuecli</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-composition-api源码分析之reactive与ref</title>
    <url>/2021/01/31/vue/vue-composition-api%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Breactive%E4%B8%8Eref/</url>
    <content><![CDATA[<p>分析的是 @vue/composition-api 的代码，版本是 V1.0.0-rc.1<br>vue 的版本是 2.6.12</p>
<p>因为对于 reactive 和 ref 各自的行为和用法尚有不明之处，所以看一下源码，记录一下笔记</p>
<p>文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─scripts</span><br><span class="line">├─src</span><br><span class="line">│  ├─apis</span><br><span class="line">│  ├─component</span><br><span class="line">│  ├─reactivity</span><br><span class="line">│  ├─types</span><br><span class="line">│  └─utils</span><br><span class="line">├─test</span><br><span class="line">│  ├─apis</span><br><span class="line">│  ├─helpers</span><br><span class="line">│  ├─ssr</span><br><span class="line">│  ├─types</span><br><span class="line">│  └─v3</span><br><span class="line">│      ├─reactivity</span><br><span class="line">│      └─runtime-core</span><br><span class="line">└─test-dts</span><br></pre></td></tr></table></figure>
<p>这次主要关注 src/reactivity 和 src/apis 中的代码</p>
<h2 id="reactivity-reactive-ts"><a href="#reactivity-reactive-ts" class="headerlink" title="reactivity/reactive.ts"></a>reactivity/reactive.ts</h2><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 和 ref 相关的方法在 reactivity 目录下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">obj: T</span>): <span class="title">UnwrapRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !(isPlainObject(obj) || isArray(obj)) ||</span><br><span class="line">    isRaw(obj) ||</span><br><span class="line">    !<span class="built_in">Object</span>.isExtensible(obj)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> observed = observe(obj);</span><br><span class="line">  setupAccessControl(observed);</span><br><span class="line">  <span class="keyword">return</span> observed <span class="keyword">as</span> UnwrapRef&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是看 observe 是啥</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Vue = getRegisteredVueOrDefault();</span><br><span class="line">  <span class="keyword">var</span> observed;</span><br><span class="line">  <span class="keyword">if</span> (Vue.observable) &#123;</span><br><span class="line">    observed = Vue.observable(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> vm = defineComponentInstance(Vue, &#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">$$state</span>: obj,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    observed = vm._data.$$state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// in SSR, there is no __ob__. Mock for reactivity check</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(observed, <span class="string">&quot;__ob__&quot;</span>)) &#123;</span><br><span class="line">    def(observed, <span class="string">&quot;__ob__&quot;</span>, mockObserver(observed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Vue 上有 Vue.observe，使用 Vue.observe</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/global-api/index.js</span></span><br><span class="line">Vue.observable = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  observe(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vue.observe 直接返回了传入的对象，也就是说，<strong>reactive 的作用只是给对象增加响应式，返回的值是对象本身</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/observer/index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&quot;__ob__&quot;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果之前没有被 observe 过，使用 new Observer(value) 添加响应式属性，否则什么都不做</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">  def(value, <span class="string">&quot;__ob__&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.observeArray(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到这个构造方法给对象增加了 <code>__ob__</code>属性。</p>
<p>那么看以下代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> b = reactive(a);</span><br><span class="line">reactive(b)</span><br></pre></td></tr></table></figure>
<p>这么使用 reactive 是没问题的，同时 a，b 这里指向的时同一个响应式对象，reactive(b) 这句实际上没有任何作用</p>
<p>显然我们不能重新给 a 或 b 赋值，因为响应性是赋予在 a，b 指向的对象上的</p>
<p>然后看下 setupAccessControl 干了什么</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupAccessControl</span>(<span class="params">target: AnyObject</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isPlainObject(target) ||</span><br><span class="line">    isRaw(target) ||</span><br><span class="line">    <span class="built_in">Array</span>.isArray(target) ||</span><br><span class="line">    isRef(target) ||</span><br><span class="line">    isComponentInstance(target) ||</span><br><span class="line">    accessModifiedSet.has(target)</span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  accessModifiedSet.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(target);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineAccessControl(target, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>accessModifiedSet 是一个 weakmap，如果之前对对象设置过，就不再设置了<br>对对象的每一个属性调用 defineAccessControl</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto unwrapping when access property</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineAccessControl</span>(<span class="params">target: AnyObject, key: <span class="built_in">any</span>, val?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;__ob__&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRaw(target[key])) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: (<span class="function">() =&gt;</span> <span class="built_in">any</span>) | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> setter: (<span class="function">(<span class="params">x: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>) | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  <span class="keyword">if</span> (property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getter = property.get;</span><br><span class="line">    setter = property.set;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (!getter || setter) <span class="comment">/* not only have getter */</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">arguments</span>.length === <span class="number">2</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      val = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 val 是一个对象 递归调用 defineAccessControl</span></span><br><span class="line">  setupAccessControl(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">getterHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(target) : val;</span><br><span class="line">      <span class="comment">// if the key is equal to RefKey, skip the unwrap logic</span></span><br><span class="line">      <span class="keyword">if</span> (key !== RefKey &amp;&amp; isRef(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">setterHandler</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(target) : val;</span><br><span class="line">      <span class="comment">// If the key is equal to RefKey, skip the unwrap logic</span></span><br><span class="line">      <span class="comment">// If and only if &quot;value&quot; is ref and &quot;newVal&quot; is not a ref,</span></span><br><span class="line">      <span class="comment">// the assignment should be proxied to &quot;value&quot; ref.</span></span><br><span class="line">      <span class="keyword">if</span> (key !== RefKey &amp;&amp; isRef(value) &amp;&amp; !isRef(newVal)) &#123;</span><br><span class="line">        value.value = newVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(target, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      setupAccessControl(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupAccessControl</span>(<span class="params">target: AnyObject</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isPlainObject(target) ||</span><br><span class="line">    isRaw(target) ||</span><br><span class="line">    <span class="built_in">Array</span>.isArray(target) ||</span><br><span class="line">    isRef(target) ||</span><br><span class="line">    isComponentInstance(target) ||</span><br><span class="line">    accessModifiedSet.has(target)</span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  accessModifiedSet.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(target);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineAccessControl(target, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 val 是一个对象 递归调用 defineAccessControl<br>defineAccessControl 的作用是 reactive 对象在读写属性时，如果属性是一个 Ref 对象，可以自动拆装箱</p>
<h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowReactive</span>(<span class="params">obj: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !(isPlainObject(obj) || isArray(obj)) ||</span><br><span class="line">    isRaw(obj) ||</span><br><span class="line">    !<span class="built_in">Object</span>.isExtensible(obj)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> observed = observe(&#123;&#125;);</span><br><span class="line">  setupAccessControl(observed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ob = (observed <span class="keyword">as</span> <span class="built_in">any</span>).__ob__;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = obj[key];</span><br><span class="line">    <span class="keyword">let</span> getter: (<span class="function">() =&gt;</span> <span class="built_in">any</span>) | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">let</span> setter: (<span class="function">(<span class="params">x: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>) | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (property) &#123;</span><br><span class="line">      <span class="keyword">if</span> (property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      getter = property.get;</span><br><span class="line">      setter = property.set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(observed, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">getterHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        ob.dep?.depend();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">setterHandler</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        ob.dep?.notify();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> observed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只对响应式对象的属性手动设置响应式并管理依赖收集，如果属性是对象，不会深度添加响应式</p>
<h3 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive"></a>isReactive</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReactive</span>(<span class="params">obj: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Boolean</span>(obj?.__ob__ &amp;&amp; !obj.__ob__?.__raw__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是看对象是否有 <code>__ob__</code> 属性并且没有使用 markRaw 标记</p>
<h3 id="markRaw-amp-amp-isRaw-amp-amp-toRaw"><a href="#markRaw-amp-amp-isRaw-amp-amp-toRaw" class="headerlink" title="markRaw &amp;&amp; isRaw &amp;&amp; toRaw"></a>markRaw &amp;&amp; isRaw &amp;&amp; toRaw</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markRaw</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">obj: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(isPlainObject(obj) || isArray(obj)) || !<span class="built_in">Object</span>.isExtensible(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the vue observable flag at obj</span></span><br><span class="line">  <span class="keyword">const</span> ob = createObserver();</span><br><span class="line">  ob.__raw__ = <span class="literal">true</span>;</span><br><span class="line">  def(obj, <span class="string">&quot;__ob__&quot;</span>, ob);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mark as Raw</span></span><br><span class="line">  rawSet.set(obj, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRaw</span>(<span class="params">obj: <span class="built_in">any</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Boolean</span>(obj?.__ob__ &amp;&amp; obj.__ob__?.__raw__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toRaw</span>&lt;<span class="title">T</span>&gt;(<span class="params">observed: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRaw(observed) || !<span class="built_in">Object</span>.isExtensible(observed)) &#123;</span><br><span class="line">    <span class="keyword">return</span> observed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (observed <span class="keyword">as</span> <span class="built_in">any</span>)?.__ob__?.value || observed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>markRaw 给目标添加了 vue observable 的 flag，这样 Vue 应该就不会再给对象添加响应式属性了<br>rawSet 也是一个 weakmap<br>isRaw 通过 markRaw 设置的 <code>__ob__.__raw__</code> flag 来判断<br>toRaw 是获取响应式对象的原本对象<br>这里 和 vue3 实现的有些差异，通过之前我们知道 reactive 是在原对象上增加响应式属性<code>__ob__</code>的，而 vue3 是通过 proxy 实现的，所以 toRaw 拿到的是被代理的原始对象,而这里这个 toRaw 有点意义不明</p>
<h2 id="reactivity-ref-ts"><a href="#reactivity-ref-ts" class="headerlink" title="reactivity/ref.ts"></a>reactivity/ref.ts</h2><p>这个文件上来就是一堆类型定义，看的我人晕掉了。。</p>
<h3 id="ref-amp-amp-isRef"><a href="#ref-amp-amp-isRef" class="headerlink" title="ref &amp;&amp; isRef"></a>ref &amp;&amp; isRef</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RefKey = <span class="string">&quot;composition-api.refKey&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  raw: T</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">T</span> <span class="title">extends</span> <span class="title">Ref</span> ? <span class="title">T</span> : <span class="title">Ref</span>&lt;<span class="title">UnwrapRef</span>&lt;<span class="title">T</span>&gt;&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>&lt;<span class="title">T</span>&gt;(<span class="params">raw: T</span>): <span class="title">Ref</span>&lt;<span class="title">UnwrapRef</span>&lt;<span class="title">T</span>&gt;&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span>): <span class="title">Ref</span>&lt;<span class="title">T</span> | <span class="title">undefined</span>&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">raw?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRef(raw)) &#123;</span><br><span class="line">    <span class="keyword">return</span> raw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = reactive(&#123; [RefKey]: raw &#125;);</span><br><span class="line">  <span class="keyword">return</span> createRef(&#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> value[RefKey] <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> ((value[RefKey] <span class="keyword">as</span> <span class="built_in">any</span>) = v),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好家伙，上来就是三个重载，然后 <code>Ref&lt;UnwrapRef&lt;T&gt;&gt;</code>这玩意好绕，先不管了<br>如果传入的对象已经是 Ref 对象，直接返回，否则通过 reactive 创建一个响应式对象，然后返回通过 createRef 创建的对象</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">value</span> <span class="title">is</span> <span class="title">Ref</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">instanceof</span> RefImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 instanceOf 判断是否是 Ref 对象是</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">options: RefOption&lt;T&gt;, <span class="keyword">readonly</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r = <span class="keyword">new</span> RefImpl&lt;T&gt;(options);</span><br><span class="line">  <span class="comment">// seal the ref, this could prevent ref from being observed</span></span><br><span class="line">  <span class="comment">// It&#x27;s safe to seal the ref, since we really shouldn&#x27;t extend it.</span></span><br><span class="line">  <span class="comment">// related issues: #79</span></span><br><span class="line">  <span class="keyword">const</span> sealed = <span class="built_in">Object</span>.seal(r);</span><br><span class="line"></span><br><span class="line">  readonlySet.set(sealed, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> sealed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">Ref</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> [_refBrand]!: <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> value!: T;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; get, set &#125;: RefOption&lt;T&gt;</span>)</span> &#123;</span><br><span class="line">    proxy(<span class="built_in">this</span>, <span class="string">&quot;value&quot;</span>, &#123;</span><br><span class="line">      get,</span><br><span class="line">      set,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noopFn,</span><br><span class="line">  <span class="attr">set</span>: noopFn,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  &#123; get, set &#125;: &#123; get?: <span class="built_in">Function</span>; set?: <span class="built_in">Function</span> &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = get || noopFn;</span><br><span class="line">  sharedPropertyDefinition.set = set || noopFn;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRef 就是创建一个 RefImpl 对象，然后代理了其中 value 属性的 getter 和 setter<br>Object.seal 让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象。</p>
<h3 id="toRef-amp-amp-toRefs"><a href="#toRef-amp-amp-toRefs" class="headerlink" title="toRef &amp;&amp; toRefs"></a>toRef &amp;&amp; toRefs</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toRef</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span>: T,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: K</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Ref</span>&lt;<span class="title">T</span>[<span class="title">K</span>]&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v = <span class="built_in">object</span>[key];</span><br><span class="line">  <span class="keyword">if</span> (isRef&lt;T[K]&gt;(v)) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createRef(&#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> <span class="built_in">object</span>[key],</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> (<span class="built_in">object</span>[key] = v),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toRefs</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Data</span> = <span class="title">Data</span>&gt;(<span class="params">obj: T</span>): <span class="title">ToRefs</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(obj)) <span class="keyword">return</span> obj <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret: <span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    ret[key] = toRef(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把对象的某个属性变成 Ref 类型<br>如果已经是 Ref 类型了，直接返回，否则返回通过 createRef 创建的对象<br>需要注意传入的 object 必须是一个响应式对象，否则返回的 Ref 是不具有响应式特性的，因为无法进行依赖收集相关的操作。</p>
<h3 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unref</span>&lt;<span class="title">T</span>&gt;(<span class="params">ref: T</span>): <span class="title">T</span> <span class="title">extends</span> <span class="title">Ref</span>&lt;<span class="title">infer</span> <span class="title">V</span>&gt; ? <span class="title">V</span> : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isRef(ref) ? (ref.value <span class="keyword">as</span> <span class="built_in">any</span>) : ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 Ref 的 value 属性</p>
<h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowRef</span>(<span class="params">raw?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRef(raw)) &#123;</span><br><span class="line">    <span class="keyword">return</span> raw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> value = shallowReactive(&#123; [RefKey]: raw &#125;);</span><br><span class="line">  <span class="keyword">return</span> createRef(&#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> value[RefKey] <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> ((value[RefKey] <span class="keyword">as</span> <span class="built_in">any</span>) = v),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很好理解，这里的 reactive 对象是通过 shallowReactive 创建的</p>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">customRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">factory: CustomRefFactory&lt;T&gt;</span>): <span class="title">Ref</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> version = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> createRef(</span><br><span class="line">    factory(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="built_in">void</span> version.value,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ++version.value;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>允许传入一个工厂方法，属于比较高级的应用，略过</p>
<h3 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">triggerRef</span>(<span class="params">value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isRef(value)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  value.value = value.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue3 文档上的例子，手动触发响应式侦测</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallow = shallowRef(&#123;</span><br><span class="line">  <span class="attr">greet</span>: <span class="string">&quot;Hello, world&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs &quot;Hello, world&quot; once for the first run-through</span></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(shallow.value.greet);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This won&#x27;t trigger the effect because the ref is shallow</span></span><br><span class="line">shallow.value.greet = <span class="string">&quot;Hello, universe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logs &quot;Hello, universe&quot;</span></span><br><span class="line">triggerRef(shallow);</span><br></pre></td></tr></table></figure>
<h3 id="proxyRefs"><a href="#proxyRefs" class="headerlink" title="proxyRefs"></a>proxyRefs</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/reactivity/ref.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxyRefs</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  objectWithRefs: T</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ShallowUnwrapRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isReactive(objectWithRefs)) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWithRefs <span class="keyword">as</span> ShallowUnwrapRef&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> value: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = reactive(&#123; [RefKey]: objectWithRefs &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(objectWithRefs)) &#123;</span><br><span class="line">    proxy(value, key, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(value[key])) &#123;</span><br><span class="line">          <span class="keyword">return</span> value[key].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">v: unknown</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(value[key])) &#123;</span><br><span class="line">          <span class="keyword">return</span> (value[key].value = unref(v));</span><br><span class="line">        &#125;</span><br><span class="line">        value[key] = unref(v);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">as</span> ShallowUnwrapRef&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了一下，是 vue3 的新特性方法，这里也跟进了<br>如果 objectWithRefs 的属性是 Ref 的话，自动进行拆装箱</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-composition-api源码分析之watch与computed</title>
    <url>/2021/01/31/vue/vue-composition-api%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bwatch%E4%B8%8Ecomputed/</url>
    <content><![CDATA[<p>上一篇基本上搞懂了怎么定义响应式对象的，这里研究一下怎么触发侦测的</p>
<h2 id="api-watch-ts"><a href="#api-watch-ts" class="headerlink" title="api/watch.ts"></a>api/watch.ts</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>之前比较疑惑的是，为什么 watch 的第一个参数需要传递一个 getter 或者 ref，而不能传递 <code>reactive.prop</code>。<br>其实这里是调用了 Vue.$watch 方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/apis/watch.ts</span></span><br><span class="line"><span class="keyword">const</span> stop = vm.$watch(getter, callback, &#123;</span><br><span class="line">  <span class="attr">immediate</span>: options.immediate,</span><br><span class="line">  <span class="attr">deep</span>: deep,</span><br><span class="line">  <span class="attr">sync</span>: isSync,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue/src/core/instance/state.js</span></span><br><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue/src/core/observer/watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 省略各种定义</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">    expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cb: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    options?: ?<span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    isRenderWatcher?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略无关内容</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop;</span><br><span class="line">        <span class="comment">// 开发环境下警告 省略</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy ? <span class="literal">undefined</span> : <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 $watch 要求传入 getter 或者一个路径字符串，这个 getter 是要在进行依赖收集的时候被调用的<br>composition-api 中的 watch 使用了 vue2 自身的 watch 机制</p>
<p>至于 watch 的响应式原理，大致如下吧</p>
<p><img src="/2021/01/31/vue/vue-composition-api%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bwatch%E4%B8%8Ecomputed/watch.png" alt="watch"></p>
<p>通过看源码也搞清了一个点，这里的 childObj 和深度监听一点关系都没有</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  customSetter?: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  shallow?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 无关代码 略过</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无关代码 略过</span></span><br></pre></td></tr></table></figure>
<p>它的作用是：每个 Observer 对象都有一个 dep 属性，如果使用 Vue.$set 给对象动态添加新属性，会给赋予该属性响应式并调用该对象的 dep 的 notify</p>
<p>看下面的例子应该就可以完全理解了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">ttt</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.ttt.a = <span class="number">3</span>; <span class="comment">// 无法触发 watch</span></span><br><span class="line">      <span class="built_in">this</span>.$set(<span class="built_in">this</span>.ttt, <span class="string">&quot;a&quot;</span>, <span class="number">5</span>); <span class="comment">// 无法触发 watch 因为不是新属性，直接赋值后就返回了</span></span><br><span class="line">      <span class="built_in">this</span>.$set(<span class="built_in">this</span>.ttt, <span class="string">&quot;b&quot;</span>, <span class="number">5</span>); <span class="comment">// 可以触发，因为 ttt 的 __ob__ 上的 dep 调用了 notify</span></span><br><span class="line">      <span class="built_in">this</span>.ttt = &#123;&#125;; <span class="comment">// 可以触发</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">ttt</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;watch&quot;</span>, val);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么看一下深度监听是怎么实现的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/observer/watcher.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">val: any</span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects);</span><br><span class="line">  seenObjects.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span>(<span class="params">val: any, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!isA &amp;&amp; !isObject(val)) ||</span><br><span class="line">    <span class="built_in">Object</span>.isFrozen(val) ||</span><br><span class="line">    val <span class="keyword">instanceof</span> VNode</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id;</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">    i = keys.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是递归遍历，深度访问对象所有的值，触发对象所有值的依赖收集。<br>还有一个点，Vue.$watch 返回了一个方法用于停止监听，看下它是怎么实现的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/instance/state.js</span></span><br><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cb: any,</span></span></span><br><span class="line"><span class="params"><span class="function">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// vue/src/core/observer/watcher.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// remove self from vm&#x27;s watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(<span class="built_in">this</span>.vm._watchers, <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="built_in">this</span>.deps[i].removeSub(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.active = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue/src/core/observer/dep.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">removeSub</span>(<span class="params">sub: Watcher</span>)</span> &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue/src/shared/util.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove an item from an array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;any&gt;, item: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是把 watcher 从所有依赖的属性的 subs 中删除</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vue/composition-api/src/apis/computed.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  options: Option&lt;T&gt;[<span class="string">&quot;get&quot;</span>] | Option&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ComputedRef</span>&lt;<span class="title">T</span>&gt; | <span class="title">WritableComputedRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = getCurrentInstance()?.proxy;</span><br><span class="line">  <span class="keyword">let</span> get: Option&lt;T&gt;[<span class="string">&quot;get&quot;</span>], <span class="attr">set</span>: Option&lt;T&gt;[<span class="string">&quot;set&quot;</span>] | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    get = options;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    get = options.get;</span><br><span class="line">    set = options.set;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> computedSetter;</span><br><span class="line">  <span class="keyword">let</span> computedGetter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm &amp;&amp; !vm.$isServer) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; Watcher, Dep &#125; = getVueInternalClasses();</span><br><span class="line">    <span class="keyword">let</span> watcher: <span class="built_in">any</span>;</span><br><span class="line">    computedGetter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!watcher) &#123;</span><br><span class="line">        watcher = <span class="keyword">new</span> Watcher(vm, get, noopFn, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    computedSetter = <span class="function">(<span class="params">v: T</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (set) &#123;</span><br><span class="line">        set(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback</span></span><br><span class="line">    <span class="keyword">const</span> computedHost = defineComponentInstance(getVueConstructor(), &#123;</span><br><span class="line">      <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">$$state</span>: &#123;</span><br><span class="line">          get,</span><br><span class="line">          set,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    vm &amp;&amp; vm.$on(<span class="string">&quot;hook:destroyed&quot;</span>, <span class="function">() =&gt;</span> computedHost.$destroy());</span><br><span class="line"></span><br><span class="line">    computedGetter = <span class="function">() =&gt;</span> (computedHost <span class="keyword">as</span> <span class="built_in">any</span>).$$state;</span><br><span class="line">    computedSetter = <span class="function">(<span class="params">v: T</span>) =&gt;</span> &#123;</span><br><span class="line">      (computedHost <span class="keyword">as</span> <span class="built_in">any</span>).$$state = v;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createRef&lt;T&gt;(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">get</span>: computedGetter,</span><br><span class="line">      <span class="attr">set</span>: computedSetter,</span><br><span class="line">    &#125;,</span><br><span class="line">    !set</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 createRef 传递 get 和 set 创建了 Ref。<br>computed 是惰性的（初始时 lazy 和 dirty 都为 true），只有在被求值的时候才会计算，然后进行相应的依赖收集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">  watcher.evaluate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  watcher.depend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有点难理解的，其实是对应了这种情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">t</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.t = <span class="number">10</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.tttt);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">tt</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.t;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">ttt</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.tt;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 computed 依赖于另外的 computed 时，访问 t 的 getter 只会给 tt 的 watcher 添加订阅，但是我们想要的给 tt 和 ttt 的 watcher 都添加订阅<br>Vue 对于 Dep.target 使用了一个栈去管理，而这种嵌套的 computed 的访问也是栈式的。<br>访问 ttt 的 getter 时，执行 ttt 的 watcher 的 evaluate()，ttt 的 watcher 入栈，然后嵌套访问 tt 的 getter，然后执行 tt 的 watcher 的 evaluate()，tt 的 watcher 入栈。tt 这一层的 evaluate() 执行完毕后 tt 的 watcher 退栈，这时 Dep.target 是指向 ttt.watcher 的，执行 watcher.depend()，就可以给 ttt 的 watcher 添加订阅了。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>如何二次封装vue组件</title>
    <url>/2020/12/28/vue/%E5%A6%82%E4%BD%95%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>当我们在项目中需要多处使用开源组件，且开源组件的默认配置行为不满足需求，需要我们手动配置大量选项时，采用二次封装方式应用一些默认选项是一种比较优雅的方式。</p>
<p>二次封装主要是要理解 <code>$props</code>,<code>$attrs</code>,<code>$listeners</code>,<code>inheritAttrs</code> 这几个 api。在二次封装时，我们希望原有 UI 组件的配置项在封装的组件上同样有效，我们只是对一些配置项进行了默认的配置，或者进行一些功能的增强，那问题的关键就是如何实现 prop 和 listeners 的透传。对于 listeners 的透传 我们可以使用 <code>v-on=&quot;$listeners&quot;</code>。对于 prop 的透传，一个可行的方式是将被封装组件的 prop 在，然后通过 <code>v-bind=&quot;$props&quot;</code> 的方式透传 prop，但是这种方式要求我们必须定义与被封装组件相同的 prop，繁琐不说，组件更新增加 prop，我们也要同步添加。</p>
<p>以下是官方文档对于 inheritAttrs 的解释</p>
<blockquote>
<p>默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。</p>
</blockquote>
<p>所有不被认作 props 的 attribute 可以通过 <code>$attrs</code> 访问。通过 <code>$attrs</code> 和 <code>inheritAttrs:false</code> 是一种更好地方式。</p>
<p>对于对部分选项需要设置默认值得需求，vue2.x 中对于 v-bind 绑定的属性和单独设置的属性处理方式是默认单独设置的属性会覆盖 v-bind 绑定的属性。如果需要实现可以手动设置覆盖二次封装默认配置的需求，可以采用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;componentsA v-bind=&quot;propsWithDefault&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  .......</span><br><span class="line">  computed:&#123;</span><br><span class="line">    propsWithDefault()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        defaultOption:&#x27;defaultValue&#x27;</span><br><span class="line">        ...this.$attrs</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如果采用 jsx + render 函数的方式，则可以利用 js 的完全编程能力。<br>可以参考我下面封装的上传组件，在上传类型是图片时，对 accept 设置了默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; message, Upload, Button, Icon, Modal &#125; from &quot;ant-design-vue&quot;;</span><br><span class="line"></span><br><span class="line">function getBase64(file) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const reader = new FileReader();</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">    reader.onload = () =&gt; resolve(reader.result);</span><br><span class="line">    reader.onerror = (error) =&gt; reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于 a-upload 二次封装的文件上传组件。</span><br><span class="line"> * @displayName SeekerUpload</span><br><span class="line"> */</span><br><span class="line">export default &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  name: &quot;SeekerUpload&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;a-upload&quot;: Upload,</span><br><span class="line">    &quot;a-button&quot;: Button,</span><br><span class="line">    &quot;a-icon&quot;: Icon,</span><br><span class="line">    &quot;a-modal&quot;: Modal,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 上传文件类型</span><br><span class="line">     * @values file image</span><br><span class="line">     */</span><br><span class="line">    uploadType: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;file&quot;,</span><br><span class="line">      validator: (x) =&gt; [&quot;file&quot;, &quot;image&quot;].includes(x),</span><br><span class="line">    &#125;,</span><br><span class="line">    /** 上传文件数量限制 */</span><br><span class="line">    number: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">    /** 文件上传按钮说明文字 */</span><br><span class="line">    btnText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;选择文件&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    /** 图片上传说明文字 */</span><br><span class="line">    tipText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;选择图片&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    alwaysShowBtn: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    listType() &#123;</span><br><span class="line">      if (this.uploadType === &quot;image&quot;) &#123;</span><br><span class="line">        return &quot;picture-card&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      return &quot;text&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      previewImage: &quot;&quot;,</span><br><span class="line">      previewVisible: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeUpload() &#123;</span><br><span class="line">      // 使用自定义上传方法</span><br><span class="line">      if (typeof this.$attrs.customRequest === &quot;function&quot;) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCancel() &#123;</span><br><span class="line">      this.previewVisible = false;</span><br><span class="line">    &#125;,</span><br><span class="line">    async handlePreview(file) &#123;</span><br><span class="line">      if (this.uploadType === &quot;file&quot;) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!file.url &amp;&amp; !file.preview) &#123;</span><br><span class="line">        file.preview = await getBase64(file.originFileObj);</span><br><span class="line">      &#125;</span><br><span class="line">      this.previewImage = file.url || file.preview;</span><br><span class="line">      this.previewVisible = true;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange(&#123; fileList &#125;) &#123;</span><br><span class="line">      const files = fileList.slice(-this.number);</span><br><span class="line">      // 对于上传图片 限制图片大小在 800KB 以内</span><br><span class="line">      if (this.uploadType === &quot;image&quot; &amp;&amp; files.length) &#123;</span><br><span class="line">        const limit = 800 * 1024;</span><br><span class="line">        // 判断最后添加的图片</span><br><span class="line">        const latestAdd = files[files.length - 1];</span><br><span class="line">        if (latestAdd.size &gt; limit) &#123;</span><br><span class="line">          message.error(&quot;图片大小超过限制，最大不得超过800KB！&quot;);</span><br><span class="line">          files.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      this.$emit(&quot;update:fileList&quot;, files);</span><br><span class="line">      this.$emit(&quot;listChange&quot;, files);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      listType,</span><br><span class="line">      uploadType,</span><br><span class="line">      $attrs,</span><br><span class="line">      $listeners,</span><br><span class="line">      handleCancel,</span><br><span class="line">      previewVisible,</span><br><span class="line">      previewImage,</span><br><span class="line">      handlePreview,</span><br><span class="line">      handleChange,</span><br><span class="line">      tipText,</span><br><span class="line">      btnText,</span><br><span class="line">      beforeUpload,</span><br><span class="line">      number,</span><br><span class="line">      alwaysShowBtn,</span><br><span class="line">    &#125; = this;</span><br><span class="line">    const bind = &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        accept: uploadType === &quot;image&quot; ? &quot;image/*&quot; : undefined,</span><br><span class="line">        ...$attrs,</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        preview: handlePreview,</span><br><span class="line">        change: handleChange,</span><br><span class="line">        ...$listeners,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const uploadControl =</span><br><span class="line">      uploadType === &quot;image&quot; ? (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;a-icon type=&quot;plus&quot; /&gt;</span><br><span class="line">          &lt;div class=&quot;ant-upload-text&quot;&gt;&#123;tipText&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;a-button disabled=&#123;$attrs.disabled&#125;&gt;</span><br><span class="line">          &lt;a-icon type=&quot;upload&quot; /&gt;</span><br><span class="line">          &#123;btnText&#125;</span><br><span class="line">        &lt;/a-button&gt;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;a-upload list-type=&#123;listType&#125; beforeUpload=&#123;beforeUpload&#125; &#123;...bind&#125;&gt;</span><br><span class="line">          &#123;($attrs.fileList &amp;&amp; $attrs.fileList.length &lt; number) || alwaysShowBtn</span><br><span class="line">            ? uploadControl</span><br><span class="line">            : null&#125;</span><br><span class="line">        &lt;/a-upload&gt;</span><br><span class="line">        &lt;a-modal</span><br><span class="line">          visible=&#123;previewVisible&#125;</span><br><span class="line">          footer=&#123;null&#125;</span><br><span class="line">          width=&#123;600&#125;</span><br><span class="line">          &#123;...&#123; on: &#123; cancel: handleCancel &#125; &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;img alt=&quot;example&quot; style=&quot;width: 100%&quot; src=&#123;previewImage&#125; /&gt;</span><br><span class="line">        &lt;/a-modal&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>看vue-router源码的一些收获</title>
    <url>/2020/10/01/vue/%E7%9C%8Bvue-router%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<h2 id="通配符路由"><a href="#通配符路由" class="headerlink" title="通配符路由"></a>通配符路由</h2><p>阅读源码发现， vue router 源码中对通配符路由做了特殊处理，保证其始终在匹配列表最后，非嵌套的路由必须以 slash 开头 (/)</p>
<h2 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h2><p>path 属性是必须的，component 必须是一个实际的组件</p>
<h2 id="单页面多路由区域"><a href="#单页面多路由区域" class="headerlink" title="单页面多路由区域"></a>单页面多路由区域</h2><p>单页面多路由区域 看了源码才知道有这种操作<br>router-view 可以设置 name，如果不设定会匹配到默认的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/Hi&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>:Hello,</span><br><span class="line">        <span class="attr">left</span>:Hi2,</span><br><span class="line">        <span class="attr">right</span>:Hi1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面里这么写</span></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="跳转原理"><a href="#跳转原理" class="headerlink" title="跳转原理"></a>跳转原理</h2><ol>
<li>首先通过 createRouteMap 创建路由映射,然后使用映射创建 matcher 函数</li>
<li>路由跳转的核心是 transitionTo 方法，该方法首先判定是不是相同的路由，相同的路由不进行跳转<ul>
<li>path，hash，query 相同 path 相同隐含了 param 相同</li>
<li>路由名，hash，query，param 相同</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>试用vue3</title>
    <url>/2020/04/18/vue/%E8%AF%95%E7%94%A8vue3/</url>
    <content><![CDATA[<p>vue 3.0 在 2020.4.17 发布了 beta 版本，可以说离正式发布已经很近了，是时候学习一波新姿势了。</p>
<h2 id="composition-api"><a href="#composition-api" class="headerlink" title="composition api"></a>composition api</h2><p>目前 vue 3.0 的文档还未更新，可以先看这个了解 vue3.0 的新语法 <a href="https://vue-composition-api-rfc.netlify.app/">vue composition api rfc</a><br>以下是我的学习笔记。</p>
<h2 id="核心概念-响应性"><a href="#核心概念-响应性" class="headerlink" title="核心概念 响应性"></a>核心概念 响应性</h2><p>响应性 vue 3.0 最重要的概念，vue3.0 使用 proxy 赋予对象响应性，一个对象具有响应性，那么当这个对象发生改变的时候，就可以自动触发视图的更新或者 watchEffect 中的副作用。</p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。所以可以实现 Object.defineProperty 做不到的对于对象新增属性，数组下标的响应式操作。</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>要使得 proxy 起作用，必须针对 Proxy 实例（上例中是 proxy）进行操作，而不是对目标对象 target 进行操作，如果 handler 没有设置任何拦截，那么等同于直接通向原对象</p>
<p>proxy 实例也可以作为其他对象的原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>proxy 对象是 obj 对象的原型，obj 对象本身没有 time 属性，所以根据原型链，会在 proxy 对象上读取该属性，导致被拦截</p>
<h4 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h4><p>几乎可以支持全部对于对象的访问操作，甚至包括 函数的调用，constructor 的调用，具体看文档就好。</p>
<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>回到 Vue3 这里</p>
<p>setup 相当于原来的 options，可以接受两个参数</p>
<p>第一个参数 props，props 是响应性的，可以触发 watchEffect，注意 props 不能被解构，否则会失去响应性。</p>
<p>第二个参数 context 是一个不可变对象。它有以下属性，其实也都对应了 2.0 中的 api。</p>
<ul>
<li>context.attrs 就是组件上的 attrs，等同于 2.0 的 $attrs</li>
<li>context.slots 可访问通过组件插槽分发的的内容，等同于 2.0 的 $slots</li>
<li>context.emit 就是 2.0 的 $emit 方法</li>
</ul>
<h3 id="setup-中的-this"><a href="#setup-中的-this" class="headerlink" title="setup 中的 this"></a>setup 中的 this</h3><p>setup 中不支持使用 this</p>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>赋予一个对象响应性，相当于 2.0 中的 Vue.observable()</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>接受一个非引用类型值，返回一个 reactive 的可变 ref 对象，对象有一个唯一的 value 属性</p>
<p>当其作为一个 reactive 对象的属性的时候，会自动 unwrap 内部的值，使它的行为与普通属性一致</p>
<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>接受一个 reactive 对象，返回一个对象，对象中每个属性都是 ref 对象<br>这在函数返回一个对象的时候很有用，返回值可以被解构而不失响应特性</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>接受一个 getter 函数，返回一个不可变的响应 ref 对象</p>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>接受一个对象（reactive 或者 朴素的）或者一个 ref，返回一个 readonly 的 proxy</p>
<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>立即运行一个函数，同时动态地跟踪它的依赖项，并在依赖项发生变化时重新运行它。</p>
<p>当 watchEffect 在 setup 中或者生命周期钩子中被调用，watcher 会被链接到组件的生命周期中，会在组件卸载的时候自动停止</p>
<p>watchEffect 也会返回一个 stop 函数，可以手动调用</p>
<h3 id="side-effect"><a href="#side-effect" class="headerlink" title="side effect"></a>side effect</h3><p>有时在 watchEffect 中需要执行一些异步的方法，当再次触发 watchEffect 但是异步操作还未完成，就需要清理一些操作。</p>
<p>watchEffect 可以接受一个 onInvalidate 参数，大致形式如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watchEffect(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value);</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// id has changed or watcher is stopped.</span></span><br><span class="line">    <span class="comment">// invalidate previously pending async operation</span></span><br><span class="line">    token.cancel();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不像是 react 中 useEffect 返回一个函数的原因是，异步函数的返回值是很重要的。<br>vue 会缓冲无效的副作用，当在一个 tick 中多次发生副作用的时候，避免不必要的重复调用。一个组件的 update 钩子也是一个副作用。watchEffect 会在 update 钩子触发前触发。触发的顺序是 beforeUpdate=》watchEffect=》onUpdate</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Vue 3.0 提供了在 setup 中使用的生命周期的钩子函数，与 2.0 的对应关系如下</p>
<p><del>beforeCreate</del> -&gt; use setup()<br><del>created</del> -&gt; use setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p>
<p>新提供了一下供调试使用的钩子<br>onRenderTracked<br>onRenderTriggered</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">onRenderTriggered</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="comment">// inspect which dependency is causing the component to re-render</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="inject-provide"><a href="#inject-provide" class="headerlink" title="inject provide"></a>inject provide</h3><p>在 vue 3.0 中的使用方式如下，provide 可以注入普通数据，也可以注入响应性数据。官方的例子，provide 的键值用的是 Symbol，当然也可以用字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> themeRef = ref(<span class="string">&quot;dark&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    provide(<span class="string">&quot;ThemeSymbol&quot;</span>, themeRef);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>son<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; theme &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; watchEffect, inject, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> theme = inject(<span class="string">&quot;ThemeSymbol&quot;</span>, ref(<span class="string">&quot;light&quot;</span>));</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    watchEffect(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="string">`theme set to: <span class="subst">$&#123;theme.value&#125;</span>`</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      theme,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="template-Refs"><a href="#template-Refs" class="headerlink" title="template Refs"></a>template Refs</h3><p>在 vue2.0 中，通过 ref 可以获取到 虚拟 dom 的引用。3.0 中也是如此，但是有一些变化。<br>下面的代码中，我们在 setep 创建了一个名叫 root 的 ref，同时在 template 的 div 的 ref 属性值为 root，那么在<strong>初次渲染</strong>后，root 的值将会指向虚拟 dom 引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      onMounted(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// the DOM element will be assigned to the ref after initial render</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(root.value) <span class="comment">// &lt;div/&gt;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        root</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Reactivity-Utilities"><a href="#Reactivity-Utilities" class="headerlink" title="Reactivity Utilities"></a>Reactivity Utilities</h2><h3 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h3><p>如果参数是一个 ref，返回它的内部值，否则返回参数自身，实际上是 val = isRef(val) ? val.value : val 的语法糖</p>
<h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>被用来从 reactive 对象中的属性中 创建一个 ref</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = toRef(state, <span class="string">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="toRefs-这个之前已经写了"><a href="#toRefs-这个之前已经写了" class="headerlink" title="toRefs 这个之前已经写了"></a>toRefs 这个之前已经写了</h3><p>将一个 reactive 对象转换为 普通对象，对象的每一个属性都是一个 ref 对象</p>
<h3 id="isRef-amp-amp-isProxy-amp-amp-isReactive-amp-amp-isReadonly"><a href="#isRef-amp-amp-isProxy-amp-amp-isReactive-amp-amp-isReadonly" class="headerlink" title="isRef &amp;&amp; isProxy &amp;&amp; isReactive &amp;&amp; isReadonly"></a>isRef &amp;&amp; isProxy &amp;&amp; isReactive &amp;&amp; isReadonly</h3><p>都是一些顾名思义的方法了，不赘述了</p>
<h2 id="Advanced-Reactivity-APIs"><a href="#Advanced-Reactivity-APIs" class="headerlink" title="Advanced Reactivity APIs"></a>Advanced Reactivity APIs</h2><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>平时应该很少用到，知道有这个方法就好了。允许你定义自己的 ref 方法，可以加入额外的操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebouncedRef</span>(<span class="params">value, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        track();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          value = newValue;</span><br><span class="line">          trigger();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">text</span>: useDebouncedRef(<span class="string">&quot;hello&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a>markRaw</h3><p>标记一个对象，这个对象不会被添加响应性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(foo))); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// also works when nested inside other reactive objects</span></span><br><span class="line"><span class="keyword">const</span> bar = reactive(&#123; foo &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(bar.foo)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h3><p>创建一个只追踪它自己的属性的响应性的对象（不会深度追踪嵌套的对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReactive(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state&#x27;s own properties is reactive</span></span><br><span class="line">state.foo++;</span><br><span class="line"><span class="comment">// ...but does not convert nested objects</span></span><br><span class="line">isReactive(state.nested); <span class="comment">// false</span></span><br><span class="line">state.nested.bar++; <span class="comment">// non-reactive</span></span><br></pre></td></tr></table></figure>
<h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h3><p>创建一个只使得它自己的属性是只读的对象（不会深度使嵌套的对象只读）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReadonly(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">nested</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutating state&#x27;s own properties will fail</span></span><br><span class="line">state.foo++;</span><br><span class="line"><span class="comment">// ...but works on nested objects</span></span><br><span class="line">isReadonly(state.nested); <span class="comment">// false</span></span><br><span class="line">state.nested.bar++; <span class="comment">// works</span></span><br></pre></td></tr></table></figure>
<h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><p>创建一个 ref，只使得它自身的 value 属性是响应性的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = shallowRef(&#123;&#125;);</span><br><span class="line"><span class="comment">// mutating the ref&#x27;s value is reactive</span></span><br><span class="line">foo.value = &#123;&#125;;</span><br><span class="line"><span class="comment">// but the value will not be converted.</span></span><br><span class="line">isReactive(foo.value); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a>toRaw</h3><p>可以获得 reactive 或者 readonly 的原始对象，允许你对原始对象进行操作。这是一个你没有其他方法时的逃生舱，可以被用来临时读取或者写入而不会触发响应追踪。这个方式是不推荐使用的，当你使用这个方法的时候，会给与警告。</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>vue3.0 搭配的是 vuex 的 4.0 版本，大部分 api 的用法都没有改变。</p>
<p>创建 store 的方法现在使用 creatStore。<br>vue3.0 的写法套路如下，首先需要用 useStore() 方法（和 react hooks 一模一样啊）获取 store 对象，如果返回 store 中的属性，用 computed 处理，如果返回 action，需要用 store 手动 dispatch。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Clicked: times, count is &#123;&#123; counter.count &#125;&#125;.</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incrementSync&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; computed, watchEffect, onUpdated, onBeforeUpdate &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> store = useStore();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">counter</span>:computed(<span class="function">() =&gt;</span> store.state.counter)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">increment</span>: <span class="function">() =&gt;</span> store.dispatch(<span class="string">&quot;counter/increment&quot;</span>),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">decrement</span>: <span class="function">() =&gt;</span> store.dispatch(<span class="string">&quot;counter/decrement&quot;</span>),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">incrementSync</span>: <span class="function">() =&gt;</span> store.dispatch(<span class="string">&quot;counter/incrementSync&quot;</span>),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>mapState，mapGetters，mapActions 这些辅助方法在 Vue3.0 写法下是无法使用的。因为 setup 中无法使用 this ，而这些辅助方法在 2.0 中是需要访问 this.$store 的。当然我们完全可以用 2.0 的写法用这些辅助方法。</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>主要的破坏性更新是</p>
<ul>
<li>使用历史模式 从 mode:’history’ 改为 history: createWebHistory()</li>
<li>捕获所有路由的写法现在应该是 /:catchAll(.*)</li>
<li>router.match 和 router.resolve 方法被合并到 router.resolve</li>
<li>router.getMathedComponents 这个方法被移除了<br>可以通过以下代码实现这个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.currentRoute.value.matched</span><br><span class="line">  .map(<span class="function">(<span class="params">record</span>) =&gt;</span> <span class="built_in">Object</span>.values(record.components))</span><br><span class="line">  .flat();</span><br></pre></td></tr></table></figure>
<p>目前合并了四个 rfc</p>
<p>动态路由 实现了以下 API</p>
<ul>
<li>router.addRoute(route: RouteRecord) Add a new route</li>
<li>router.removeRoute(name: string | symbol) Remove an existing route</li>
<li>router.hasRoute(name: string | symbol): boolean Check if a route exists</li>
<li>router.getRoutes(): RouteRecord[] Get the current list of routes</li>
</ul>
<p>移除了 router-link 的 tag 和 event prop，不再自动给内部 a 元素添加点击事件，增加了 scoped-slot api</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>esbuild简介</title>
    <url>/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里说明一下打包工具的概念，打包工具是用来将多个 js 文件和他们的依赖组合成一个或者多个 bundle 文件的工具。前端知名的打包工具有 webpack，rollup，gulp 等。</p>
<p><img src="/2021/07/19/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/esbuild%E7%AE%80%E4%BB%8B/bundle.png" alt="打包过程"></p>
<p>我们的前端项目一般都会使用 webpack 进行构建。随着项目规模不断增加，引入的依赖逐渐增多，我们开启开发服务器和进行生产构建的时间会不断增加。目前我的公司的项目开启开发服务器需要 1 分钟左右，进行生产构建需要 5 分钟以上，而这已经是进行微前端拆分后的结果，如果还是单体巨石应用的结构，那画面太美不敢想象。webpack 的速度实在是太慢，esbuild 就是为了解决这一痛点而被创造出来的。</p>
<p>esbuild 是使用 go 语言编写的一个新一代的 JavaScript 打包工具，它的作者是 figma 的 CTO Evan Wallace。得益于 go 语言编译型语言的优点，打包速度可以达到 webpack 的几十倍。一些知名的热门项目已经内置了 esbuild，比如 vite，snowpack。今天我们就跟随 esbuild 的官方文档，学习一下 esbuild 的相关知识。</p>
<p>下文的主要内容包括</p>
<ul>
<li>为什么 esbuild 这么快</li>
<li>上手使用 esbuild</li>
<li>esbuild plugin api 简介</li>
<li>esbuild 目前的局限</li>
</ul>
<h3 id="esbuild-为什么那么快"><a href="#esbuild-为什么那么快" class="headerlink" title="esbuild 为什么那么快"></a>esbuild 为什么那么快</h3><p>在文档中作者给出了 esbuild 与其他打包工具对 three.js 进行的打包基准测试结果，我们可以看到 esbuild 的速度惊人的快，最高是 rollup 和 webpack 的百倍。<br>| Bundler | Time | Relative slowdown |Absolute speed| Output size|<br>|—-|—-|—-|—-|—-|<br>|esbuild |0.37s |1x |1479.6 kloc/s |5.81mb|<br>|esbuild (1 thread) |1.61s |4x |340.0 kloc/s |5.81mb|<br>|rollup + terser |37.79s |102x |14.5 kloc/s |5.81mb|<br>|parcel 2 |39.28s |106x |13.9 kloc/s |5.87mb|<br>|webpack 4 |43.07s |116x |12.7 kloc/s |5.97mb|<br>|webpack 5 |55.25s |149x |9.9 kloc/s |5.84mb|</p>
<p>这里大家一定非常好奇 esbuild 是如何做到如此之快的，在官方文档的 FAQ 中给出了以下解释:</p>
<h4 id="go-语言编写"><a href="#go-语言编写" class="headerlink" title="go 语言编写"></a>go 语言编写</h4><p>go 是为了<strong>并行</strong>而被设计出来的<strong>编译型语言</strong>，速度相比使用<strong>脚本语言</strong> JavaScript 编写的同类工具有很大的优势。<br>尽管 v8 引擎提供了 JIT 的特性，很大程度上提升了 Javascript 的性能，但是对于命令行程序，它依然太慢了。 每次运行打包器时，JavaScript VM 都会在没有任何优化的情况下运行打包程序的代码。在 esbuild 忙于解析 JavaScript 时，node 还在忙于解析打包程序的 JavaScript。<br>在线程间通信方面， Go 在线程之间可以共享内存，而 JavaScript 必须在线程之间传递序列化数据，这一点显然共享内存的效率更高。<br>Go 和 JavaScript 都有并行的垃圾收集器，但是 Go 的堆在所有线程之间共享，而对于 JavaScript, 每个 JavaScript 线程中都有一个单独的堆。</p>
<h4 id="充分使用并行"><a href="#充分使用并行" class="headerlink" title="充分使用并行"></a>充分使用并行</h4><p>esbuild 内部的算法专门被设计为可以最大程度利用 cpu 资源的形式。esbuild 的工作流程可大致分为三个阶段，解析，链接和代码生成。其中作为主要工作的解析代码和代码生成全部并行方式处理。因为所有的线程共享了内存，不同入口文件的打包工作可以使用相同的导入的 Javascript 模块数据。<br>这里需要额外说明一下，Go 语言是一门为并发编程设计的语言，它原生支持协程。</p>
<h4 id="代码完全自己编写"><a href="#代码完全自己编写" class="headerlink" title="代码完全自己编写"></a>代码完全自己编写</h4><p>esbuild 不使用第三方库，自己来编写实现 js/ts 的编译相关模块，带来了很多细节上的性能优化。</p>
<h4 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h4><p>理想情况下，编译器以近乎 O(n) 的复杂度处理输入，如果需要处理大量数据，内存访问速度可能会严重影响性能。如果你能更少地遍历代码，编译器的运行速度就会更快。<br>esbuild 只会访问 js/ts 的 AST 三次。<br>第一次是对于词法解析，作用域设置，以及声明符号<br>第二次是绑定符号，压缩语法， JSX/TS 转 JS，ESNext 转 ES2015<br>第三次是压缩标识符，压缩空白字符，生成代码与生成 sourcemap<br>esbuild 最大程度重用了 AST 数据，当它们还在 cpu 的缓存中时。</p>
<p>综合以上的几个方面，使得 esbuild 的速度比起其他打包工具高出一个数量级。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>esbuild 提供了三种方式来使用 esbuild，分别是 命令行，npm 包 和 go 包<br>esbuild 提供了两种调用类型主要 API 类型，Transform API 和 Build API<br>下面分别简单介绍一下它们的使用</p>
<h4 id="npm-包方式"><a href="#npm-包方式" class="headerlink" title="npm 包方式"></a>npm 包方式</h4><p>首先安装 esbuild</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install esbuild</span><br></pre></td></tr></table></figure>
<p>可以看到 esbuild 的 npm 包结构如下:</p>
<p>│ esbuild.exe<br>│ install.js<br>│ package.json<br>│ README.md<br>│<br>├─bin<br>│ esbuild<br>│<br>├─lib<br>│ main.d.ts<br>│ main.js</p>
<p>esbuild 是一个 go 语言编译的可执行程序， 包在安装时会根据所在平台安装对应的可执行程序，windows 系统下就是 esbuild.exe 。lib 下 main.js 提供了对于 esbuild 可执行程序调用的封装。</p>
<p>以下是官网的示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).writeFileSync(<span class="string">&quot;in.ts&quot;</span>, <span class="string">&quot;let x: number = 1&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>).buildSync(&#123;</span><br><span class="line">  <span class="attr">entryPoints</span>: [<span class="string">&quot;in.ts&quot;</span>],</span><br><span class="line">  <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFileSync(<span class="string">&quot;out.js&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h4><p>使用 npm 安装 esbuild 后，我们也可以通过命令行的方式调用 esbuild。esbuild 在 package.json 中定义了 bin 的配置，该文件是一个 node 脚本，用以子进程方式调用 esbuild 可执行文件。</p>
<p>根据 npm 的约定，当 package.json 中定义了 bin 选项时，包安装时会自动将脚本软链接到 node_modules/.bin 目录下。当使用 npm 执行定义在 scripts 中的命令时，会自动将 node_modules/.bin 目录下添加到 PATH 中。通过这种方式就可以以命令行方式调用 esbuild。</p>
<h4 id="Transform-API"><a href="#Transform-API" class="headerlink" title="Transform API"></a>Transform API</h4><p>Transform API 对单个字符串进行操作，它不访问文件系统。这使得它非常适合在没有文件系统(例如浏览器)的环境中使用，或者作为另一个工具链的一部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;esbuild&#x27;</span>).transformSync(<span class="string">&#x27;let x: number = 1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;ts&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">=&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;let x = 1;\n&#x27;</span>,</span><br><span class="line">  <span class="attr">map</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">warnings</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>社区中有很多基于 esbuild Transform API 打造的其他打包工具的插件，比如</p>
<ul>
<li><a href="https://github.com/privatenumber/esbuild-loader">esbuild-loader</a></li>
<li><a href="https://github.com/egoist/rollup-plugin-esbuild">rollup-plugin-esbuild</a></li>
</ul>
<h4 id="Build-API"><a href="#Build-API" class="headerlink" title="Build API"></a>Build API</h4><p>esbuild 的 Build API 做的事情和 webpack，rollup 等一样，需要入口文件，用于将一系列文件及其以来打包输出到一个或多个文件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).writeFileSync(<span class="string">&quot;in.ts&quot;</span>, <span class="string">&quot;let x: number = 1&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>).buildSync(&#123;</span><br><span class="line">  <span class="attr">entryPoints</span>: [<span class="string">&quot;in.ts&quot;</span>],</span><br><span class="line">  <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">  <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>).readFileSync(<span class="string">&quot;out.js&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">(<span class="string">&quot;let x = 1;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>设置 watch 选项为 true 既可以开启开发服务器模式，esbuild 会监听文件系统的变化并自动重新 build。</p>
<h3 id="内置-loaders"><a href="#内置-loaders" class="headerlink" title="内置 loaders"></a>内置 loaders</h3><p>esbuild 内置的 loaders 可以处理以下文件类型：JavaScript，typescript，jsx，json，css，text，binary，base64，dataurl，external file</p>
<p>除了 external，其他类型的 loader 会在处理相关扩展名的文件时自动调用，也可以通过 loader 手动设置调用规则。</p>
<p>需要注意的是 esbuild 对于 js 的处理。如果你想要用 esbuild 转译 es5 的代码，需要将<strong>target 设置为 es5</strong>，这可以避免 esbuild 进行错误的转译，比如将<code>&#123;x:x&#125;</code> 转译为 <code>&#123;x&#125;</code>。</p>
<p>esbuild 目前对将<strong>es6+ 的代码转译为 es5 的代码的支持不完善</strong>，如 <code>let</code>，<code>const</code> 等语法不会被转译。</p>
<h3 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h3><p>同 rollup 和 和 webpack 一样，esbuild 提供了插件机制，目前 esbuild 的插件 api 还在实验阶段，在未来可能会有很大的变动。<br><strong>esbuild 目前只支持在 build API 中使用插件，不支持 transform API</strong>。</p>
<h4 id="编写-esbuild-插件"><a href="#编写-esbuild-插件" class="headerlink" title="编写 esbuild 插件"></a>编写 esbuild 插件</h4><p>一个 esbuild 的插件是一个对象，有一个 <code>name</code> 属性和一个 <code>setup</code> 函数。在 build API 中，我们可以设置 plugins 数组。插件对象中的 <code>setup</code> 函数会在 build 每次运行时调用一次。</p>
<p>下面是文档中的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> envPlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;env&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Intercept import paths called &quot;env&quot; so esbuild doesn&#x27;t attempt</span></span><br><span class="line">    <span class="comment">// to map them to a file system location. Tag them with the &quot;env-ns&quot;</span></span><br><span class="line">    <span class="comment">// namespace to reserve them for this plugin.</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^env$/</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">path</span>: args.path,</span><br><span class="line">      <span class="attr">namespace</span>: <span class="string">&quot;env-ns&quot;</span>,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load paths tagged with the &quot;env-ns&quot; namespace and behave as if</span></span><br><span class="line">    <span class="comment">// they point to a JSON file containing the environment variables.</span></span><br><span class="line">    build.onLoad(&#123; <span class="attr">filter</span>: <span class="regexp">/.*/</span>, namespace: <span class="string">&quot;env-ns&quot;</span> &#125;, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">contents</span>: <span class="built_in">JSON</span>.stringify(process.env),</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>)</span><br><span class="line">  .build(&#123;</span><br><span class="line">    <span class="attr">entryPoints</span>: [<span class="string">&quot;app.js&quot;</span>],</span><br><span class="line">    <span class="attr">bundle</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [envPlugin],</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> process.exit(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>这个插件的作用是让 esbuild 将以 env 结尾的文件作为 json 文件解析。可以看到 esbuild 的插件编写非常简单，只有少量的关键概念和关键 API，下面我们来简单了解一下。</p>
<h4 id="两个关键观念"><a href="#两个关键观念" class="headerlink" title="两个关键观念"></a>两个关键观念</h4><h5 id="Namespaces-命名空间"><a href="#Namespaces-命名空间" class="headerlink" title="Namespaces 命名空间"></a>Namespaces 命名空间</h5><p>每个模块有一个关联的命名空间。默认情况下，esbuild 在 <code>file</code> 命名空间下工作，它对应于真实文件系统上的文件。<br>esbuild 也可以处理虚拟的模块，即并不对应于文件系统上的文件。举个例子，比如从 <code>stdin</code> 中提供的模块。</p>
<p>可以用插件去创建虚拟模块，标注模块在一个特定的命名空间，以使用其他的插件进行特殊处理。</p>
<h5 id="Filters-过滤器"><a href="#Filters-过滤器" class="headerlink" title="Filters 过滤器"></a>Filters 过滤器</h5><p>每一个回调函数必须提供一个正则表达式作为过滤器，那些不匹配的模块将被跳过处理。<br>你应该尽可能使用过滤正则表达式而非使用 js 代码来处理，因为 Filters 是在 esbuild 内部处理的，效率更高。</p>
<h4 id="两个主要回调"><a href="#两个主要回调" class="headerlink" title="两个主要回调"></a>两个主要回调</h4><h5 id="onResolve-回调"><a href="#onResolve-回调" class="headerlink" title="onResolve 回调"></a>onResolve 回调</h5><p>使用 onResolve 添加的回调会在每次 esbuild build 过程中的路径解析阶段被调用。这个回调用来自定义 esbuild 解析路径的行为。</p>
<p>下面这个例子中，插件将以 images 开头的导入路径重定向到 /public/images 目录，将 http 开头的路径标记为 external。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleOnResolvePlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redirect all paths starting with &quot;images/&quot; to &quot;./public/images/&quot;</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^images\//</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: path.join(args.resolveDir, <span class="string">&quot;public&quot;</span>, args.path) &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark all paths starting with &quot;http://&quot; or &quot;https://&quot; as external</span></span><br><span class="line">    build.onResolve(&#123; <span class="attr">filter</span>: <span class="regexp">/^https?:\/\//</span> &#125;, <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: args.path, <span class="attr">external</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="onLoad-回调"><a href="#onLoad-回调" class="headerlink" title="onLoad 回调"></a>onLoad 回调</h5><p>使用 onLoad 添加的回调会在所有没有被标记为 external 的模块中运行，模块由路径和命名空间共同标识。它用来自定义模块返回的内容，告诉 esbuild 如何去转译它。</p>
<p>下面这个例子中，插件将以 txt 文件以 utf8 方式获取内容后，以 json 数据形式读取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exampleOnLoadPlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">build</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load &quot;.txt&quot; files and return an array of words</span></span><br><span class="line">    build.onLoad(&#123; <span class="attr">filter</span>: <span class="regexp">/\.txt$/</span> &#125;, <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> text = <span class="keyword">await</span> fs.promises.readFile(args.path, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">contents</span>: <span class="built_in">JSON</span>.stringify(text.split(<span class="regexp">/\s+/</span>)),</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;esbuild&quot;</span>)</span><br><span class="line">  .build(&#123;</span><br><span class="line">    <span class="attr">entryPoints</span>: [<span class="string">&quot;app.js&quot;</span>],</span><br><span class="line">    <span class="attr">bundle</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">outfile</span>: <span class="string">&quot;out.js&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [exampleOnLoadPlugin],</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> process.exit(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="esbuild-插件的局限"><a href="#esbuild-插件的局限" class="headerlink" title="esbuild 插件的局限"></a>esbuild 插件的局限</h4><p>esbuild 的插件无法做到覆盖全部的用户场景。它只提供了自定义模块家在方式和自定义模块返回内容的能力，没有提供给我们直接访问 js ast 的能力，这是出于为了保持 esbuild 卓越性能的考虑，但这也导致很多 babel 插件提供的基于 js ast 的转译功能都无法使用 esbuild 的插件机制来实现。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>esbuild 作为打包工具的性能表现是极为出色的，但是现阶段并不能代替 webpack。一方面，webpack 经过多年的发展，生态非常成熟，可以覆盖到几乎所有的使用场景，另一方面，esbuild 本身受限的插件机制使得它注定无法完成一些事情。<br>比如说我们使用 webpack 中使用的 基于 ast 的 babel 插件，是没办法迁移到 esbuild 中去的，因为 esbuild 根本不提供访问 ast 的能力。<br>对于基于 webpack 的老项目，通常包含了很多基于 webpack 生态的 loader，插件等，将它们迁移到 esbuild 是一项艰巨且风险巨大的工作。新的项目没有技术债务，可以使用 esbuild 作为构建工具，可以极大提升开发体验。<br>但是，把 esbuild 作为纯的 js/ts 转译工具，或者作为代码压缩工具，作为其他构建工具工具链的一部分，是可以的融入到老项目中，提升构建速度的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://esbuild.github.io/">esbuild 官方文档</a><br><a href="https://blog.csdn.net/weixin_39843414/article/details/117719170">「 不懂就问 」esbuild 为什么这么快?</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>esbuild</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2019/09/16/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>跟着掘金小册学习如何在工作中使用 git</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h2 id="多人合作基本工作模型-2-0"><a href="#多人合作基本工作模型-2-0" class="headerlink" title="多人合作基本工作模型 2.0"></a>多人合作基本工作模型 2.0</h2><p>写完所有的 commit 后，不用考虑中央仓库是否有新的提交，直接 push 就好</p>
<p>如果 push 失败，就用 pull 把本地仓库的提交和中央仓库的提交进行合并，然后再 push 一次</p>
<h2 id="head，master"><a href="#head，master" class="headerlink" title="head，master"></a>head，master</h2><p>HEAD 指向的 branch 不能删除，如果要删除，需要先用 checkout 把 HEAD 指向其他地方</p>
<p>没有被合并到 master 过的 branch 在删除时会失败 如果需要删除 使用 -D</p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>push 是把当前的分支上传到远程仓库，并把这个 branch 的路径上的所有 commits 也一并上传。</p>
<p>push 的时候，如果当前分支是一个本地创建的分支，需要指定远程仓库名和分支名，用 git push origin branch_name 的格式，而不能只用 git push；或者可以通过 git config 修改 push.default 来改变 push 时的行为逻辑。</p>
<p>push 的时候之后上传当前分支，并不会上传 HEAD；远程仓库的 HEAD 是永远指向默认分支（即 master）的。</p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。</p>
<h2 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h2><p>当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）</p>
<p>待填坑中</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>helm安装sentry踩坑</title>
    <url>/2020/10/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/helm%E5%AE%89%E8%A3%85sentry%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p>最近一周一直在研究在公司的 rancher k8s 环境下搭建前端错误监控平台 sentry。首先介绍一下 sentry，这是一个非常强大的错误收集框架，可以收集众多语言的运行错误日志，其在前端错误的监控上应用的比较多。配合上传 sourceMap可以快速准确定位到源代码错误位置。</p>
<p>为什么它来监控前端错误呢？我们的测试无法覆盖到应用的方方面面，很多线上错误，往往是用户反馈到了客服人员，然后技术人员才能知晓，同时由于前端运行环境复杂，问题可能很难复现，技术人员定位错误需要不少的时间，这段时间就可能造成不小的损失了，如果解决问题花费的时间很久，用户对于这家公司的技术力也会产生质疑。应用前端错误监控之后，当线上有高频错误发生时，可以立即通过钉钉或者邮件的方式通知到开发人员，开发人员通过错误日志信息可以快速定位到错误点，这带来的好处是不言而喻的。</p>
<p>sentry 提供 saas 的服务，同时也提供开源的私有化部署版本，提供相同的服务体验。官方维护的是 docker-compose 的一键式部署方式，但是公司的云服务器都在 k8s 的集群，因此我考虑采用的是基于 k8s 的安装方式。然而公司并没有专业的运维人员，想折腾，只能自己动手了。最为一个一周前对 k8s 还是一窍不通的小白，踩坑是避免不了的，写这篇文章就是记录下踩的那些坑。</p>
<h2 id="错误方式-rancher-ui-商店方式安装"><a href="#错误方式-rancher-ui-商店方式安装" class="headerlink" title="错误方式 rancher ui 商店方式安装"></a>错误方式 rancher ui 商店方式安装</h2><p>一开始知道可以在 rancher 上安装 sentry，是在 v 站看到的一个回复，说是起个部署 sentry 会方便很多。然后知道了 rancher 的商店里可以找到 sentry，然后一键安装。这里需要开启 rancher 商店的 helm 官方仓库，结果商店死活刷不出来应用列表，后来才知道国内的云主机是无法访问 google 的 helm 仓库的，需要使用国内加速的仓库 <a href="http://mirror.azure.cn/kubernetes/charts。">http://mirror.azure.cn/kubernetes/charts。</a></p>
<p>换了加速地址后，可以顺利使用 rancher 商店启动应用了，工作负载一堆爆红，web，db和redis都没起来，这是因为没有设置默认存储类，导致 pvc 没有 绑定到 pv。刚一开始我可不知道 pv 和 pvc 的概念，更不用说默认存储类，总之是又百度又google又看官方文档的，算是稍稍搞明白了这块。这个在安装要求里已经说明了，k8s集群应该有一个默认存储类，用来动态分配pv。rancher ui 里像下图一样。</p>
<p><img src="/2020/10/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/helm%E5%AE%89%E8%A3%85sentry%E8%B8%A9%E5%9D%91/默认存储类.png" alt="默认存储类"></p>
<p>配置好了这个，按理说通过 rancher ui 的商店应该可以正常安装了吧，然而答案是并不能。这时候所有组件都能正常创建，除了一个 pending 的 loadbalance Service，这个我一开始没管它，自己又创建了一个 Ingress 配置，总算是可以访问 sentry 的 web 页面了。但是我按照文档的方法，输入用户名和密码，一直提示登录失败。我重装了几次，一直如此，折腾了几个小时，才发现了原因。</p>
<p>rancher ui 也是通过 helm 工具安装 chart 的，helm 默认的等待事件是 5分钟，超过了就认为安装失败了。而 sentry 的安装是包含了两个 job 的，db_init 和 user_create。db_init 用时很长，已经超过了5分钟，helm 认为安装失败了，就不继续调用 user_create 的 job了，导致初始用户根本没有被初始化进去。</p>
<h2 id="正确方式-helm-方式安装"><a href="#正确方式-helm-方式安装" class="headerlink" title="正确方式 helm 方式安装"></a>正确方式 helm 方式安装</h2><p>rancher ui中并没有方式去设置 helm 的等待时间，因此只能采用 helm 的方式进行安装了。这里感谢这位仁兄的文章 <a href="https://www.imooc.com/article/303501">Sentry实时应用错误跟踪系统在Kubernetes中私有化部署</a>，给予了我很大的帮助。</p>
<p>先简单介绍一下 helm，helm 是一个 k8s 的应用管理工具。helm 的 chart 我理解和 docker-compose 的 compose.yaml 类似，但是比后者更强大，通过预先配置的一组文件，来一键式部署k8s应用。helm现在有helm2和helm3两个版本，其中helm2需要在k8s中安装 helm2 服务端 Tiller，麻烦不说，还有潜在的后门隐患。helm3取消了这一步，因此这里使用的是helm3。</p>
<p>这里还踩了一个坑，一开始 helm 方式，连 db_init 的 job 都不运行。检查了以下各个组件，只有名为 sentry 的 service 处于 pending状态。它的 serviceType 是 loadbalance。尝试删掉它，helm 直接返回错误，我感觉是helm要等待所有组件就绪，才会调度job。我看了下文档，service 主要是负责外网连接功能的，它有两种类型 loadbalance 和 nodeport，loadbalance 只有使用 gce（谷歌的云服务） 的服务才能正常工作。后来把他改成 nodeport 果然正常了。db_init 后，user_create 也正常调度了。<br>最后摸索出来的命令是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm --kubeconfig  D:\bins\kubeconfig install sentry stable/sentry -n sentry --set persistenc</span><br><span class="line">e.enabled=true --set user.email=你的用户名 --set user.password=你的密码 --set email.host=你的邮箱host --set email.port=25 --set email.user=你的邮箱服务用户 --set email.password=你的邮箱服务密码 --set service.type=NodePort --set email.use_tls=false --wait --timeout=800s</span><br></pre></td></tr></table></figure>
<p>稍微等待个10分钟作用， sentry服务就部署完成了，确实是很简单。。。</p>
<p>明天研究一下将 sentry 引入项目，然后在下篇博客再总结一下 sentry 的前端监控应用。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>rancher</tag>
        <tag>sentry</tag>
        <tag>前端基建</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins自动构建部署前端镜像</title>
    <url>/2020/06/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>目标，实现 OJ 前端代码自动打包构建镜像到腾讯云，远程 ssh 登录学校主机自动部署镜像</p>
<p>尝试了一下在 docker 中安装 jenkins，遇到了无法解决的坑，还是在 windows 下安装吧。</p>
<h2 id="jenkins-插件下载加速"><a href="#jenkins-插件下载加速" class="headerlink" title="jenkins 插件下载加速"></a>jenkins 插件下载加速</h2><p>修改 jenkins_home 里 updates 中 default.json 文件,之后访问 /restart 路径 重启 jenkins 后生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json &amp;&amp; sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br></pre></td></tr></table></figure>
<h2 id="无法执行-shell-脚本"><a href="#无法执行-shell-脚本" class="headerlink" title="无法执行 shell 脚本"></a>无法执行 shell 脚本</h2><p>Manage Jenkins&gt;Configuration System<br>将 shell 设置为 git 安装目录 下 bin/sh.exe 的路径</p>
<h2 id="node-环境"><a href="#node-环境" class="headerlink" title="node 环境"></a>node 环境</h2><p>下载 jenkinsNode 插件后，直接设置为本机的 node 安装目录<br><img src="/2020/06/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%95%9C%E5%83%8F/nodejs配置.png" alt="nodejs配置"></p>
<h2 id="配置-publish-over-ssh"><a href="#配置-publish-over-ssh" class="headerlink" title="配置 publish over ssh"></a>配置 publish over ssh</h2><p>首先安装 Publish Over SSH 插件</p>
<p>报错 invalid private key<br>这是生成的 key 格式不同，插件不认新的 openssh 的格式，需要将私钥转回老格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>老格式文件的开头是这样的</p>
<h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><p>选择自由软件，配置 github 仓库地址，选择构建环境为设置的 nodejs 环境</p>
<h3 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> FE &amp;&amp; yarn &amp;&amp; yarn build</span><br><span class="line"><span class="built_in">cd</span> FE &amp;&amp; docker build -t ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe .</span><br><span class="line">docker login --username=xxxxxx --password=xxxxxx ccr.ccs.tencentyun.com &amp;&amp; docker tag ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe:<span class="variable">$BUILD_NUMBER</span> &amp;&amp; docker push ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe</span><br><span class="line">docker rmi ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe:<span class="variable">$BUILD_NUMBER</span></span><br><span class="line">docker rmi ccr.ccs.tencentyun.com/jiezi19971225/ahpuoj-fe</span><br></pre></td></tr></table></figure>
<h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ahpuoj/ahpuojv2docker/compose</span><br><span class="line">docker-compose pull fe</span><br><span class="line">docker-compose up -d fe</span><br><span class="line">// 这行命令用来删除老的镜像</span><br><span class="line">docker image prune -f --filter <span class="string">&quot;dangling=true&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="it-works"><a href="#it-works" class="headerlink" title="it works"></a>it works</h2><p><img src="/2020/06/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%95%9C%E5%83%8F/itWorks.png" alt="itWorks"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>npm私仓搭建并制作发布npm包</title>
    <url>/2020/10/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/npm%E7%A7%81%E4%BB%93%E6%90%AD%E5%BB%BA%E5%B9%B6%E5%88%B6%E4%BD%9C%E5%8F%91%E5%B8%83npm%E5%8C%85/</url>
    <content><![CDATA[<p>这几天发现多端上存在一些重合的业务逻辑代码，在每个项目中都写一遍逻辑是很没有效率的事情，也不利于 bug 的管控与治理。一般在 vue 项目中，同一个项目中的重复代码可以通过封装组件，封装 mixin，抽离 utils 函数的方式来复用，对于分散在多个项目中的重复代码，可以通过制作为 npm 包的方式来实现复用。</p>
<p>公司的前端基础设施还是非常不完善的，并没有自己的 npm 私仓。首先要把 npm 私仓建立起来，经过一番查找资料最终决定采用 verdaccio 进行搭建。</p>
<h2 id="npm-私仓搭建"><a href="#npm-私仓搭建" class="headerlink" title="npm 私仓搭建"></a>npm 私仓搭建</h2><p>verdaccio 是一个轻量级的 npm 私有仓库软件。它的搭建过程非常简便，无需数据库，唯一的要求就是需要有 node 环境。</p>
<p><a href="https://blog.csdn.net/qq_35876316/article/details/106542802">windows 搭建私服 verdaccio（内外网安装）</a><br><a href="https://blog.csdn.net/yuzheng7002/article/details/104196062">使用 verdaccio 搭建 npm 私有库 pm2 守护进程</a><br>搭建主要过程主要参考了这两篇博文，唯二需要注意的是 配置文件末尾应该加上 listen:0.0.0.0:4873 还有 使用 pm2 启动的时候，应该填写 verdaccio 的绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 start C:\Users\Administrator\AppData\Roaming\npm\node_modules\verdaccio\bin\verdaccio</span><br><span class="line"># 如果是linux，就用下面这个命令就好了</span><br><span class="line">pm2 start `which verdaccio`</span><br></pre></td></tr></table></figure>
<h2 id="使用私仓"><a href="#使用私仓" class="headerlink" title="使用私仓"></a>使用私仓</h2><h3 id="nrm-方式"><a href="#nrm-方式" class="headerlink" title="nrm 方式"></a>nrm 方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装nrm</span><br><span class="line">npm install -g nrm</span><br><span class="line">添加仓库</span><br><span class="line">nrm add seeker http://&#123;地址&#125;:4873/</span><br><span class="line">使用仓库</span><br><span class="line">nrm use seeker</span><br></pre></td></tr></table></figure>
<h3 id="npmrc"><a href="#npmrc" class="headerlink" title="npmrc"></a>npmrc</h3><p>直接添加<br>registry=<a href="http://{地址}:4873/">http://{地址}:4873/</a></p>
<h2 id="npm-包制作发布流程"><a href="#npm-包制作发布流程" class="headerlink" title="npm 包制作发布流程"></a>npm 包制作发布流程</h2><p>要制作一个 npm 包，包含代码编写，本地测试，文件打包等关键点<br>首先需要搭建的是打包的工作流，这里采用的是 rollup + typescript 搭建的。</p>
<p>为什么要用 typescript 编写包呢？如果你是用的 vscode 写代码，一定会觉得 vscode 的代码提示非常好用，当你引用一个包时，包函数的使用方法都以 ts 函数定义的方式显示出来，这个是靠 typescript 的 .d.ts 文件做到的。而用 typescript 编写类库，就可以使用 tsc 自动生成 .d.ts 文件，让我们自己编写的库也能获得 vscode 代码提示的加持。这样来编写库，对库使用人员是非常友好的。</p>
<h3 id="rollup工作流搭建"><a href="#rollup工作流搭建" class="headerlink" title="rollup工作流搭建"></a>rollup工作流搭建</h3><p>rollup 使用非常简单。安装rollup后，只需要编写一个简单的配置文件，就可以工作了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&quot;@rollup/plugin-typescript&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">&quot;./package.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&quot;src/index.ts&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 出口文件</span></span><br><span class="line">      <span class="attr">file</span>: pkg.main,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&quot;umd&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;seeker-fe-utils&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 出口文件</span></span><br><span class="line">      <span class="attr">file</span>: pkg.module,</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&quot;es&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;seeker-fe-utils&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [typescript()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我这里引用了 rollup 的 typescript 插件，可以看到我输出了两种模块规范的目标文件。注意这里我直接引入了 package.json，以其中的 main 字段和 module 字段直接作为输出路径，保证了入口文件路径的准确性，可以算是一个小技巧。</p>
<p>目前我使用的 @rollup/plugin-typescript 插件版本是 6.0.0，这个版本有一个 bug，即输出多个文件与自动生成 .d.ts 的配置是冲突的。要生成 .d.ts需要在 tsconfig 文件中设置 outDir，然后就会导致很蛋疼的冲突问题。参考了 stackoverflow 上的解决方法是，不使用 tsconfig配置，而是通过命令行传参的方式单独生成 .d.ts 文件。把以下命令配置到 package.json 的 script 中。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;gen-type&quot;: &quot;npx tsc -d --emitDeclarationOnly --outDir types&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;npx rollup -c&quot;,</span><br><span class="line">  &quot;pub&quot;: &quot;npx rollup -c &amp;&amp; npm publish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="package-json-配置简要说明"><a href="#package-json-配置简要说明" class="headerlink" title="package.json 配置简要说明"></a>package.json 配置简要说明</h3><p>如果要发布 npm 包，以下三个字段是必须的。<br>name - 包名<br>version - 版本号，每次发布的版本必须与之前的版本不同<br>main - 指定 cjs 模块入口文件的路径<br>module - 指定 esm 模块入口文件的路径，用来和webpack搭配只用<br>broswer - 指定 umd 模块入口文件的路径</p>
<h3 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h3><p>npm 提供了 npm version 系列命令用来修改 package.json 中的版本号。<br>README 文件正常会在 npm 包发布的时候更新。</p>
<h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>在本地测试一般使用 npm link，具体方法是</p>
<p>在包项目根目录下使用npm link，这将会把包软连接到全局 npm 包中。<br>在项目目录下使用 npm link 包名，这将会把在全局包下的包软连接到项目的 node_modules 文件夹中。<br>在开发时可以指定 package.json 中的 main 为源文件的路径，这样就可以边修改包源码边测试了。</p>
<p>还可以使用 npm install {npm 包绝对路径} 在本地安装 npm 包测试</p>
<h3 id="包发布"><a href="#包发布" class="headerlink" title="包发布"></a>包发布</h3><p>npm 同名包以版本区分，发布新的版本，旧的版本依旧存在<br>npm publish 发布该版本的包<br>npm unpublish 从 registry 中删除该版本的包</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack爬坑之路</title>
    <url>/2019/09/04/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/webpack%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="打包文件资源问题"><a href="#打包文件资源问题" class="headerlink" title="打包文件资源问题"></a>打包文件资源问题</h3><p>filename 指列在 entry 中，打包后输出的文件的名称。<br>chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。</p>
<h3 id="项目缓存问题"><a href="#项目缓存问题" class="headerlink" title="项目缓存问题"></a>项目缓存问题</h3><p>当项目上线新版本的时候，用户浏览器可能仍然使用的是之前 html 和 js 文件的缓存。通过以下几个方法可以解决这个问题。</p>
<ul>
<li>文件命名使用哈希值，这样当发布新版本就会请求新版本的资源文件。vue-cli 中默认有这个功能，webpack 在每次构建的时候都会生成 hash，contenthash，chunkhash 三个哈希值<ul>
<li>hash 这是工程级别的，即每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</li>
<li>chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用 chunkhash 的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。并且 webpack4 中支持了异步 import 功能，chunkhash 也作用于此。</li>
<li>contenthash 一般来说，样式是作为模块 import 到 js 文件中，他们的 chunkhash 是一致的，这导致只要对应的 css 或者 js 改变，chunkhash 就会改变。而 contenthash 是针对文件内容级别的，只有自身模块的内容变了，hash 值才改变</li>
</ul>
</li>
<li>html 加上</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;no-cache, no-store, must-revalidate&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 nginx，禁止 html 入口文件的缓存</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location = /index.html &#123;</span><br><span class="line">    add_header Cache-Control <span class="string">&quot;no-cache, no-store&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">location = /admin_index.html &#123;</span><br><span class="line">    add_header Cache-Control <span class="string">&quot;no-cache, no-store&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 HtmlWebpackPlugin 插件，一个典型的配置如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;admin_index.html&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;web-admin/admin_index.html&#x27;</span>,</span><br><span class="line">    <span class="attr">inject</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">hash</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">chunks</span>: [<span class="string">&#x27;adminApp&#x27;</span>, <span class="string">&#x27;vendor~adminApp&#x27;</span>, <span class="string">&#x27;vendor~adminApp~userApp&#x27;</span>],  <span class="comment">// 这个数组是html要引入的打包生成的chunk文件，chunkname 在 webpack 打包输出信息中</span></span><br><span class="line">    <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeAttributeQuotes</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/04/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/webpack%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF/chunkname.png" alt="chunkname"><br>图中最右边一列就是资源的 chunkname</p>
<h3 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h3><p>之前项目使用的是 ExtractTextPlugin 对 css 进行抽出并打包，然而 ExtractTextPlugin 在 4.0 版本后不再支持对 css 进行打包 (会在生成的 css 文件末尾附加 webpack 运行时的代码)，后学习得知现在应使用 MiniCssExtractPlugin 对 css 进行抽离</p>
<h3 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h3><p>这个插件的作用是每次构建的时候，清理重复构建的文件，因为使用哈希方式构建的时候，文件名不同，更改的文件不会直接替换。个人感觉使用 rm -rf dist/* 清理也可以 当然这可以避免你神志不清时误把整个项目文件删了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&quot;dist&quot;</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="optimization-splitChunks"><a href="#optimization-splitChunks" class="headerlink" title="optimization.splitChunks"></a>optimization.splitChunks</h3><p>非常实用的功能，抽出代码中的公共组件到独立的文件，举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cacheGroups: &#123;</span><br><span class="line">    <span class="attr">vendor</span>: &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        chunks: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">        <span class="comment">// name:&quot;vendor&quot;,</span></span><br><span class="line">        <span class="attr">priority</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有 name 属性，a 入口文件引用了 vue 和 axios， b 入口文件引用了 react 和 axios，那么 webpack 就会把 axios 单独抽离出来为独立的 chunk，同时 vue 和 react 在各自的独立 chunk 中<br>而如果有 name 属性，那么所有依赖文件都会打包到命名的 chunk 文件中，这个原理同样适用于 CSS 的打包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将 node_modules 中代码单独打包一个 chunk 最终输出</p>
<p>通过 js 代码让文件打包成单独 chunk</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/*webpackChunkName:&#x27;test&#x27;,webpackPrefetc:true*/</span>,<span class="string">&quot;./test&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 es6 module</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>懒加载 当文件需要时才加载<br>预加载 prefetch 会在使用之前，提前加载 js 文件，等其他资源加载完毕了，再偷偷加载<br>正常加载认为是并行加载</p>
<h3 id="OptimizeCssAssetsPlugin"><a href="#OptimizeCssAssetsPlugin" class="headerlink" title="OptimizeCssAssetsPlugin"></a>OptimizeCssAssetsPlugin</h3><p>我在打包时发现 node_modules 中的 css 文件无法被压缩。css loader 中的 minimize 选项早已被废弃，尝试使用了这个插件后解决了问题。</p>
<h3 id="devserver"><a href="#devserver" class="headerlink" title="devserver"></a>devserver</h3><ul>
<li>proxy<br>代理的只能是本地 如果本身请求的目的地址已经指定不是本地，那么这个请求不会被 webpack 代理</li>
<li>HMR<ul>
<li>样式文件 可以使用 因为 style-loader 内部实现了 HMR</li>
<li>js 文件 默认不能使用 HMR 功能</li>
<li>html 文件不能热更新 将 html 文件 加入 entry 这样会重新加载页面 不需要作 HMR 功能</li>
</ul>
</li>
</ul>
<h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>source-map</td>
<td>外部 错误代码的准确信息访问到源代码的准确位置</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>内联 只生成一个 sourcemap</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>外联 错误代码错误原因，但是没有错误位置，不能追踪源代码错误，只能提示到构建后代码的错误位置</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>内联 每一个文件都生成对应的 source-map，都在 eval 错误代码准确信息，和源代码的错误位置</td>
</tr>
<tr>
<td>nosources-source-map</td>
<td>外部 错误代码准确信息，但是没有任何源代码信息</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>外部 错误代码准确信息和源代码的错误位置 只能精确到行</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>外部 错误代码准确信息 和 源代码错误位置</td>
</tr>
</tbody>
</table>
</div>
<p>module 会将 loader 的 source map 加入</p>
<p>开发环境:速度快，调试更友好<br>速度快(eval&gt;inline&gt;cheap)<br>eval-cheap-source-map<br>eval-source-map<br>调试更友好<br>source-map<br>cheap-moudule-source-map<br>cheap-source-map</p>
<p>eval-cheap-source-map</p>
<ul>
<li>内联和外部的区别 1. 外部生成了文件，内联没有 2. 内联构建速度更快</li>
</ul>
<p>开发环境：速度快，调试更友好<br>eval&gt;inline&gt;cheap<br>source-map<br>cheap-module-source-map<br>cheap-source-map<br>eval-source-map / eval-cheap-moudule-source-map</p>
<p>生产环境：源代码要不要隐藏？调试友好程度<br>内联会让代码变大，所以再生产环境不用内联<br>nosources-source-map 全部隐藏<br>hidden-source-map 只隐藏代码，会提示构建代码错误信息</p>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>babel 缓存 cacheDirectory: true</p>
<h3 id="tree-shakin-去除无用代码"><a href="#tree-shakin-去除无用代码" class="headerlink" title="tree shakin 去除无用代码"></a>tree shakin 去除无用代码</h3><ul>
<li><p>必须使用 ES6 模块化</p>
</li>
<li><p>开启 production 环境</p>
</li>
<li><p>在 package.json 中配置 “sideEffects”:false 所有的代码都没有副作用，都可以进行 tree shaking 可能会把 css/ @bable/polyfill 文件干掉</p>
</li>
<li>定义 nodejs 环境变量：决定使用 browserslist 的哪个环境 process.env.NODE_ENV = ‘production’</li>
</ul>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>workbox-&gt;workbox-webpack-plugin</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW &#123;</span><br><span class="line">  <span class="comment">// 生成 serverworker.js</span></span><br><span class="line">  <span class="attr">clientClaim</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">skipWaiting</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eslint 不认识 window,navigator 全局变量，需要修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">env: &#123;</span><br><span class="line">  <span class="attr">browser</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多进程打包-thread-loader"><a href="#多进程打包-thread-loader" class="headerlink" title="多进程打包 thread-loader"></a>多进程打包 thread-loader</h3><p>开启多进程打包，进程启动大概 600ms，进程通信也有开销<br>多用在 babel-loader</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">loader</span>:<span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>:&#123;</span><br><span class="line">    <span class="attr">workers</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="externals-忽略打包"><a href="#externals-忽略打包" class="headerlink" title="externals 忽略打包"></a>externals 忽略打包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  <span class="comment">// 忽略库名 -- npm 包名</span></span><br><span class="line">  <span class="attr">jQuery</span>: <span class="string">&quot;jQuery&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>打包 dll</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&quot;jquery&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&quot;dll&quot;</span>),</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&quot;[name]_[hash]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个 manifest.json --&gt; 提供和jquery映射</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DLLPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;[name]_[hash]&quot;</span>,</span><br><span class="line">      <span class="attr">path</span>: resolve(__dirname, <span class="string">&quot;dll/manifest.json&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义 dll</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DLLReferencePlugin(&#123;</span><br><span class="line">  <span class="attr">manifest</span>: resolve(__dirname, <span class="string">&quot;dll/manifest.json&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>引用 dll</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">  <span class="attr">filepath</span>: resolve(__dirname, <span class="string">&quot;dll/jquery.js&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h3><ul>
<li><p>module</p>
<ul>
<li>enforce:’pre’, // 优先执行</li>
<li>enforce:’post’, // 延后执行</li>
</ul>
</li>
<li><p>resolve 解析模块的规则</p>
<ul>
<li>alias 配置解析模块的别名</li>
<li>extensions:[‘.js’,’json’] 配置省略文件路径的后缀名</li>
<li>modules:[resolve(__dirname,’../../node_modules’),’node_modules’] 解析模块去找哪个目录</li>
</ul>
</li>
<li><p>optimization</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  <span class="comment">// 将当前模块记录的其他模块的hash单独打包为一个文件 runtime 一定要加上 保证未改动模块缓存不失效</span></span><br><span class="line">  <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="function"><span class="params">entrypoint</span> =&gt;</span> <span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">minimize</span>:&#123;</span><br><span class="line">    <span class="comment">// 配置生产环境的压缩方案: js和css</span></span><br><span class="line">    <span class="keyword">new</span> TerserWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="attr">cache</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多进程打包</span></span><br><span class="line">      <span class="attr">parallel</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 启动source-map</span></span><br><span class="line">      <span class="attr">sourceMap</span>:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn命令</title>
    <url>/2021/10/21/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/yarn%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="yarn-add"><a href="#yarn-add" class="headerlink" title="yarn add"></a>yarn add</h2><p>-E 选项明确指定版本<br>—audit 检查在已安装的包中所有已经的安全问题并输出</p>
<h2 id="yarn-autoclean"><a href="#yarn-autoclean" class="headerlink" title="yarn autoclean"></a>yarn autoclean</h2><p>autoclean 命令通过从依赖项中删除不必要的文件和文件夹来释放空间。它减少了项目节点模块文件夹中的文件数量，这在直接将包签入版本控制的环境中非常有用。</p>
<h2 id="yarn-bin"><a href="#yarn-bin" class="headerlink" title="yarn bin"></a>yarn bin</h2><p>输出 yarn 安装可执行文件的目录</p>
<h2 id="yarn-cache"><a href="#yarn-cache" class="headerlink" title="yarn cache"></a>yarn cache</h2><p>可以管理下载的包缓存</p>
<h2 id="yarn-create"><a href="#yarn-create" class="headerlink" title="yarn create"></a>yarn create</h2><p>是一个快捷指令</p>
<p>yarn create react-app my-app 就相当于</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn global add create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure>
<h3 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h3><p>举个例子，项目中引入了 pakcageA，依赖 A 中的 package.json 中的 dependencies 中包含了 packageB，那么项目的目录结构是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject</span><br><span class="line">|- node_modules</span><br><span class="line">   |- PackageA</span><br><span class="line">      |- node_modules</span><br><span class="line">         |- PackageB</span><br></pre></td></tr></table></figure>
<p>我们在项目中，可以直接通过下面语句引用 PackegeA，但是不能直接引用 PackageB。所以，为了解决这个问题，在 MyProject 项目 package.json 中我们必须直接声明对 PackageB 的依赖并安装。</p>
<p>而如果是在 peerDependencies 声明的 packgeB 的话，得到的目录结构是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject</span><br><span class="line">|- node_modules</span><br><span class="line">   |- PackageA</span><br><span class="line">   |- PackageB</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>微信小程序官方文档学习</title>
    <url>/2021/10/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/%E5%8E%9F%E7%94%9F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>backgroundColor 不是背景的颜色 而是下拉页面的背景色</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>组件间的生命周期会有些区别</p>
<ul>
<li>onLoad 页面加载，一个页面只会调用一次，可以获得 query 参数</li>
<li>onShow 页面显示 、页面切入前台都会调用</li>
<li>onHide 页面隐藏/切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等</li>
<li>onReady 页面初次渲染完成，表示可以与视图层进行交互,像动态改变页面标题的就可以在这处理， wx.setNavigationBarTitle</li>
<li>onUnload 页面卸载时触发。如 wx.redirectTo 或 wx.navigateBack 到其他页面时。</li>
</ul>
<p>小程序从启动到关闭，生命周期函数的执行情况<br>1、初次打开： 会执行小程序的生命周期钩子函数：onLaunch -&gt; onShow -&gt; onReady<br>2、使用 navigateTo 离开当前页面： 保留所离开的页面，执行 onHide<br>3、使用 navigateBack 离开当前页面： 销毁当前页面，执行 onHide -&gt; onUnload<br>4、使用 switchTabTo 离开当前页面： 销毁所有非 tab 页面，但保留所有已经加载的 tab 页面</p>
<p>components 中的生命周期函数<br>1、 组件实例化： created 节点树还未导入, 无法使用 setData<br>2、节点树导入完成： attached 可以使用 setData 来初始化数据，但无法操作节点<br>3、组件布局完成: ready 组件布局完成，可以获取到节点信息也可以操作节点<br>4、组件实例被移动到节点树另一个位置： moved<br>5、组件实例从页面节点移除： detached</p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>有冒泡和非冒泡两种</p>
<p>WXML 的冒泡事件列表：<br>类型 触发条件 最低版本<br>touchstart 手指触摸动作开始<br>touchmove 手指触摸后移动<br>touchcancel 手指触摸动作被打断，如来电提醒，弹窗<br>touchend 手指触摸动作结束<br>tap 手指触摸后马上离开<br>longpress 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 1.5.0<br>longtap 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）<br>transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发<br>animationstart 会在一个 WXSS animation 动画开始时触发<br>animationiteration 会在一个 WXSS animation 一次迭代结束时触发<br>animationend 会在一个 WXSS animation 动画完成时触发<br>touchforcechange 在支持 3D Touch 的 iPhone 设备，重按时会触发 1.9.90</p>
<h4 id="bind-和-catch-的区别"><a href="#bind-和-catch-的区别" class="headerlink" title="bind 和 catch 的区别"></a>bind 和 catch 的区别</h4><p>bind 系列事件绑定不会阻止冒泡事件向上冒泡，但是 catch 系列事件绑定可以阻止冒泡事件向上冒泡。</p>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template 可以类比于传统后端模板引擎引用代码片段<br>在一个 wxml 文件中可以定义多个 template，用 name 进行区分</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">&quot;/templates/item.wxml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&quot;item2&quot;</span> <span class="attr">data</span>=<span class="string">&quot;&#123;&#123;text:&#x27;foobar&#x27;&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。<br>如：C import B，B import A，在 C 中可以使用 B 定义的 template，在 B 中可以使用 A 定义的 template，但是 C 不能使用 A 定义的 template。</p>
<h5 id="inlcude"><a href="#inlcude" class="headerlink" title="inlcude"></a>inlcude</h5><p>include 可以将目标文件除了 template wxs 外的整个代码引入，相当于是拷贝到 include 位置，如：</p>
<h3 id="响应式数据访问"><a href="#响应式数据访问" class="headerlink" title="响应式数据访问"></a>响应式数据访问</h3><p>在 page 或者 component 中的生命周期或者 methods 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="string">&#x27;xxx</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>需要使用 this.data.a 进行访问，相比与 vue，需要多一层 data 属性，vue 内部对 data 属性的访问是做了代理的，而小程序则没有这层代理</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>这种方式很 react</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>required 不支持绝对路径<br>设置 tabbar 坑！ 首页必须包含在其中，否则不能显示<br>npm 安装 weui-wxss 构建 npm 提示 没有找到可以构建的 npm 模块 是因为 weui-wxss 没有导出模块的设置<br>数据库 获取不到数据 这个是数据库访问权限设置的问题</p>
<h3 id="原生-API"><a href="#原生-API" class="headerlink" title="原生 API"></a>原生 API</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>wx.switchTab 只能跳转到带有 tabbar 的页面 关闭其他所有非 tabBar 页面，跳转路径不能带参数<br>wx.reLaunch 关闭所有页面，打开到应用内的某个页面 路由可以带有参数<br>wx.redirectTo 关闭当前页面，跳转到不带 tabbar 的页面，路由可以带有参数</p>
<p>以上方法可接受一个 Object 作为参数 参数格式如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>string</td>
<td>无</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>success</td>
<td>function</td>
<td>无</td>
<td>否</td>
<td>接口调用成功的回调函数</td>
</tr>
<tr>
<td>fail</td>
<td>function</td>
<td>无</td>
<td>否</td>
<td>接口调用失败的回调函数</td>
</tr>
<tr>
<td>complete</td>
<td>function</td>
<td>无</td>
<td>否</td>
<td>接口调用结束的回调函数（调用成功、失败都会执行）</td>
</tr>
</tbody>
</table>
</div>
<p>wx.navigateBack 关闭当前页面，返回上一页面或者多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。<br>它不接受 url 参数，可以接受一个 delta 作为参数，决定要返回几层</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>delta</td>
<td>number</td>
<td>1</td>
<td>否</td>
<td>返回的页面数，如果 delta 大于现有页面数，则返回到首页。</td>
</tr>
</tbody>
</table>
</div>
<p>wx.navigateTo 保留当前页面，跳转到应用某个页面，但是不能跳转到 tabbar 页面。相比于以上方法，他多了一个可选参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>events</td>
<td>Object</td>
<td>无</td>
<td>否</td>
<td>页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h4><p>wx.startPullDownRefresh 可以手动条用 onPllDownRefresh 声明周期的方法<br>wx.pageScrollTo 将页面滚动到目标位置，支持选择器和滚动距离两种方式定位</p>
<h4 id="填坑中"><a href="#填坑中" class="headerlink" title="填坑中"></a>填坑中</h4>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45</title>
    <url>/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>Mysql 拿到一个查询请求后，会先到查询缓存看是否执行过该语句。缓存可能会以 key-value 对形式直接缓存在内存，如果能直接在缓存中找到结果，就直接返回 value 给客户端，否则，就继续后面的执行阶段。执行完成后，执行结果被存入查询缓存。</p>
<p>但是查询缓存的失效非常频繁，只要对一个表有更新，这个表上所有查询缓存都会被清空。从 mysql8.0 版本，查询缓存的功能被删除了。</p>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><img src="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/查询流程.png" alt="查询流程"></p>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p>WAL 技术全称是 Write-Ahead Logging 先写日志，再写磁盘，当有一条记录需要更新的时候，innodb 会把记录写到 redo log，并更新内存，并在适当的时候，将这个操作记录更新到磁盘。redolog 的大小是固定的，写到末尾又会回到开头覆写。<br>因为 redolog，innodb 可以保证数据库异常重启后，之前提交的记录不会丢失，称为 crash-safe。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redolog 是 innodb 特有的 log，而 server 层也有自己的日志，称为 binlog（归档日志）<br>redolog 是物理日志，记录在某个数据页做了什么修改，binlog 是逻辑日志，记录的是语句的原始逻辑<br>binlog 采用追加写，写到一定大写后会创建新的 binlog，不会覆盖之前的日志</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>浅色表示在 innoDB 内部执行，深色表示在执行器中执行<br><img src="/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/两阶段提交.png" alt="两阶段提交"></p>
<p>redolog 的写入拆分成 parpare 和 commit 两步，保证两个日志逻辑上的一致，这给了 binlog 和 redolog 一个同时说 ok 的机会</p>
<h4 id="崩溃恢复原则"><a href="#崩溃恢复原则" class="headerlink" title="崩溃恢复原则"></a>崩溃恢复原则</h4><p>redo log 和 binlog 有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>
<ol>
<li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li>
<li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。<ul>
<li>binlog 无记录，回滚事务</li>
<li>binlog 有记录，提交事务。</li>
</ul>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>set innodb_flush_log_at_trx_commit = 1 将每次事务都持久化到磁盘<br>set sync_binlog = 1 将每次事务的 binlog 都持久化到磁盘</p>
<h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>读未提交，一个事务还没提交时，它做的变更就能被别的事务看到<br>读提交，一个事务提交之后，他做的变更才会被其他事务看到<br>可重复读是，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一样的，未提交的变更对其他事务是不可见的<br>串行化，对于同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成后才能继续执行<br>配置方式 将启动参数 transaction_isolation 的值设置成 READ-COMMITTED，可以用 show variables 查看当期数值</p>
<p>数据库内会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是在事务启动的时候创建的，整个事务存在期间都用这个事务。在读提交级别下，这个视图是在每个 sql 语句开始执行的时候创建的。读未提交没有视图概念，串行化直接用加锁的方式避免并行访问。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>可重复读 每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，可以得到前一个状态的值<br>不同时刻启动的事务会有不同的 read-view,同一个记录的值分别是 1,2,3,4，同一个记录在系统中可以存在多个版本，这是数据库的多版本并发控制 mvcc。对于 read-view A，要得到更新后的值，就必须将当前数值依次执行所有回滚操作<br>回滚日志会一直保留到没有比这个更早的 read-view 的时候，因此尽量不要使用长事务</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>显式启动事务 begin 或 start transaction 提交使用 commit 回滚使用 rollback<br>set autocommit=0 会将线程的自动提交关掉，这意味着事务不会自动提交，知道主动执行 commit 或者 rollback 或者断开连接，建议总是设置 autocommit 为 1<br>可以在 informatino_schema 库的 innodb_trx 表中查询长事务</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>三种数据结构<ul>
<li>哈希表 优点是增加新的 user 时速度很快，只需要往后追加，但缺点是，因为不是有序的，哈希索引做区间查询速度很慢</li>
<li>有序数组 在等值查询和范围查询场景的性能非常优秀，但是需要插入的时候成本太高，只适用于静态存储引擎</li>
<li>搜索树 目前数据库中使用的是 N 叉数</li>
</ul>
</li>
</ul>
<h3 id="innodb-的索引模型"><a href="#innodb-的索引模型" class="headerlink" title="innodb 的索引模型"></a>innodb 的索引模型</h3><ul>
<li>innodb 中，表都是根据主键顺序以索引的形式存放的，这种方式称为索引组织表，使用 B+树索引模型，所有数据存储在 B+树中。</li>
<li>主键索引的叶子节点存的是整行数据，在 innodb 中，主键索引也被称为聚簇索引，非主键索引的叶子节点的内容是主键的数值，非主键索引也被称为二级索引</li>
<li>使用二级索引查表需要先找到主键的值，再在主键的索引书搜索一次，这个过程称为回表</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><ul>
<li>主键索引树需要保持树的有序性，自增主键的插入数据模式的耗时很低，而有业务逻辑的字段作主键，往往不容易保证有序插入，这样写数据的成本相对较高</li>
<li>而且从空间角度，使用 int 型作为主键，占用的空间也较小，主键索引越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</li>
<li>直接用业务字段作主键<ul>
<li>只有一个索引</li>
<li>该索引必须是唯一索引</li>
</ul>
</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果在某个查询里面，索引 k 已经覆盖了我们的查询需求，我们称其为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能</p>
<h3 id="最左索引"><a href="#最左索引" class="headerlink" title="最左索引"></a>最左索引</h3><ul>
<li>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以使联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</li>
</ul>
<h3 id="下推优化"><a href="#下推优化" class="headerlink" title="下推优化"></a>下推优化</h3><p>mysql5.6 之后，可以在索引遍历的过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数</p>
<h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p>重建主键索引会将整个表重建</p>
<ul>
<li>普通索引与唯一索引的性能差距<br>对于普通索引，查找到满足条件的第一条记录后，还需要继续查找知道碰到第一个不满足条件的记录，对于唯一索引，由于定义了唯一性，查找到第一个满足条件的记录后就会停止继续检索，这带来的性能差距呢是微乎其微，innodb 是按照页读写的，当找到记录的时候，他所在的数据页也都在内存中，因此下一次查找的消耗很低</li>
<li>change buffer<br>当需要更新一个数据页时，如果数据页在内存中就直接更新，如果不再，在不影响数据一致性的前提下，innodb 会将更新操作缓存在 changer buffer 中，当下一次查询需要访问这个页面的时候，将数据读入内存，然后执行 change buffer 中与这个页有关的操作。很像操作系统中的页面交换。</li>
<li>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 purge，除了访问这个数据页会触发 purge，还有后台线程会定期 purge，在数据库正常关闭的过程中，也会执行 purge</li>
<li>对于唯一索引，所有更新操作都先判断这个操作是否违反唯一约数，要将数据页读入内存才能判断，没必要使用 change buffer 实际上只有普通索引可以使用</li>
<li>change buffer 用的是 buffer pool 里的内存，可通过 innodb_change_buffer_max_size 来动态设置</li>
<li>对于写多读少的业务，比较适合使用 change buffer，如果业务写入之后立即查询，由于会频繁触发 purge 过程，增加了 change buffer 的维护代价，反而起到了副作用</li>
</ul>
<h3 id="mysql-选择了错误的索引"><a href="#mysql-选择了错误的索引" class="headerlink" title="mysql 选择了错误的索引"></a>mysql 选择了错误的索引</h3><ul>
<li>可以使用 force index 强制选取使用的索引</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45-3</title>
    <url>/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="order-by-是怎么工作的"><a href="#order-by-是怎么工作的" class="headerlink" title="order by 是怎么工作的"></a>order by 是怎么工作的</h4><ul>
<li>mysql 的外部排序采用归并排序，将排序数据分成多个保存到临时文件中，最后合并为一个大文件</li>
<li>mysql 有两种排序方式 全字段排序和 rowid 排序，mysql 的设计思想是，如果内存够，就要多利用内存，尽量减少磁盘访问</li>
<li>rc 模式下 for update 对所有行加了 X 锁 没有上 gap 锁 rr 模式下，也加了 X 锁</li>
<li>幻读是指一个事务在前后两次查询同一个范围的时候，后一次查询到了前一次没看到的行</li>
<li>加上 forupdate 是当前读</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45-2</title>
    <url>/2019/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql45%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><ul>
<li>mysql 里面的锁可以大致分成全局锁，表级锁和行锁</li>
</ul>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁对整个数据库实例加锁<br>Flush tables with read lock(FTWRL)<br>当使用这个命令后，其他线程的一下语句会被阻塞：数据更新语句，数据定义语句和更新类事务的提交语句<br>典型使用场景是做全局逻辑备份</p>
<ul>
<li>主库上备份，业务会停摆</li>
<li>从库上备份，备份期间不能执行主库同步过来的 binlog，导致主从延迟<br>官方自带的逻辑备份工具是 mysqldump，当使用参数-single-transaction 的时候，导数据之前就会启动一个事务，确保拿到一致性视图</li>
<li>myisam 不支持事务的引擎，这时就需要使用 FTWRL</li>
<li>不建议使用 set global readonly = true</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>lock tables … read/write<br>可以使用 unlock 主动释放，也可以在客户端断开的时候自动释放</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><ul>
<li>MyiSAM 把表的总行数存在了磁盘上，因此效率很高</li>
<li>innodb 需要一行一行统计</li>
<li>在保证逻辑正确的前提下 尽量减少扫描的数据量 是数据库系统设计的通用法则之一</li>
<li>show table status 返回很快 但是不准确</li>
<li>innodb 可以将计数保存到一张表中，使用事务，保持了一致性</li>
<li>count(id) innodb 会遍历整张表，把每一行的 id 都取出来，返回给 server 层，server 层拿到 id 后，判断是不可能为空的，就按行累加</li>
<li>count(1) innodb 引擎便利整张表，但不取值，server 层对返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加</li>
<li>count(字段)<ul>
<li>如果是 not null 就一行行独读出，判断不能为 null，按行累加</li>
<li>如果允许为 null，不是 null 才累加</li>
</ul>
</li>
<li>count(*)做了优化，按行累加</li>
</ul>
<h4 id="答疑-1"><a href="#答疑-1" class="headerlink" title="答疑 1"></a>答疑 1</h4><ul>
<li>insert on duplicate 确保了在事务内部，执行 SQL 后占住了这个行锁</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle复习考点</title>
    <url>/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle%E5%A4%8D%E4%B9%A0%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<p>大三数据库考试前记的考点</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><ul>
<li>修改密码 alter user identified by 123456;</li>
<li>解锁用户 alter user scott account unlock;</li>
<li>用户登录 connect 用户名/密码</li>
<li>修改 sqlplus 默认命令提示符 set sqlprompt jieziSQL&gt;</li>
</ul>
<h2 id="sqlplus-基本命令"><a href="#sqlplus-基本命令" class="headerlink" title="sqlplus 基本命令"></a>sqlplus 基本命令</h2><ul>
<li>show user 显示当前用户</li>
<li>select * from tab 当前用户下的表和视图</li>
<li>set linesize 150 设置行宽</li>
<li>col ename for[mat] a10 设置列宽</li>
<li>set pagesize 30 设置页大小</li>
<li>set newpage 5 设置一页中空行的数量</li>
<li>define 定义变量</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lj<span class="operator">&gt;</span><span class="keyword">define</span> var <span class="operator">=</span> &quot;test&quot;;</span><br><span class="line">lj<span class="operator">&gt;</span><span class="keyword">define</span> var;</span><br><span class="line"><span class="keyword">DEFINE</span> VAR	       <span class="operator">=</span> &quot;test&quot; (<span class="type">CHAR</span>)</span><br></pre></td></tr></table></figure>
<p>save,get,/,start,@</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> myemp;</span><br><span class="line">save o1;    <span class="operator">/</span><span class="operator">/</span> 保存到o1.sql</span><br><span class="line"><span class="keyword">get</span> o1; <span class="operator">/</span><span class="operator">/</span> 显示o1.sql</span><br><span class="line"><span class="operator">/</span>   <span class="operator">/</span><span class="operator">/</span> 执行上一条<span class="keyword">sql</span>命令</span><br><span class="line"><span class="keyword">start</span> o1;  <span class="operator">/</span><span class="operator">/</span> 执行方式<span class="number">1</span></span><br><span class="line"><span class="variable">@o1</span> <span class="operator">/</span><span class="operator">/</span> 执行方式<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>numformat<br>有如下占位符<br><em> 9 对应数字存在则显示，如果位数不足会显示乱码，如 56 在 999 掩码下会乱码
</em> 0 对应数字不存在补 0<br><em> $ 添加美元符号
</em> S 强制显示符号，正数会显示+ * , 对应位置添加,</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> numformat $<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999.00</span></span><br></pre></td></tr></table></figure>
<p>desc</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> dba_tablespaces;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 在查询过程中使用</span><br><span class="line"> <span class="keyword">select</span> empno,ename,</span><br><span class="line"> #<span class="keyword">desc</span> job</span><br><span class="line"> job <span class="keyword">from</span> emp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>spool<br>spool filename [create | replace | append] 可使用简写 cre 新建 rep 替换 app 追加<br>spool out | off 关闭 spool 输出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lj<span class="operator">&gt;</span>spool <span class="operator">/</span>home<span class="operator">/</span>jiezi19971225<span class="operator">/</span><span class="keyword">result</span> app;</span><br><span class="line">lj<span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line">lj<span class="operator">&gt;</span>spool off;</span><br></pre></td></tr></table></figure>
<p>ed[it] filename<br>上一条执行的 SQL 或者 PL/SQL 执行完毕后，可以用该命令编辑<br>col[umn]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lj<span class="operator">&gt;</span> col ename heading 姓名;</span><br><span class="line">lj<span class="operator">&gt;</span> col comm <span class="keyword">null</span> <span class="keyword">empty</span>; <span class="operator">/</span><span class="operator">/</span> 该列<span class="keyword">null</span>值显示为设定的字符串</span><br><span class="line">lj<span class="operator">&gt;</span>col sal off;</span><br><span class="line">lj<span class="operator">&gt;</span>col job justify [<span class="keyword">left</span><span class="operator">|</span>center<span class="operator">|</span><span class="keyword">right</span>];</span><br><span class="line">lj<span class="operator">&gt;</span>col job [print<span class="operator">|</span>noprint]; <span class="operator">/</span><span class="operator">/</span> 控制是否显示该列</span><br><span class="line">lj<span class="operator">&gt;</span>col job [wrapped<span class="operator">|</span>word_wrapped]; <span class="operator">/</span><span class="operator">/</span> 按照长度、单词折行</span><br></pre></td></tr></table></figure>
<p>ttitle 和 btitle</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lj<span class="operator">&gt;</span>ttitle <span class="keyword">left</span> 我是表头标题  <span class="operator">/</span><span class="operator">/</span> 参数可选<span class="keyword">left</span> center <span class="keyword">right</span> col n(在第n列打印)  <span class="keyword">skip</span> n (跳到下一行开始的第几行) bold 以黑体打印 可以使用变量</span><br><span class="line">lj<span class="operator">&gt;</span>btitle <span class="keyword">left</span> 我是表尾标题</span><br><span class="line">lj<span class="operator">&gt;</span>btitle [<span class="keyword">on</span><span class="operator">|</span>off] 切换显示</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用变量</span><br><span class="line">lj<span class="operator">&gt;</span><span class="keyword">define</span> varT<span class="operator">=</span><span class="string">&#x27;table header&#x27;</span></span><br><span class="line">lj<span class="operator">&gt;</span>ttitle <span class="keyword">left</span> varT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置空白行数为 4</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">new</span> page <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="用户管理与权限分配"><a href="#用户管理与权限分配" class="headerlink" title="用户管理与权限分配"></a>用户管理与权限分配</h2><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> user_name [identified <span class="keyword">by</span> pass_word <span class="operator">|</span> identified exeternally]</span><br><span class="line"><span class="keyword">default</span> tablespace uses</span><br><span class="line">temporary tablespaces temp</span><br><span class="line">quota <span class="number">10</span>m <span class="keyword">on</span> tbsp_1;   <span class="operator">/</span><span class="operator">/</span> 置顶用户在tbsp_1表空间最多可使用的大小为<span class="number">10</span>MB</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> user_name [cascade]; <span class="operator">/</span><span class="operator">/</span> 如果用户包含数据库对象必须加cascade</span><br></pre></td></tr></table></figure>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>如果不知道权限，可以 select * from system_privilege_map where privilege_name = ? 进行模糊查找</p>
<h2 id="概要文件"><a href="#概要文件" class="headerlink" title="概要文件"></a>概要文件</h2><p>概要文件：<br>是一个命名的资源限制的集合。系统资源的使用、口令的限制。<br>创建：</p>
<p>create profile 概要文件名 limit<br>sessions_per_user : 限制用户当前会话的数量<br>cpu_per_session： 限制一个会话使用的 cpu 时间<br>cpu_per_call ：限制一个 sql 语句使用的 cpu 时间<br>logical_reads_per_session：限制每个会话读取的数据库数据块数，包括从内存和磁盘读取的总和<br>logical_reads_per_call：限制 sql 语句读取的数据库数据块数，包括从内存和磁盘读取的总和<br>private_sga ：sga 中私有区域的大小<br>connect_time ：指定一个会话连接到数据库的最大时间<br>idle_time default：指定一个会话可以连续空闲的最长时间，单位：分钟<br>composite_limit：设置用户对系统资源的综合消耗。由： cpu_per_session、logical_reads_per_session、private_sga、connect_time 综合决定<br>failed_login_attempts: 最大错误登录次数<br>password_lock_time:登录失败后账户被锁天数<br>password_life_time:密码有效天数<br>password_grace_time：用户密码被中止前多少天提醒用户修改密码<br>password_reuse_time：用户修改密码后多少天，用户才可以再次使用原来的密码<br>password_reuse_max：密码被重新使用后，可修改的次数<br>password_verify_function：密码复杂度审计函数</p>
<p>修改：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> profile 概要文件名 limit </span><br><span class="line">sessions_per_user <span class="number">20</span></span><br><span class="line">failed_login_attemps <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> profile 概要文件名；</span><br></pre></td></tr></table></figure>
<p>说明：<br>一个用户所使用的概要文件被删除，则此用户使用默认的概要文件。<br>使某个用户使用某个用户配置文件<br>aler user 用户名 profile 概要文件名;<br>要使上面的限制生效，需要修改初始化参数 resource_limit<br>alter system set resource_limit=true;(11g)</p>
<h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> jiezi19971225 identified <span class="keyword">by</span> <span class="number">123456</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>switch虚拟系统折腾记录</title>
    <url>/2021/07/28/%E6%9D%82%E9%A1%B9/switch%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>我的 switch 是我在上大三的时候，也就是 19 年上半年吧，买的可以软破的机器，然后自己折腾的破解。我是一个 JRPG 的爱好者，当时买 switch 的首要原因就是特别想玩它上面独占的八方旅人，其二就是当时还没发售的火纹新作，对塞尔达野吹倒是很无感。不得不说，折腾破解的过程还是很有趣的，去各种资源站，论坛下游戏的过程也很有趣，但是自己却很难再静下心去打通一款游戏了，可能确实是老了。之后很长一段时间，我都认为打游戏这种毫无产出的行为，是在浪费时间，这导致我的 switch 吃灰了很长时间。至今为止，switch 上我还没有打通任何一款游戏。</p>
<p>但是最近又心血来潮，想着把 switch 上的八方旅人打通，再尝试一下勇气默示录 2。大学的时候因为穷，给 switch 只配了 64gb 的内存卡，这让我折腾 switch 一直面临着严重的容量焦虑，有时想安装点新游戏，就必须删掉一些其他游戏，好不自在。<br>我想升级内存卡很久了，之前一直觉得反正也不怎么玩了，就一直没换。但是现在又有玩游戏的想法了，还是要提升一下体验的。<br>我的 switch 破解是大气层单系统破解。现在主流的破解方式都是制作虚拟系统，这个虚拟系统是独立于 switch 本机系统的。可以自由选择启动 switch 本机系统或者虚拟系统，可以在 switch 本机系统中玩正版游戏联网，在虚拟系统中玩学习版的游戏，虚拟系统可以随意折腾，挂掉了重新安装即可，总之优点多多。趁这次机会，我准备把破解方式也升级成虚拟系统的方式。</p>
<p>因此这次折腾要完成以下内容</p>
<ul>
<li>首先买一张内存卡，容量要大大大</li>
<li>将游戏从之前的内存卡迁移到新内存卡</li>
<li>新的内存卡上创建虚拟系统</li>
<li>升级虚拟系统的系统版本</li>
</ul>
<h3 id="动手之前的情况"><a href="#动手之前的情况" class="headerlink" title="动手之前的情况"></a>动手之前的情况</h3><ul>
<li>机器是软破机，大气层版本 0.10.4</li>
<li>switch 系统版本 10.0.3，之前有过几次升级，使用的是大白兔的离线免熔断升级</li>
</ul>
<h3 id="计划实施"><a href="#计划实施" class="headerlink" title="计划实施"></a>计划实施</h3><ul>
<li>首先是内存卡，最后买了闪迪 200G a1，这样除去虚拟系统的 30G，尚有 100 多 G，足够我用了。闲鱼 120 元购得</li>
<li>将原内存卡所有内容到新内存卡，新内存卡插入 swtich，可以正常启动大气层，并且游戏都在</li>
<li>之后看教程进行虚拟系统的创建，这里强力推荐下公众号鹿枫堂游戏分享，无论是破解教程，还是游戏下载，在这个公众号里都能找到</li>
<li>重启 switch 进入 rcm 模式，创建虚拟系统 emummc，等待几分钟创建完毕，然后设置虚拟系统为启用状态</li>
<li>然后升级大气层，用电脑读取内存卡，将大气层相关的文件删除，其中 atomosphere/contents 文件夹和 switch/checkpoint/saves 文件夹需要备份，之后将最新版的大气层文件拷贝到 sd 卡中，大气层升级完成</li>
<li>重启 switch，这时候查看系统版本，发现带有后缀 E，说明当前启动的是虚拟系统</li>
<li>升级 switch 系统，首先在公众号里面下载最新的固件包，将固件包拷贝到内存卡中，启动 switch，进入相册使用 daybreank 进行系统升级</li>
<li>switch 再次重启后，虚拟系统的版本已经更新</li>
</ul>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>上述操作搞定后，进入 switch，发现之前 switch 内存卡中的游戏全部丢失，点击系统找不到数据文件，需要重新安装。还好游戏的 nsp 文件我都还保存着，于是重新安装了一遍，安装完进入游戏，存档还在，可以接受。<br>之后才知道虚拟系统默认在 SD00 文件夹内，该文件夹内有一个 <strong>emummc.ini</strong> 的配置文件，里面可以配置 nintendo 文件夹的路径，而这个文件夹就是游戏文件所在的文件夹</p>
<p>我备份了 atomosphere/contents 文件夹，拷回新内存卡后，大气层启动报错，无奈只好放弃这些备份的还原。这个文件夹主要是一些汉化和金手指，我也不怎么用这些，所以影响不大。感觉可能是因为没有配置 nintendo 文件夹路径，没有找到对应游戏安装位置的原因。</p>
]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title>win11升级记录</title>
    <url>/2021/10/21/%E6%9D%82%E9%A1%B9/win11%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>微软在今年宣布推出了 windows 的下一代操作系统 windows 11。说好的 win10 是最后一代 windows 操作系统呢？6 月微软就放出了预览版，不过我没有第一时间升级。依稀记得 win10 是在我高中的时候推出的，我也是第一时间给我的电脑装上了 win10，那个时候我还没怎么接触 linux，甚至觉得 win10 是我见到过的最酷的操作系统了(lll ￢ ω ￢)。不过后来微软在对开发者友好上确实做的不错，推出了新的 windows terminal，官方的包管理器等，docker 等软件也对 win10 有了更好的支持，win10 作为开发环境也挺省心的。</p>
<p>10 月 5 日，微软发布了 win11 的正式版，win10 可以无损免费升级到 win11。于是我花了半天的时间折腾了以下，成功将系统升级为 win11，这里记录一下过程。</p>
<h4 id="win11-升级要求"><a href="#win11-升级要求" class="headerlink" title="win11 升级要求"></a>win11 升级要求</h4><p>忽略硬件要求，主要就这两项</p>
<ul>
<li>开启 tpm2.0</li>
<li>开启安全启动<br>我的平台是 b450m + ryzen r7-2700，硬件上肯定是达标的，这两项技术也支持，可能需要调整的是 bios 的设置</li>
</ul>
<h4 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h4><p>首先下载微软官方的 <a href="https://www.microsoft.com/en-us/software-download/windows11">win11 升级助手</a></p>
<p>还需要下载 <a href="https://www.microsoft.com/zh-cn/windows/windows-11#pchealthcheck">windows 健康检查应用</a></p>
<p>运行 windows 健康检查应用，发现不满足 tpm 和 安全启动的条件。<br>进入 bios 发现 tpm 可以开启，安全启动必须关闭 scm support 才出现相应选项</p>
<p>原来我之前的系统还是使用 mbr 方式引导的，而安全启动要求必须以纯 ufei 方式启动，因此我需要将引导方式从 mbr 转变为 gpt。</p>
<p>其实也不麻烦，有现成的工具可用，下载一个傲梅分区助手，对系统盘进行 mbr 转 gpt 的操作，等它帮你慢慢操作就行了，自己玩玩手机，半小时就搞定了，很稳。</p>
<p>之后再进 bios 开启安全启动。这时候进入系统，运行健康检查，发现满足升级条件，此时打开升级助手，就可以开始下载升级文件了。之后就是等待就好了。</p>
<p><img src="/2021/10/21/%E6%9D%82%E9%A1%B9/win11%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/win11.png" alt="win11"></p>
<p>升级成功！其实感觉就是 win10 换了个皮肤。图标的风格更加扁平与圆润。底部栏与开始菜单移到了中间，肉眼可见的所有东西都加上了圆角。我不懂设计，说不出个所以然来，win11 有啥优点暂时也体验不出来，就当换个皮肤了，先用着吧 O(∩_∩)O。</p>
]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>时区问题踩坑</title>
    <url>/2021/02/21/%E6%9D%82%E9%A1%B9/%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p>今天被时区的问题困扰了好久，踩了不少坑，在此记录一下。</p>
<h3 id="go-中的时区"><a href="#go-中的时区" class="headerlink" title="go 中的时区"></a>go 中的时区</h3><p>go 中 time.Now() 取的是系统的时区。</p>
<p>time.parse 默认采用的是 UTC 时间进行解析，UTC 时即世界协调时间。</p>
<p>我们中国使用的北京时间是东八区时间，领先了 UTC 八个小时。</p>
<p>举个例子，现在是北京时间 2021/2/21 15:00:00，用 time.parse 解析得到的时间 2021/2/21 15:00:00 +0:00，而这个解析到的时间对应到北京时间是 2021/2/21 23:00:00 +8:00</p>
<p>time.Now() 取到的系统时间是 2021/2/21 15:00:00 +8:00，这种情况下做时间的比较，是无法得到正确的结果的，同时如果使用 gorm 等事件保存到数据库中，保存的时间也是比正确的时间晚了 8 小时的。</p>
<p>所以应当使用 time.parseInLocation</p>
<h3 id="容器中的时区"><a href="#容器中的时区" class="headerlink" title="容器中的时区"></a>容器中的时区</h3><p>使用 docker-compose，可以设置 environment 中的 TZ 设置时区，前提是镜像中安装了 tzdata 这个软件。如果没有，设置时无法生效的。</p>
<h3 id="mysql-中的时区"><a href="#mysql-中的时区" class="headerlink" title="mysql 中的时区"></a>mysql 中的时区</h3><p>默认会采用系统时区，可以在 my.cnf 中手动设置默认的时区。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深圳游记-深圳湾公园与世界之窗</title>
    <url>/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>大学开始，慢慢养成了记录技术类博客的习惯，当然这也是比较实用主义的做法，因为接触的知识真的很多，如果不记录下来，过一段时间就是忘光光了，这也就是知识管理的重要性。</p>
<p>但是生活其实也并不只是工作学习，并且随着年龄的增长，我越来越感觉到时间的珍贵，对于逝去的时间，如果不记录些什么，就感觉白白浪费了。所以也想要尝试记录生活，留住感动，去抓住逝去的时光。今后的话，大概会写一些出去玩的游记和游戏记录相关的内容吧。另外本人的文笔不好，希望也可以慢慢练习吧。</p>
<h3 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h3><p>作为一个平日深居简出的宅宅，其实出去玩对我是没有什么吸引力的。之前在杭州实习，呆了几个月，甚至都没有去西湖走一遭，现在感觉还是挺遗憾的。说实话，这次出去很大一个原因是怕万一别人问起我春节不回家去了哪里玩，如果说一直霉在出租屋里，总感觉不太好。本来计划着初三出去的，显然我丝毫没有意识到初三是情人节的事实，这出去还不被虐成狗啊。初三是出去不成了，初四又是慵懒的一天，就这样拖到了初五，下定决心一定要出去了，在网上搜深圳有哪些好玩的地方，然后想起之前同事跟我提过可以去深圳湾公园，地铁直达的样子，搜了一下，感觉靠谱，出发！</p>
<h3 id="深圳湾公园"><a href="#深圳湾公园" class="headerlink" title="深圳湾公园"></a>深圳湾公园</h3><p>从塘朗地铁站出发，经过两次转线，大约历时一个小时，到达 9 号线深圳湾公园站。深圳湾这块绝对是个游玩的胜地，光是地铁站的出口有好几个，分别去往不同的地方。去往深圳湾公园的出口沿着扶梯上去，就来到了公园的门口。意外的是人是挺多的，远远望去都是人，除了必须要带上口罩外，完全看不到疫情带来的影响。</p>
<p>来了公园这边，想做的事情当然就是看海了。想到跟大海零距离接触，虽然说不上激动，但是对于我这个在内陆地区长大的人来说，这种感觉还是挺奇妙的。</p>
<p>之前跟同事聚餐完后一个人跑到人才公园那边感受了一下，看到的是深圳这座大都市海滨的华灯璀璨，让我不禁感慨这才是深圳该有的样子。</p>
<p>在 B 站视频里见过的深圳湾地标-春笋。</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/春笋.jpg" alt="春笋"></p>
<p>夜景</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/深圳湾夜景.jpg" alt="深圳湾夜景"></p>
<p>但是在深圳湾公园这边，感受到的则是一种宁静。看着大海的浪潮起伏，感受着湿润的海风朝自己扑来，最惊喜的是可以“文明观鸟”。</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/文明观鸟.jpg" alt="文明观鸟"></p>
<p>在最靠近这群海鸟的地方，有几个人用装着半米长镜头的相机在拍摄，真是专业的不行，海岸边有公园的工作人员举着宣传语，让人们“文明观鸟”，不要擅自给海鸟喂食，人们无知善意的举动，实际上是可能伤害它们的。</p>
<p>公园绵延海岸线十几公里，我从入口一路往东走，就到了红树林，这边的海岸是生长着红树林的湿地，这边的滩涂上，有那种一跳一跳的鱼，不时会有几只一跃而起，很是神奇。</p>
<p>就这样沿着海岸线走着走着，想到既然来了，晚上去再去别的地方玩玩好了。本来是想要去民俗村的，但是订票的时候显示票已售罄的。看到世界之窗也在附近，看评价似乎挺好，于是就定了夜场的票。订票的时候已经是 5 点了，6 点是夜场入门的时间，在公园又溜了一会后，我决定步行前往。但是这里我犯了一个错误，我没有用地图的导航功能，我从公园的出口出来了，想要过马路到对面，但是实际上这里必须走地铁的地下通道才能过去，绕了一大圈，花了不少时间，还是骑单车在 6 点半的时候赶到了入口。</p>
<h3 id="世界之窗"><a href="#世界之窗" class="headerlink" title="世界之窗"></a>世界之窗</h3><p>公园的入口处，是巴黎卢浮宫的微型仿制建筑，上面有江泽民主席的题字，看到这个，真的忍不住要膜一下。</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/世界之窗.jpg" alt="世界之窗"></p>
<p>深圳是中国向世界开放的窗口，世界之窗这个主题公园里，浓缩了世界著名的景观，也是中国人认识世界的一个窗口。</p>
<p>入园后，我突然意识到了一个问题，几乎所有的游客，要么就是家长带小孩，要么就是情侣一起，最次也是几个好哥们同行，似乎只有我是一个人来玩的。不过好在我内心还是很强大的，即使是一个人，来感受下氛围也好，毕竟钱都已经花了。当然有了这次的前车之鉴，下次我是绝对不会再一个人来这种主题公园了。。。</p>
<p>公园的正中心是缩小版的埃菲尔铁塔，然后分为东西两边两大块区域。</p>
<h4 id="东区"><a href="#东区" class="headerlink" title="东区"></a>东区</h4><p>我一开始去了东边。地图标注一些的景观，实际上都只是这种微缩的模型，比如下面的天皇居所，还有泰姬陵，一开始让我感觉略微有点失望，就这？</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/天皇の住居.jpg" alt="天皇の住居"></p>
<p>然后，再走不远就到了日本主题的地区。这里有租借和服的，我看到有小姐姐租借了穿的，是真的好漂亮，我要是女生也真的好想穿上试试。</p>
<p>日本馆的和风是很有味道的<br><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/日本馆.jpg" alt="日本馆"></p>
<p>这个富士山就挺让人一言难尽的<br><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/富士山.jpg" alt="富士山"></p>
<p>逛完了这里，天色已经暗了下来了，这些景观的观看效果大大打了折扣。东区的话，还有东南亚，欧洲和大洋洲的景观。下面是科隆大教堂，历史上这座教堂断断续续修了几百年，是天主教最著名的几座教堂之一，即使只看模型，也还是能被他的宏伟震撼。只是这里的灯光，把它变得有点魔幻。。。</p>
<p><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/科隆大教堂.jpg" alt="科隆大教堂"></p>
<p>凯旋门，拿皇万岁！<br><img src="/2021/02/18/%E6%B8%B8%E8%AE%B0/%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0-%E6%B7%B1%E5%9C%B3%E6%B9%BE%E5%85%AC%E5%9B%AD%E4%B8%8E%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97/凯旋门.jpg" alt="凯旋门"></p>
<p>差不多逛完了东区，已经快要 7 点了，这时我才知道，景区的一些免费项目是有开放时间限制的。之前在网上了解的像飞跃美利坚之类的必玩项目，7 点就结束了，后悔自己没有多做点功课了。</p>
<p>这个时候，人都在往中心的埃菲尔铁塔赶了。这里 7 点 15 会有灯光秀的表演，在表演开始之前，这里有几个演员穿着奇异的装束在这里打鼓，我是真的不知道他们打扮的是啥东西，只是想感叹钱难挣啊，这么打扮我感觉是挺难受的。</p>
<p>灯光秀准时开始，配合这恢弘的 BGM，效果还是很震撼的，但是时间嘛比较短，大概 5 分钟就结束了，让人有点意犹未尽。</p>
<h4 id="演出盛世纪"><a href="#演出盛世纪" class="headerlink" title="演出盛世纪"></a>演出盛世纪</h4><p>7 点 30 在中心的广场有歌舞剧演出，我到的时候，外场中间的位置已经坐满了（内场是额外花钱的）。我只能在边界找了个位置坐下，角度可以说非常差了。</p>
<p>歌舞剧把中国上下五千年的文化浓缩到了一台歌舞剧中，从后羿射日，到春秋战国，再到大汉王朝，再到大唐盛世。大秦的部分确实把秦军的气势展现了出来，大汉王朝则是把汉的儒学文化和张骞通西域的开放包容展现了出来，大唐的部分更是分成了四幕，从盛世长安到雪域高原。<br>刚开始看的确实挺震撼的，但是看多了，要么是一群男的舞刀弄枪，要么是一群女的在哪里跳舞，要么是几个外国人上来耍耍鞭子流星锤啥的，就有点审美疲劳了。渐渐的外场的人走的越来越多，内场的人倒是没见有走的，毕竟是花钱了的 😄。我是看到了郑和下西洋那一幕，觉的没啥意思了，就溜了。</p>
<h4 id="外籍演员演出"><a href="#外籍演员演出" class="headerlink" title="外籍演员演出"></a>外籍演员演出</h4><p>这之后我本来是打算赶快把西区逛一逛的，刚向西没过多久，就看到路上的人都在往中间赶，原来是有烟花的演出。现在春节都是禁止燃放烟花了，能看到烟花演出，确实不容易的，我也就跟着也往中间跑去了，可等待感到了中间，烟花都已经放完了，算了，就是感受个氛围吧。</p>
<p>到了中间，听到广播在说 9 点 15 凯撒宫那边会有梦幻欧洲灯光表演，人群都在往凯撒宫那边去，我也就跟着过去了。我跟着人群进到了宫殿内部，这里其实是一个剧场，我刚开始挺怀疑的，这里也能有灯光表演吗？等到了 9 点 15，表演也没有开始，然后挺广播才知道，这里面要开始的是一个外籍演员的专场演出，灯光表演是在外面。不过既然在里面坐下了，我也就等到它的演出开始了。</p>
<p>整场演出十分精彩，印象最深的是里面肯尼亚黑人表演的杂技，看了除了牛逼想不出别的词语来形容了。这些黑人演员的力气和胆子是真的大，各种杂技动作难度非常之高。最吸引研究的就是里面的毛妹了，有大毛也有二毛，有一说一，确实都是大美人，身材也都是顶级的。感觉整场演出里俄罗斯的人最多，为什么他们要跑来深圳打工呢，因为俄罗斯经济不景气吗？最后是小丑的滑稽剧表演，小时候看央视的正大综艺看过这种表演，在现场看这种演示还是生平第一次，最后也是在一片欢乐祥和中结束了整场演出。</p>
<h4 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h4><p>看完演出已经 10 点了，显然已经没有时间再去西区了，想想是挺遗憾的。不过生活嘛，本来就是充满遗憾的，这次来本来就挺仓促的，一个人的话，甚至不能好好拍点照片留念，不过我是觉得已经体验到挺多了，以后如果有机会，再和朋友好好玩一次吧。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我是在开工前的夜晚赶出来的这篇游记。我在这段时间一直被焦虑的情绪困扰，这次出来玩了一趟过后，确实轻松了不少。长假已经过去，是时候收拾好心情，迎接年后的新的工作挑战了。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/03/24/%E7%AE%97%E6%B3%95/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>因为看编译原理的有穷自动机，想到了以前一直不懂的这玩意。既然都叫自动机，就一块研究了吧。</p>
<p>AC 自动机是一种实现多模式匹配的字符串匹配算法。</p>
<h2 id="前置技能-Trie-树（字典树）"><a href="#前置技能-Trie-树（字典树）" class="headerlink" title="前置技能 Trie 树（字典树）"></a>前置技能 Trie 树（字典树）</h2><p>字典树是一颗树，能迅速匹配字典中的字符串。<br>它具有以下基本性质。</p>
<ul>
<li>根节点不包括字符串，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
<p>他的节点结构如下，其中 exist 标记当前节点是否是单词的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是使用指针方式的构建代码,比较易懂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        node *next[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> exist;</span><br><span class="line">        <span class="built_in">node</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next));</span><br><span class="line">            exist = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node *root;</span><br><span class="line">    <span class="built_in">trie</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;next[num])</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next[num] = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">                cur = cur-&gt;next[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(string word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *cur = root;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;next[num])</span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;exist)</span><br><span class="line">        &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    trie t;</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;am&quot;</span>);</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    t.<span class="built_in">insert</span>(<span class="string">&quot;lvjie&quot;</span>);</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">find</span>(<span class="string">&quot;lvjie&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">find</span>(<span class="string">&quot;lvji&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">find</span>(<span class="string">&quot;i&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/24/%E7%AE%97%E6%B3%95/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/字典树.png" alt="字典树"></p>
<h2 id="利用字典树暴力求解多模式匹配"><a href="#利用字典树暴力求解多模式匹配" class="headerlink" title="利用字典树暴力求解多模式匹配"></a>利用字典树暴力求解多模式匹配</h2><p>很容易想到，从字符串的每一个字符开始，跑 Trie 的匹配算法，这样的时间复杂度是 O(len(T) * maxD(Trie)) 即字符串长度乘以字典树的深度</p>
<h2 id="KMP-的思想很重要"><a href="#KMP-的思想很重要" class="headerlink" title="KMP 的思想很重要"></a>KMP 的思想很重要</h2><p>显然，匹配失败并不需要在下一位置从 Trie 根节点开始匹配，而是应该找当前匹配的最长后缀。</p>
<p>这里引入 fail 指针的概念，表示从该节点取前缀，在字典树中找到该前缀中后缀最长的节点。<br>以下摘自洛谷日报</p>
<ul>
<li>共同点-两者同样是在失配的时候用于跳转的指针。</li>
<li>不同点-KMP 要求的是最长相同真前后缀，而 AC 自动机只需要相同后缀即可。</li>
<li>因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。</li>
<li>有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。</li>
<li>也就是说，AC 自动机在对匹配串做逐位匹配时，同一位上可能匹配多个模式串。</li>
<li>因此 fail 指针会在字典树上的结点来回穿梭，而不像 KMP 在线性结构上跳转。</li>
</ul>
<p>构建基础思想</p>
<ul>
<li>构建一个节点的 fail 指针，需要找它的父节点的 fail 指针，所以构建过程应该是一个对树 BFS 的过程</li>
<li>使用队列进行 BFS，每次取队首的节点，设为当前节点 cur，（该节点的 fail 指针已经构建），遍历它所有边，现假设有以字符 x 连接的子节点 child<ul>
<li>找当前节点 cur 的 fail 指针指向的节点是否也有以字符 x 连接的子节点，如果有，令 child 的 fail 指针指向该子节点</li>
<li>如果没有，则令 cur = cur.fail，循环这个过程，直到 cur 指向 -1</li>
</ul>
</li>
</ul>
<p>查询思想</p>
<p>构建了 ac 自动机这种结构，它的基础应用就是给你一个字符串，让你统计在这个串中出现了多少统计的单词，而这个求解过程是在 O(N) 的复杂度下完成的</p>
<p>方法很简单，维护两个指针 cur 和 pos，分别指向字典树的节点和字符串遍历位置</p>
<p>对于每个位置 pos</p>
<ul>
<li>如果当前 cur = -1，说明该字符位置无法匹配任何模式串，则令 cur = 0， pos++</li>
<li>如果当前 cur 位置的 cnt 计数不为 0，则将从该点及从该点可跳转的后缀纳入统计</li>
<li>判断当前节点有否有以字符 str[pos]连接的子节点，如果有 pos++，cur 移动到该子节点的位置</li>
<li>否则，cur 指向 cur 节点的 fail 指针的位置</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下为 luogu P3808 的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aho</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> fail, cnt;</span><br><span class="line">        <span class="built_in">node</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(next));</span><br><span class="line">            fail = cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; treeNode[maxn];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(treeNode[i].next, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(treeNode[i].next));</span><br><span class="line">            treeNode[i].fail = treeNode[i].cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!treeNode[cur].next[num])</span><br><span class="line">            &#123;</span><br><span class="line">                treeNode[cur].next[num] = ++size;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = treeNode[cur].next[num];</span><br><span class="line">        &#125;</span><br><span class="line">        treeNode[cur].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        treeNode[<span class="number">0</span>].fail = <span class="number">-1</span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode[top].next[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(treeNode[top].next[i]);</span><br><span class="line">                    <span class="keyword">if</span> (top == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        treeNode[treeNode[top].next[i]].fail = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> v = treeNode[top].fail;</span><br><span class="line">                        <span class="keyword">while</span> (v != <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (treeNode[v].next[i])</span><br><span class="line">                            &#123;</span><br><span class="line">                                treeNode[treeNode[top].next[i]].fail = treeNode[v].next[i];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                v = treeNode[v].fail;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (v == <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            treeNode[treeNode[top].next[i]].fail = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNow</span><span class="params">(<span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += treeNode[cur].cnt;</span><br><span class="line">            treeNode[cur].cnt = <span class="number">0</span>;</span><br><span class="line">            cur = treeNode[cur].fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(string target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; target.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (treeNode[cur].cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="built_in">getNow</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = target[pos] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++pos;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (treeNode[cur].next[num])</span><br><span class="line">            &#123;</span><br><span class="line">                ++pos;</span><br><span class="line">                cur = treeNode[cur].next[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = treeNode[cur].fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode[cur].cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">getNow</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来检查构建的字典树和fail指针的指向</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> v;</span><br><span class="line">            string word;</span><br><span class="line">            <span class="built_in">pair</span>(<span class="keyword">int</span> v, string word) : <span class="built_in">v</span>(v), <span class="built_in">word</span>(word)&#123;&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        queue&lt;pair&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pair</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pair top = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode[top.v].next[i])</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    string word = top.word + <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pair</span>(treeNode[top.v].next[i], word));</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;开始输出节点信息&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;当前节点为编号&quot;</span> &lt;&lt; treeNode[top.v].next[i] &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;word=&quot;</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;cnt=&quot;</span> &lt;&lt; treeNode[treeNode[top.v].next[i]].cnt &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;fail=&quot;</span> &lt;&lt; treeNode[treeNode[top.v].next[i]].fail &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;节点信息输出完毕&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;3808.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    aho a;</span><br><span class="line">    a.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        string t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a.<span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">// a.check();</span></span><br><span class="line">    string target;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">find</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法</title>
    <url>/2020/03/24/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>推荐 B 站一个 UP 的视频，讲的非常容易理解 <a href="https://www.bilibili.com/video/BV1iJ411a7Kb?p=3">链接</a></p>
<h2 id="暴力匹配思路"><a href="#暴力匹配思路" class="headerlink" title="暴力匹配思路"></a>暴力匹配思路</h2><p>设模式串为 sp，要匹配的目标字符串为 st</p>
<p>扫一遍 st，每次从 st 当前位置开始匹配 sp，这样做浪费了大量时间，之前匹配过程得到信息没有被有效利用。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="最大公共前后缀"><a href="#最大公共前后缀" class="headerlink" title="最大公共前后缀"></a>最大公共前后缀</h3><p>KMP 中为了有效利用之前已获得的信息，使用了最大公共前后缀。<br>前后缀的概念我们都知道，而公共前后缀是指该位置的前缀与后缀相同的部分。应当注意，前缀是不能包含当前位置的，而后缀不能包含第 1 个位置。<br>举个例子，ABCDABC 中，C 位置的最大公共前后缀是 ABC。<br>我们计算 AAAAB 的最大公共前后缀，使用 presuf 数组保存最大公共前后缀的长度<br>则 presuf = [0,1,2,3,0]</p>
<h3 id="KMP-算法流程"><a href="#KMP-算法流程" class="headerlink" title="KMP 算法流程"></a>KMP 算法流程</h3><h4 id="构造最大前后缀数组"><a href="#构造最大前后缀数组" class="headerlink" title="构造最大前后缀数组"></a>构造最大前后缀数组</h4><p>首先构造 presuf 数组，构造的流程如下</p>
<p>为了方便算法编写，令 presuf[0] = -1 作为边界，最大公共前后缀从 1 下标开始记录。<br>令 j 表示当前指针位置，可以理解为后缀指针，t 表示前缀指针位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = presuf[0] = -1</span><br><span class="line">m = sp.length()</span><br><span class="line">while j &lt; m-1</span><br><span class="line">    // 当前位置前后缀匹配，更新 presuf 数组</span><br><span class="line">    if t &lt; 0 || sp[j] == sp[t]</span><br><span class="line">        presuf[++j] = ++ t</span><br><span class="line">    // 当前不匹配，则应该缩小前缀的范围</span><br><span class="line">    else</span><br><span class="line">        t = presuf[t];</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/24/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95/构造过程.png" alt="构造过程"></p>
<h4 id="匹配流程"><a href="#匹配流程" class="headerlink" title="匹配流程"></a>匹配流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 0</span><br><span class="line">j = 0</span><br><span class="line">m = st.length()</span><br><span class="line">while j &lt; m</span><br><span class="line">    if i &lt; 0 || sp[i] == st[i]</span><br><span class="line">        ++i,++j</span><br><span class="line">        if i == sp.length()</span><br><span class="line">            // 得到结果</span><br><span class="line">    else</span><br><span class="line">        // 这一步也很好理解，和构造过程是一样</span><br><span class="line">        i = presuf[i]</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了便于理解，变量名都是用了更具意义的缩写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string st = <span class="string">&quot;AAAAAAAAB&quot;</span>;</span><br><span class="line">    string sp = <span class="string">&quot;AAAAB&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> presuf[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(presuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(presuf));</span><br><span class="line">    <span class="comment">// 构造过程</span></span><br><span class="line">    <span class="keyword">int</span> prep = presuf[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sufp &lt; sp.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prep &lt; <span class="number">0</span> || sp[prep] == sp[sufp])</span><br><span class="line">        &#123;</span><br><span class="line">            presuf[++sufp] = ++prep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            prep = presuf[prep];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配过程</span></span><br><span class="line">    <span class="keyword">int</span> stp = <span class="number">0</span>, spp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stp &lt; st.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (spp &lt; <span class="number">0</span> || st[stp] == sp[spp])</span><br><span class="line">        &#123;</span><br><span class="line">            ++spp, ++stp;</span><br><span class="line">            <span class="keyword">if</span> (spp == sp.<span class="built_in">length</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res = stp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            spp = presuf[spp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>KMP 算法的应用，判定一棵二叉树是否是另一颗二叉树的子树，如果这棵树的序列化字符串是另一棵树序列化字符串的子串，则可以判定。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcodeP10-RegularExpressionMatching</title>
    <url>/2019/03/24/%E7%AE%97%E6%B3%95/leetcodeP10-RegularExpressionMatching/</url>
    <content><![CDATA[<p>这一题最开始想到模拟，也想到了匹配的贪婪问题，感觉题目可能不要求那么多，结果是 WA，看到讨论区 PO 出的一份代码，使用了动态规划，想了一下确实改用 DP，此题确有一定难度，在此记录一下解法。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 s 和字符串 p，s 只包含英文小写字母，p 只包含英文小写字母和 ‘.’ 或 ‘*‘，实现一个支持元字符 ‘.’ 和 ‘*‘的正则匹配</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设 dp[x][y]表示取字符串 s 前 x 个字符和模式串 p 前 y 个字符是否能够完全匹配，为一个 bool 值<br>初始状态 dp[0][0] = true，若 p 串以”a*b*c*“的形式开头，则 dp[0][2],dp[0][4],dp[0][6]也为 true，显示这种状态是匹配的<br>dp 的转移过程为<br>若 s[i-1] == p[j-1] || p[j-1] == ‘.’，dp[i][j] = dp[i][j] || dp[i-1][j-1]<br>若 p[j-1] == ‘*‘ ，方程至多可从一下三种状态转移</p>
<ul>
<li>dp[i][j] = dp[i][j] || dp[i][j-2]，*可以匹配 0 个多个，因此总可以从该状态转移</li>
<li>若 s[i-1] == p[j-2] || int(p[j-2]) == ‘.’，即匹配 “?*“形式，可采用贪婪与非贪婪策略<ul>
<li>dp[i][j] = dp[i][j] || dp[i-1][j] ，采用非贪婪策略，*不匹配字符</li>
<li>dp[i][j] = dp[i][j] || dp[i][j-1]，采用贪婪策略，*匹配字符</li>
</ul>
</li>
</ul>
<p>以下是代码，参考了 leetcode 上的题解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lens := <span class="built_in">len</span>(s)</span><br><span class="line">    lenp := <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">var</span> dp [][]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= lens; i++ &#123;</span><br><span class="line">        d := <span class="built_in">make</span>([]<span class="keyword">bool</span>, lenp+<span class="number">1</span>)</span><br><span class="line">        dp = <span class="built_in">append</span>(dp, d)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= lenp; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= lens; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= lenp; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j] || dp[i][j<span class="number">-2</span>]</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || <span class="keyword">int</span>(p[j<span class="number">-2</span>]) == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lens][lenp]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcodeP11-ContainerWithMostWater</title>
    <url>/2019/04/20/%E7%AE%97%E6%B3%95/leetcodeP11-ContainerWithMostWater/</url>
    <content><![CDATA[<p>这道题以前做过，但是忘记怎么做的了。第一次交了一个双重循环的暴力。查看题解一下就明白了正确的贪心算法。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 N 个非负的正整数 a1,a2,a3,…an，每个代表了坐标轴上的一个点(i，ai)。n 条垂直的线连接点和 x 轴，要求找出两条线，让它们和 x 轴组成的容器的容积最大。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>正解是用两点逼近的算法。首先容器的高度是由最短的那条线决定的。<br>维护一个变量记录最大容积。记录所取的两端的端点位置，每次计算当前情况的容积，并更新最大容积。之后更新较短的那条线的端点位置(一定是更新较短的端点位置，否则容积一定小于当前容积，因为只有宽度减小)，更新方法为向另一端的方向遍历直到遇到一条比当前线高度高的线（比当前线高度低的线组成的容积一定小于当前情况的容积）。</p>
<p>以下是代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        minHeight := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            minHeight = height[left]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeight = height[right]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newArea := (right - left) * minHeight</span><br><span class="line">        <span class="keyword">if</span> newArea &gt; res &#123;</span><br><span class="line">            res = newArea</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            newLeft := left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> newLeft &lt; right &amp;&amp; height[newLeft] &lt; height[left] &#123;</span><br><span class="line">                newLeft = newLeft + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            left = newLeft</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newRight := right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> newRight &gt; left &amp;&amp; height[newRight] &lt; height[right] &#123;</span><br><span class="line">                newRight = newRight - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            right = newRight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/03/17/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉搜索树（Binary Search Tree）是一种可以在 O(logN) 复杂度做查找，插入和删除的操作。</p>
<p>二叉搜索树是一种满足以下特殊性质的二叉树。</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值</li>
<li>若右子树不空，则右子树上所有结点的值均小于或等于它的根结点的值</li>
<li>左右子树均为二叉搜索树</li>
</ul>
<p>二叉搜索树包含三种基本操作。其流程如下。</p>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><ul>
<li>若当前节点为 NULL，返回 false</li>
<li>若查找的值小于当前节点的值，则递归搜索左子树</li>
<li>若查找的值大于当前节点的值，则递归搜索右子树</li>
<li>若查找的值等于当前节点的值，则返回 true</li>
</ul>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><ul>
<li>若当前节点为 NULL，用插入的值构建新节点插入到当前位置</li>
<li>若插入的值小于当前节点的值，则在左子树上执行插入操作</li>
<li>若插入的值大于当前节点的值，则在右子树上执行插入操作</li>
</ul>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><ul>
<li>若当前节点为 NULL，返回 false</li>
<li>若删除的值小于当前节点的值，则在左子树上执行删除操作</li>
<li>若删除的值大于当前节点的值，则在右子树上执行删除操作</li>
<li>若删除的值等于当前节点的值，这里又分为多种情况<ul>
<li>若当前节点左子树为空，则直接将右子树接上来</li>
<li>若当前节点右子树为空，则直接将左子树接上来</li>
<li>否则，查找左子树中最大的值（或者右子树中最小的值），与当前节点的值进行交换，然后删除被交换的节点，这里想一下就可以明白，左子树最大的数值移动到当前节点的位置，因为它是左子树中最大的数值，所以它一定大于左子树中其他值，同时也一定小于右子树中所有值，这样操作后仍然满足 BST 的性质。</li>
</ul>
</li>
</ul>
<p>根据二叉搜索树的性质，中序遍历二叉搜索树，得到的一定是一个有序的数列。所以用二叉搜索树进行排序，时间复杂度为 O(NlogN)</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>以下内容来自洛谷日报</p>
<p>这样一种数据结构，支持找前驱与后继，还可以按排名与按数值查找</p>
<h3 id="找前驱"><a href="#找前驱" class="headerlink" title="找前驱"></a>找前驱</h3><p>所谓前驱，就是小于 x 的最大的数，所以前驱一定比 x 小<br>其实找前驱，就是从根节点开始，递归子树，如果你要找的数小于当前节点，就找他的左子树，反之找他的右子树，直到没有可以找的为止。</p>
<h3 id="按排名找值"><a href="#按排名找值" class="headerlink" title="按排名找值"></a>按排名找值</h3><p>再节点维护一个 size 信息，表示当前位置开始的树的节点数量，则找排名为 k 的节点，先看左子树的 size+1 是否大于等于 k，若大于，则在左子树中查找 排名为 k-1 的节点。否则，查询右树中排名为 k-size-1 的节点。</p>
<h3 id="按值找排名"><a href="#按值找排名" class="headerlink" title="按值找排名"></a>按值找排名</h3><p>按值找排名时，从根开始，如果该位置的值小于要查询的值，就找他的右子树，同时记住他左子树的大小，如果小于，就查询他的左子树，直到大小相等，他的排名就是该点左子树的大小加上一路上比他小的节点个数再加上 1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是 BST 基础功能的 C++ 实现的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    node *lch, *rch;</span><br><span class="line">    <span class="built_in">node</span>(T val) : <span class="built_in">val</span>(val), <span class="built_in">lch</span>(<span class="literal">NULL</span>), <span class="built_in">rch</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> node&lt;T&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bst</span>() : <span class="built_in">root</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _insert(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> _insert(node *&amp;root, <span class="keyword">const</span> T &amp;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">node</span>(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _insert(root-&gt;lch, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _insert(root-&gt;rch, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _find(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> _find(node *root, <span class="keyword">const</span> T &amp;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _find(root-&gt;lch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _find(root-&gt;rch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _remove(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> _remove(node *&amp;root, T val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _remove(root-&gt;lch, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _remove(root-&gt;rch, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;lch == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node *del = root;</span><br><span class="line">                root = root-&gt;rch;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;rch == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node *del = root;</span><br><span class="line">                root = root-&gt;lch;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找右子树中值最小的</span></span><br><span class="line">                node *rightMin = root-&gt;rch-&gt;lch;</span><br><span class="line">                <span class="keyword">while</span> (rightMin)</span><br><span class="line">                &#123;</span><br><span class="line">                    rightMin = rightMin-&gt;lch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 交换之后，右子树仍然满足 bst 性质</span></span><br><span class="line">                <span class="built_in">swap</span>(root-&gt;val, rightMin-&gt;val);</span><br><span class="line">                _remove(root-&gt;rch, rightMin-&gt;val);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _output(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> _output(node *root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _output(root-&gt;lch);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span><br><span class="line">        _output(root-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bst&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    b.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    b.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础之图中找环</title>
    <url>/2019/05/11/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/</url>
    <content><![CDATA[<p>对于有向图而言 可以使用拓扑排序的方式找出图中的环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> du[maxn];<span class="comment">//入度</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    du[b]++;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[temp].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = gra[temp][i];</span><br><span class="line">            du[to]--;</span><br><span class="line">            <span class="keyword">if</span>(!du[to])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图 可以采用并查集的方式，在读边的时候，如果两个顶点在同一个集合中，说明构成了环，这时令这两个顶点作为起点和终点，深搜一下输出路径即可</p>
<p>蓝桥杯 2017 国赛 c++b 组 t4 找环</p>
<p>题意：</p>
<p>编号为 1 到 n 的 n 个点，以及 n-1 条边构成一棵树。现在在树上加上一条边，这样就构成了一个含环的图了。请你找出该环上的结点，从小到大输出这些结点编号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e+7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x]==x?x:p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    p[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    gra[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    gra[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s,e;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> path[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">            path[to] = x;<span class="comment">// 记录路径</span></span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(to == e)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(path));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> aa = <span class="built_in">find</span>(a),bb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(aa!=bb)&#123;</span><br><span class="line">            <span class="built_in">unit</span>(a,b);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 说明构成了环</span></span><br><span class="line">            s = a,e = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(s);</span><br><span class="line">    <span class="keyword">int</span> temp = e;</span><br><span class="line">    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">while</span>(path[temp])&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path[temp]);</span><br><span class="line">        temp = path[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以采用深搜的方式，首先需要了解</p>
<p>在图的遍历中，往往设置了一个标记数组 vis 来记录顶点是否被访问过。但有些时候需要改变 vis 值的意义。令 vis 具有 3 种值并表示 3 种不同含义</p>
<p>vis = 0,表示该顶点没没有被访问<br>vis = 1,表示该顶点已经被访问，但其子孙后代还没被访问完，也就没从该点返回<br>vis = 2,，表示该顶点已经被访问，其子孙后代也已经访问完，也已经从该顶点返回<br>可以 vis 的 3 种值表示的是一种顺序关系和时间关系</p>
<p>《算法导论》334 页有这 4 种边的准确定义</p>
<p><img src="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%AD%E6%89%BE%E7%8E%AF/边的定义.png" alt="边的定义"></p>
<p>DFS 过程中，对于一条边 u-&gt;v<br>vis[v] = 0,说明 v 还没被访问，v 是首次被发现，u-&gt;v 是一条树边<br>vis[v] = 1,说明 v 已经被访问，但其子孙后代还没有被访问完（正在访问中），而 u 又指向 v，说明 u 就是 v 的子孙后代，u-&gt;v 是一条后向边，因此后向边又称返祖边，<br>vis[v] = 2,说明 v 已经被访问，其子孙后代也已经全部访问完，u-&gt;v 这条边可能是一条横叉边，或者前向边</p>
<p>注意：树边，后向边，前向边，都有祖先，后裔的关系，但横叉边没有，u-&gt;v 为横叉边，说明在这棵 DFS 树中，它们不是祖先后裔的关系它们可能是兄弟关系，堂兄弟关系，甚至更远的关系，如果是 dfs 森林的话，u 和 v 甚至可以在不同的树上</p>
<p>对于无向图而言，只存在树边和返祖边，当发现一条返祖边时，说明找到了环，这时输出所有 vis[i] = 1 的节点即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    gra[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">()</span></span>&#123;  <span class="comment">// 找环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to,x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(to!= p &amp;&amp; vis[to])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">findp</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">addedge</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>左偏树</title>
    <url>/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<p>最后一篇以前写的文章了，</p>
<p>左偏树是一种实现简单的可并堆，可以在 logn 的复杂度下面完成优先队列的插入，删除，合并操作。</p>
<p>这就是一颗左偏树啦 蓝色是该节点的 dist</p>
<p><img src="/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%A6%E5%81%8F%E6%A0%91/左偏树.png" alt="左偏树"></p>
<p>结构体定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,v;<span class="comment">//左右子树，距离和键值</span></span><br><span class="line">    <span class="built_in">Node</span>()&#123;</span><br><span class="line">        l=r=v=d=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义左偏树的外界点为，一个左子树为空或者一个右子树为空的结点，结点的 dist 为它到它子树内外节点的最短距离。一个左偏树在满足堆的性质的前提下还应该满足它的右子树的 dist 不大于它的左子树的 dist。由此，我们可以得出其他一些性质。</p>
<p>当前结点的 dist 为右子树 dist 的长度+1<br>若左偏树根节点的 dist 为一定值，则节点数最少的左偏树是一颗完全二叉树，并且为满二叉树<br>由上一条性质，可以知道根节点 dist 为 n 的左偏树，最少含有 2n+1−12n+1−1 个结点<br>一个有 n 个结点的左偏树，根节点距离最大为|log2（n+1）|−1|log2（n+1）|−1<br>左偏树的操作（最大堆）</p>
<p>递归合并<br>如果有一颗树为空，返回另一棵树<br>否则，就将根节点键值较大树的右子树和根节点键值较小树合并<br>如果合并后破坏了左偏树的性质（左子树 dist&lt;右子树 dist）<br>交换根节点的左右子树<br>更新根节点的 dist 值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].v&lt;node[y].v)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].r=<span class="built_in">merge</span>(node[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(node[node[x].l].d&lt;node[node[x].r].d)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(node[x].l,node[x].r);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].d=node[node[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入<br>相当于和只有一个结点的树合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    node[cnt].v=v;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(x,cnt);<span class="comment">//返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node[x].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(node[x].l,node[x].r);<span class="comment">//返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作都以左偏树堆顶的编号代表这一刻左偏树<br>例题 hdu1512 左偏树加并查集的模版题，今年省赛的热身赛就是这题来着，当时乱搞搞出来了（数据太弱），重新用左偏树写一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[maxn],pqroot[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,v;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;</span><br><span class="line">        l=r=v=d=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        l=r=d=<span class="number">0</span>;</span><br><span class="line">        v/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].v&lt;node[y].v)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].r=<span class="built_in">merge</span>(node[x].r,y);</span><br><span class="line">    <span class="keyword">if</span>(node[node[x].l].d&lt;node[node[x].r].d)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(node[x].l,node[x].r);</span><br><span class="line">    &#125;</span><br><span class="line">    node[x].d=node[node[x].r].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(node[x].l,node[x].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==p[x]?x:x=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    p[x]=y;</span><br><span class="line">    pqroot[y]=root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">        <span class="built_in">memset</span>(pqroot,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pqroot));</span><br><span class="line">        node[<span class="number">0</span>].d=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">            pqroot[i]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1,p2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p1,&amp;p2);</span><br><span class="line">            <span class="keyword">int</span> s1=<span class="built_in">find</span>(p1),s2=<span class="built_in">find</span>(p2);</span><br><span class="line">            <span class="keyword">if</span>(s1!=s2)&#123;</span><br><span class="line">                <span class="keyword">int</span> pqroot1=pqroot[s1],pqroot2=pqroot[s2];</span><br><span class="line">                <span class="keyword">int</span> newroot1=<span class="built_in">pop</span>(pqroot1);</span><br><span class="line">                <span class="keyword">int</span> newroot2=<span class="built_in">pop</span>(pqroot2);</span><br><span class="line">                node[pqroot1].<span class="built_in">fight</span>();</span><br><span class="line">                node[pqroot2].<span class="built_in">fight</span>();</span><br><span class="line">                newroot1=<span class="built_in">merge</span>(newroot1,pqroot1);</span><br><span class="line">                newroot2=<span class="built_in">merge</span>(newroot2,pqroot2);</span><br><span class="line">                <span class="keyword">int</span> newpqroot=<span class="built_in">merge</span>(newroot1,newroot2);</span><br><span class="line">                <span class="built_in">uset</span>(s1,s2,newpqroot);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,node[newpqroot].v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并查集维护一个当前集合内优先队列的根节点 pqroot，合并的时候注意根的相关操作就 OK 了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/2019/05/11/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>这还是一篇以前写的文章。</p>
<p>差分约束问题是一类出一些形如 x-y&lt;=b 不等式的约束，问你是否满足有解的问题，这类问题竟然可以转换成图论里的最短路径问题，下面开始详细介绍下<br>比如给出三个不等式,b-a&lt;=k1,c-b&lt;=k2,c-a&lt;=k3,求出 c-a 的最大值,我们可以把 a,b,c 转换成三个点，k1，k2，k3 是边上的权，如图<br>由题我们可以得知，这个有向图中，由题 b-a&lt;=k1,c-b&lt;=k2,得出 c-a&lt;=k1+k2,因此比较 k1+k2 和 k3 的大小，求出最小的就是 c-a 的最大值了<br>根据以上的解法，我们可能会猜到求解过程实际就是求从 a 到 c 的最短路径，没错的….简单的说就是从 a 到 c 沿着某条路径后把所有权值和 k 求出就是 c -a&lt;=k 的一个<br>推广的不等式约束，既然这样，满足题目的肯定是最小的 k，也就是从 a 到 c 最短距离<br>再看 a - b &lt;= k1，b - c &lt;= k2， c-1 &lt;= k3， 那么有 k1+k2+k3&gt;=0，因此若图中存在负环，就说明不存在满足条件的解<br>判断图中是否存在负环 可以使用 dfs 形式的 spfa 算法，使用一个 vis 数组 值为 1 表示当前正在递归栈中的点，因为点可能多次入栈，需要注意回溯时处理。<br>洛谷 P1993   使用了超级源点的思想，将图中的所有点与超级源点连一条权值为 0 的边，对结果没有影响，但方便了问题的处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> to,<span class="keyword">int</span> w)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;to = to,<span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line">vector&lt;node&gt; gra[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    gra[a].<span class="built_in">push_back</span>(<span class="built_in">node</span>(b,c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> to = gra[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(dist[to]&gt;dist[x]+gra[x][i].w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[to] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            dist[to]=dist[x]+gra[x][i].w;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="built_in">spfa</span>(to);</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[to] = <span class="number">0</span>;<span class="comment">// 回溯的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fill</span>(dist,dist+maxn,inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,a,b,c;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,-c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">addedge</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树算法总结</title>
    <url>/2019/05/17/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最小生成树的算法有 Prim 和 Kruskal,首先，先说明一个结论，定义图有 n 个点，m 条边, prim 的复杂度为 O(nlogm)，kk 的复杂度为 O(mlogm)，可见 prim 更适合稠密图，而 kk 更适合稀松图。</p>
<p>当连通图中各边权值不相等时,最小生成树唯一;当有相等的权值时最小生成树可能不唯一。</p>
<p>prim 算法的思想是，首先选取一个点，加入点集，然后将该点所连的边加入边集，重复以下步骤。<br>选取当前边集合中权值最小的边，如果该边所连接的点不在点集中，将该边的另一个端点加入点集合，同时将该端点所连接的边加入边的集合。<br>当选取了 n-1 条边后，得到最小生成树。使用堆优化后的时间复杂度为 O(nlogm)。</p>
<p>证明，假设 prim 生成的树 T* 不是最小生成树，设最小生成树为 T，T* 中 <u,v> 不属于 T ，那么一定有将 <u,v> 加入 T，T 中形成环(此时共有 n 条边，一定存在环)，可以通过删除环上任意一条边(根据构建过程，<u,v>是点所连边中权值最小的)得到更小的生成树，因此 T 不存在。</u,v></u,v></u,v></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;from = from;</span><br><span class="line">        <span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">        <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; gra[maxn];</span><br><span class="line">priority_queue&lt;edge&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[<span class="number">1</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        edge tmp = gra[<span class="number">1</span>][i];</span><br><span class="line">        pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n - <span class="number">1</span> &amp;&amp; !pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        edge top = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> to = top.to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to])</span><br><span class="line">        &#123;</span><br><span class="line">            res += top.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            vis[to] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[to].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                edge tmp = gra[to][i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[tmp.to])</span><br><span class="line">                &#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gra[from].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(from, to, w));</span><br><span class="line">    gra[to].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(to, from, w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>次小生成树问题一般使用 prim 算法解决。设最小生成树的权值为 W，因为 prim 算法可以记录生成树路径，思想是在剩下的边集中尝试将每一条边 (u,v) 加入生成树中 ，此时必然可以构成一个环，此时要删除权值最大的一条边。可以用一个 max 数组记录路径 path(u,v) 上的权值最大值 max(u,v)，那么最终的答案就是 min (W + w(u,v) - max(u,v) )，max(u，v)可以在循环过程中求得。</p>
<p>网上的算法都是 O(V^2)的，我自己尝试了，似乎写不出堆优化的后的次小生成树写法，记录路径要用到 LCA。下面是模板的使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">bool</span> use[maxn][maxn]; <span class="comment">// 最小生成树使用的边</span></span><br><span class="line"><span class="keyword">int</span> maxv[maxn][maxn]; <span class="comment">// u-&gt;v中边权最大值</span></span><br><span class="line"><span class="keyword">int</span> cost[maxn][maxn]; <span class="comment">// u-&gt;v的花费</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span> use);</span><br><span class="line">    <span class="built_in">memset</span>(maxv, <span class="number">0</span>, <span class="keyword">sizeof</span> maxv);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        pre[i] = s;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, minw = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; minw)</span><br><span class="line">            &#123;</span><br><span class="line">                u = i, minw = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minw == INF)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 不连通</span></span><br><span class="line">        res += dis[u];</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        use[u][pre[u]] = use[pre[u]][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; ++v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                maxv[u][v] = maxv[v][u] = <span class="built_in">max</span>(maxv[v][pre[u]], dis[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; cost[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = cost[u][v], pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">smst</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// s:起点 ans:最小生成树的值</span></span><br><span class="line">    <span class="keyword">int</span> res = INF, ans = <span class="built_in">prim</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (cost[i][j] != INF &amp;&amp; !use[i][j]) <span class="comment">// i-&gt;j有边且不在最小生成数里</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, ans + cost[i][j] - maxv[i][j]);</span><br><span class="line">    <span class="keyword">return</span> res == INF ? <span class="number">-1</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cost[i][j] = cost[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        cost[from][to] = <span class="built_in">min</span>(cost[from][to], w);</span><br><span class="line">        cost[to][from] = <span class="built_in">min</span>(cost[to][from], w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">smst</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kruskal 的算法思想是，对于一个有 n 个点和 m 条边的无向图来说，先对其边按照权值按照从小到大的顺序进行排序。初始化一个并查集。每次取排好序的边集中权值最小的一条边，若这条边与已经选取的边不构成回路，那么将这条边加入到最终的生成树中，最终得到的生成树一定是最小生成树。回路的判断用并查集来实现。时间复杂度为 O(mlogm)</p>
<p>假设 Kruskal 算法对 n≤k 阶图适用，那么，在 k+1 阶图 G 中，我们把最短边的两个端点 a 和 b 做一个合并操作，即把 u 与 v 合为一个点 v’，把原来接在 u 和 v 的边都接到 v’上去，这样就能够得到一个 k 阶图 G’(u,v 的合并是 k+1 少一条边)，G’最小生成树 T’可以用 Kruskal 算法得到。</p>
<p>我们证明 T’+{<u,v>}是 G 的最小生成树。</u,v></p>
<p>用反证法，如果 T’+{<u,v>}不是最小生成树，最小生成树是 T，即 W(T)<W(T'+{<u,v>})。显然 T 应该包含<u,v>，否则，可以用<u,v>加入到 T 中，形成一个环，删除环上原有的任意一条边，形成一棵更小权值的生成树。而 T-{<u,v>}，是 G'的生成树。所以 W(T-{<u,v>})=W(T’)，也就是 W(T)=W(T’)+W(<u,v>)=W(T’+{<u,v>})，产生了矛盾。于是假设不成立，T’+{<u,v>}是 G 的最小生成树，Kruskal 算法对 k+1 阶图也适用。</u,v></u,v></u,v></u,v></u,v></u,v></u,v></W(T'+{<u,v></u,v></p>
<p>由数学归纳法，Kruskal 算法得证。</p>
<p>算法的实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w;</span><br><span class="line">&#125; edges[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u[x] == x ? x : u[x] = <span class="built_in">find</span>(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(edges[i].from);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">find</span>(edges[i].to);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">merge</span>(x, y);</span><br><span class="line">            res += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 KK 算法，求次小生成树的方法是维护一个子图集合和一个 maxw 数组，maxw 数据记录子图集之间的最大边权。开始每个点都属于一个子图。在进行并查集合并操作的时候合并子图。每次插入边的时候，更新边端点所在子图的最大边权为新加入的边的权值。显然根据 KK 算法的思想，每次加入的边的权值都是连接的两个子图中权值中最大的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gra[maxn];</span><br><span class="line"><span class="keyword">int</span> maxw[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, w, vis;</span><br><span class="line">&#125; edges[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(edge &amp;a, edge &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u[x] == x ? x : u[x] = <span class="built_in">find</span>(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u[x] = y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gra[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gra[y].<span class="built_in">push_back</span>(gra[x][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = i;</span><br><span class="line">        gra[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(edges[i].from);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">find</span>(edges[i].to);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; gra[x].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; gra[y].<span class="built_in">size</span>(); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxw[gra[x][j]][gra[y][k]] = maxw[gra[y][k]][gra[x][j]] = edges[i].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            edges[i].vis = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">merge</span>(x, y);</span><br><span class="line">            cnt++;</span><br><span class="line">            res += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seckk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">kk</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].vis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = edges[i].w;</span><br><span class="line">            <span class="keyword">int</span> wmax = maxw[edges[i].from][edges[i].to];</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, res + w - wmax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edges[i].from, &amp;edges[i].to, &amp;edges[i].w);</span><br><span class="line">        edges[i].vis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">seckk</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2019/09/02/%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>树状数组是一种用来解决区间单点更新，区间求和问题的简单数据结构。其核心思想在于二进制特殊性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>lowbit 函数的作用是取得 x 最右边一个 1 对应的数值。 如果 x 的二进制可以表示为 00010010，那么 lowbit 的结果为 2。怎么做到的呢？-x 的补码是 x 按位取反加 1，0010 变成 1101 +1 = 1110 ，-x 从右数第一个 1 的位置对应 x 从右数第一个 x 的位置，其他均取反。<br>如此便可以取得所要得到的数。<br>得到了这个数又有什么用呢。可以看下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>普通数组 a</th>
<th>树状数组 c</th>
<th>解释</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>a[1]</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>a[1]+a[2]</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>a[3]</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>a[1]+a[2]+a[3]+a[4]</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>a[5]</td>
<td>0101</td>
</tr>
<tr>
<td>6</td>
<td>11</td>
<td>a[5]+a[6]</td>
<td>0110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>a[7]</td>
<td>0111</td>
</tr>
<tr>
<td>8</td>
<td>36</td>
<td>a[1]+…+a[8]</td>
<td>1000</td>
</tr>
<tr>
<td>9</td>
<td>9</td>
<td>a[9]</td>
<td>1001</td>
</tr>
</tbody>
</table>
</div>
<p>对于一个位置，看它的二进制，这个位置保存的元素个数就是其二进制最右边 1 代表的大小，保存从去掉最右边 1 到加上最右边 1 的位置之间的数据（左开右闭）。<br>这样表述很不清楚，直接距离，看 c[6]位置，6 的二进制是 0110，去掉最右边 1 是 0100，即十进制的 4，它保存的是(4,6]之间的数据。</p>
<p>那么对于求和操作，就变成了不断找右边的 1 的过程。</p>
<p>对于更新操作，我们要同时更新其之后的父节点。<br>当我们修改 a[i]的值时，可以从 c[i]往根节点一路上溯，调整这条路上的所有 C[]即可，对于节点 i，父节点下标 p=i+lowbit(i)</p>
<p>树状数组多用于求逆序对，原理是将序列按顺序插入树状数组时，每次统计比当前数小的元素数量 sum，则与当前数构成逆序的对数有 i-sum<br>可以离散化数据，我们不关心具体元素的数值，只关心其对应关系。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="built_in">update</span>(i, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展到二维"><a href="#扩展到二维" class="headerlink" title="扩展到二维"></a>扩展到二维</h2><p>问题：一个由数字构成的大矩阵，能进行两种操作</p>
<ul>
<li>对矩阵里的某个数加上一个整数（可正可负）</li>
<li>查询某个子矩阵里所有数字的和,要求对每次查询，输出结果。</li>
</ul>
<p>一维树状数组很容易扩展到二维，在二维情况下:数组 A[][]的树状数组定义为：</p>
<script type="math/tex; mode=display">C[x][y] = \Sigma a[i][j]</script><script type="math/tex; mode=display">x-lowbit(x) + 1 <= i <= x</script><script type="math/tex; mode=display">y-lowbit(y) + 1 <= j <= y</script><p>其相应的更新与求和操作也很容易类比出来，这里就不做说明了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>约数个数公式</title>
    <url>/2019/05/26/%E7%AE%97%E6%B3%95/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>题目是求有 100 个约数的数字的最小值。有两种方法去做，一种直接暴力求每个数的约数个数，直到找到第一个约数为 100 的数。第二种用到了约数定理，首先用质因数分解的方法求出每个质因数的指数：</p>
<script type="math/tex; mode=display">n = a_{1}^{p1}*a_{2}^{p2}*...*a_{n}^{pn}</script><p>那么 n 的约数个数可以用以下公式求得：</p>
<script type="math/tex; mode=display">(p1+1)*(p2+1)*...*(pn+1)</script><p>很简单的乘法原理的思想，对于质因数 $ a_1 $ 可以取 0,1,2…n 一共 n+1 个，其他同理。<br>如何证明这样不会取得相同的因数呢？<br>假设两个因数</p>
<script type="math/tex; mode=display">b_1 = a_1 * a_1 * a_2 * a_2 * a_3 \\ b_2 = a_1 * a_2 * a_3 * a_4</script><p>如果 $ b_1 = b_2 $ 那么有 $ a_1 * a _2 = a_4 $，显然与$a_4$是一个质数矛盾，所以不存在重复的情况。<br>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">2</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % factor != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            factor++;</span><br><span class="line">            a.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            n = n / factor;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= (a[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">solve</span>(n);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ret &lt;&lt; endl;5</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题记录方案数量</title>
    <url>/2019/05/26/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E6%96%B9%E6%A1%88%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>题目是求 2019 可以由多少个两两不同的质因数组成，可以转化为 01 背包模型，将每个质因数的价值和花费等同于其数值大小。那么问题就简单变为了求 01 背包的方案数量。<br>代码如下<br>注意初始化 dp[0] =1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> isp[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isp[<span class="number">0</span>] = isp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; maxn; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                isp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">seive</span>();</span><br><span class="line">    <span class="keyword">int</span> dp[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2019</span>; j &gt;= prime[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - prime[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">2019</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>蓝桥2019国赛</tag>
      </tags>
  </entry>
  <entry>
    <title>有穷自动机</title>
    <url>/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>（以下内容摘自龙书）</p>
<p>有穷自动机是一般化的状态转换图，它可以是确定的或不确定的，其中不确定的含义是，对于某个输入符号，在同一个状态上存在不止一种转换。</p>
<p>下文以 DFA 指代确定的有穷自动机，NFA 指代不确定的有穷自动机。</p>
<p>DFA 和 NFA 都能且仅能识别正规集，即它们能够识别正规表达式所表示的语言。DFA 导出的识别器比 NFA 导出的识别器快得多，但是 DFA 可能比与之等价的 NFA 大得多。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><p>NFA 是由以下几个部分组成的数学模型：</p>
<ul>
<li>一个状态的有穷集合 S</li>
<li>一个输入符合集合$\Sigma$,即输入符号字母表</li>
<li>一个转换函数 move，它把状态和符号组成的二元组映射到状态集合</li>
<li>状态 $s_0$ 是唯一的开始或初始状态</li>
<li>状态集合 F 是接受（或中止）状态集合</li>
</ul>
<p>NFA 可以用带标记的有向图表示，称为转换图，其节点是状态，有标记的边是转化函数。</p>
<p><img src="/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/NFA.png" alt="NFA"></p>
<p><img src="/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/NFA2.png" alt="NFA2"></p>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA 是 NFA 的特例</p>
<ul>
<li>没有一个状态具有$\epsilon$转换</li>
<li>对每个状态 s 和输入符号 a，最多只有一条标记为 a 的边离开</li>
</ul>
<p>确定的有穷自动机在任何状态下，对任一输入符号，最多只有一个转换。如果用转换表表示 DFA 的转换函数，那么表中的每个表项最多只有一个状态。因而，很容易确定 DFA 是否接受某输入字符串，因为从开始状态起，最多只有一条到达接受状态的路径可由这个符号串标记。</p>
<h2 id="NFA-转为-DFA"><a href="#NFA-转为-DFA" class="headerlink" title="NFA 转为 DFA"></a>NFA 转为 DFA</h2><p>子集构造算法，在 NFA 的转换表中，每个表项是一个状态集，在 DFA 的转化表中，每个表项只有一个状态。从 NFA 变换到 DFA 的基本思想是让 DFA 的每个状态对应 NFA 的一个状态集。DFA 用它的状态去记住 NFA 在读输入符号后到达的所有状态。</p>
<p><img src="/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/NFA转DFA.png" alt="NFA转DFA"></p>
<p>定义三种操作</p>
<ul>
<li>$\epsilon-closure(s)$ 从 NFA 状态 s 只经过$\epsilon$转换可以到达的 NFA 状态集</li>
<li>$\epsilon-closure(T)$ 从 T 中的状态只经过$\epsilon$转换可以到达的 NFA 状态集</li>
<li>move(T,a) 从 T 中的状态 S 经过输入符号 a 上的转换可以到达的 NFA 状态集</li>
</ul>
<p>子集构造的步骤伪码如下，其中 Dstates 是 D 的状态集合，Dtran 是 D 的转换表</p>
<p>初始时，$\epsilon-closure(s)$是 Dstates 中唯一的状态且未被标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while Dstates 中存在一个未标记的状态T</span><br><span class="line">    标记T</span><br><span class="line">    for 每个输入符号a</span><br><span class="line">        U = epsilon-closure(move(T,a))</span><br><span class="line">        if U 不在 Dstates中</span><br><span class="line">            将U作为一个未标记的状态添加到Dstates中</span><br><span class="line">        Dtran[T,a] = U</span><br></pre></td></tr></table></figure>
<p>开始状态 A = $\epsilon-closure(s)$ = {0，1，2，4，7}，根据算法流程，先标记 A</p>
<p>然后计算 $\epsilon-closure(move(A,a))$，在状态 A 上只有 2 和 7 有 a 上的转换，得到状态 B={1,2,3,4,6,7,8},Dtran[A,a] = B</p>
<p>状态 A 中只有状态 4 对于输入 b 有一个转换，得到状态 C={1,2,4,5,6,7},Dtran[A,b]=C</p>
<p>然后对没被标记的状态 B 和状态 C 继续这个过程</p>
<p>状态 B 的 a 转换 得到的状态仍然是 B， Dtran[B,a] = B</p>
<p>状态 B 中在 8 上的 b 的转换可以得到新的状态 D={1,2,4,5,6,7,9} Dtran[B,b] = D。这里的计算详细解释一下，{1,2,3,4,6,7,8} 经过 b 转换后的集合是 {5,9}，然后再计算 $\epsilon-closure({5,8})$ 得到 {1,2,4,5,6,7,9}</p>
<p>状态 C 的 a 转换可以得到的状态 {1,2,3,4,6,7,8}，即状态 B，Dtran[C,a] = B</p>
<p>状态 C 的 b 转换可以得到的状态 {1,2,4,5,6,7}，即状态 C 自身，Dtran[C,b] = C</p>
<p>之后的过程省略，可以得到的五个状态集合是</p>
<p>A = {0,1,2,4,7}<br>B = {1,2,3,4,6,7,8}<br>C = {1,2,4,5,6,7}<br>D = {1,2,4,5,6,7,9}<br>E = {1,2,4,5,6,7,10}</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>B</td>
<td>B</td>
<td>D</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>D</td>
<td>B</td>
<td>E</td>
</tr>
<tr>
<td>E</td>
<td>B</td>
<td>C</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/子集构造法结果.png" alt="子集构造法结果"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来用编程语言实现一个简单的 DFA</p>
<p><img src="/2020/03/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/要实现的DFA.png" alt="要实现的DFA"></p>
<p>功能要求：输入一个单行无空格的字符串（以“#”号结束），如果该字符串是一个合法的输入，则显示“接受”，否则显示“不接受”。</p>
<p>分析该 DFA 的五元组信息如下</p>
<ul>
<li>一个状态的有穷集合 S = {0,1,2,3}</li>
<li>一个输入符合集合$\Sigma$ = {a,b}</li>
<li>一个转换函数 move，它把状态和符号组成的二元组映射到状态集合<ul>
<li>move(0,a) = 1</li>
<li>move(0,b) = 0</li>
<li>move(1,a) = 1</li>
<li>move(1,b) = 2</li>
<li>move(2,a) = 1</li>
<li>move(2,b) = 3</li>
<li>move(3,a) = 1</li>
<li>move(3,b) = 0</li>
</ul>
</li>
<li>状态 $s_0$ 是唯一的开始或初始状态 = 0</li>
<li>状态集合 F 是接受（或中止）状态集合 = {3}</li>
</ul>
<p>根据如下信息就可以开始编码了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 是否合法</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;    <span class="comment">// 当前扫描位置</span></span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;  <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">while</span> (str[pos] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> next = str[pos];</span><br><span class="line">        ++pos;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;接受&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不接受&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：<br>abbab#<br>abb#<br>输出：<br>不接受<br>接受</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编与栈帧1</title>
    <url>/2018/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E4%B8%8E%E6%A0%88%E5%B8%A7/</url>
    <content><![CDATA[<p>转自:</p>
<ul>
<li><a href="https://www.cnblogs.com/dormant/p/5059644.html">汇编与栈帧学习（一）</a></li>
<li><a href="https://www.cnblogs.com/dormant/p/5079894.html">esp 和 ebp 详解</a></li>
<li><a href="https://blog.csdn.net/striver1205/article/details/25695437">Push, Pop, call, leave 和 Ret 指令图解</a></li>
</ul>
<p>参考以上博文的内容，写了一个简单的程序，说明一下汇编调用过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源程序 test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我的环境为64位linux系统，需要加上-m32指定以32位方式编译</span></span><br><span class="line">$ gcc -m32  -g test1.c</span><br><span class="line">$ gdb a.<span class="built_in">out</span></span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x80483f7</span>: file test1.c, line <span class="number">8.</span></span><br><span class="line">(gdb) b add</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x80483e1</span>: file test1.c, line <span class="number">3.</span></span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at test1.c:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>         <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line"><span class="number">0x080483f1</span> &lt;+<span class="number">0</span>&gt;:     push   %ebp <span class="comment">// ebp寄存器存储当前main栈帧栈底, 将ebp入栈，esp减去4字节</span></span><br><span class="line"><span class="number">0x080483f2</span> &lt;+<span class="number">1</span>&gt;:     mov    %esp,%ebp <span class="comment">// 把esp的数值赋给ebp</span></span><br><span class="line"><span class="number">0x080483f4</span> &lt;+<span class="number">3</span>&gt;:     sub    $<span class="number">0x10</span>,%esp <span class="comment">// 把esp减去16个字节</span></span><br><span class="line">=&gt; <span class="number">0x080483f7</span> &lt;+<span class="number">6</span>&gt;:     movl   $<span class="number">0xffffffff</span>,<span class="number">-0xc</span>(%ebp) <span class="comment">// ebp减去12字节的位置保存直接数-1</span></span><br><span class="line"><span class="number">0x080483fe</span> &lt;+<span class="number">13</span>&gt;:    movl   $<span class="number">0x0</span>,<span class="number">-0x8</span>(%ebp) <span class="comment">// ebp减去8字节的位置保存直接数0</span></span><br><span class="line"><span class="number">0x08048405</span> &lt;+<span class="number">20</span>&gt;:    pushl  <span class="number">-0x8</span>(%ebp) <span class="comment">// ebp减去8字节的位置的值（b的数值）入栈 同时esp减去4字节</span></span><br><span class="line"><span class="number">0x08048408</span> &lt;+<span class="number">23</span>&gt;:    pushl  <span class="number">-0xc</span>(%ebp) <span class="comment">// ebp减去12字节的位置的值入栈（a的数值） 同时esp减去4字节 说明参数是按照从右向左的顺序入栈的</span></span><br><span class="line"><span class="number">0x0804840b</span> &lt;+<span class="number">26</span>&gt;:    call   <span class="number">0x80483db</span> &lt;add&gt; <span class="comment">// 调用add函数 call指令将返回地址0x0804840b压入栈顶，esp减去4字节，然后程序跳转到add函数的起始地址</span></span><br><span class="line"><span class="number">0x08048410</span> &lt;+<span class="number">31</span>&gt;:    add    $<span class="number">0x8</span>,%esp <span class="comment">// esp加上8 清除局部变量占用的空间</span></span><br><span class="line"><span class="number">0x08048413</span> &lt;+<span class="number">34</span>&gt;:    mov    %eax,<span class="number">-0x4</span>(%ebp)</span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">37</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"><span class="number">0x0804841b</span> &lt;+<span class="number">42</span>&gt;:    leave</span><br><span class="line"><span class="number">0x0804841c</span> &lt;+<span class="number">43</span>&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p $esp</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc68</span></span><br><span class="line">(gdb) p $ebp</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc78</span></span><br><span class="line">(gdb) disas add</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function add:</span><br><span class="line"><span class="number">0x080483db</span> &lt;+<span class="number">0</span>&gt;:     push   %ebp <span class="comment">// ebp寄存器存储当前main栈帧栈底, 将ebp入栈，esp减去4字节</span></span><br><span class="line"><span class="number">0x080483dc</span> &lt;+<span class="number">1</span>&gt;:     mov    %esp,%ebp <span class="comment">// 把esp的数值赋给ebp</span></span><br><span class="line"><span class="number">0x080483de</span> &lt;+<span class="number">3</span>&gt;:     sub    $<span class="number">0x10</span>,%esp <span class="comment">// 把esp减去16个字节</span></span><br><span class="line">=&gt; <span class="number">0x080483e1</span> &lt;+<span class="number">6</span>&gt;:     mov    <span class="number">0x8</span>(%ebp),%edx <span class="comment">// ebp加上8个字节的位置的值 存入寄存器edx</span></span><br><span class="line"><span class="number">0x080483e4</span> &lt;+<span class="number">9</span>&gt;:     mov    <span class="number">0xc</span>(%ebp),%eax <span class="comment">// // ebp加上12个字节的位置的值 存入寄存器eax</span></span><br><span class="line"><span class="number">0x080483e7</span> &lt;+<span class="number">12</span>&gt;:    add    %edx,%eax <span class="comment">// edx的数值加上eax的数值存入eax</span></span><br><span class="line"><span class="number">0x080483e9</span> &lt;+<span class="number">14</span>&gt;:    mov    %eax,<span class="number">-0x4</span>(%ebp) <span class="comment">// ebx减去4字节的位置保存eax的值</span></span><br><span class="line"><span class="number">0x080483ec</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">-0x4</span>(%ebp),%eax <span class="comment">//</span></span><br><span class="line"><span class="number">0x080483ef</span> &lt;+<span class="number">20</span>&gt;:    leave <span class="comment">// LEAVE指令是将ebp的数值赋给esp，然后popl ebp， 即esp加上4字节</span></span><br><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">21</span>&gt;:    ret <span class="comment">// RET指令则是将栈顶的返回地址弹出到EIP，esp+4 然后按照EIP此时指示的指令地址继续执行程序</span></span><br><span class="line">(gdb) p $ebp</span><br><span class="line">$<span class="number">6</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc58</span></span><br><span class="line">(gdb) p $esp</span><br><span class="line">$<span class="number">5</span> = (<span class="keyword">void</span> *) <span class="number">0xffffcc48</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础之异常控制流学习笔记</title>
    <url>/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/思维导图.png" alt="思维导图"></p>
<h2 id="正常控制流"><a href="#正常控制流" class="headerlink" title="正常控制流"></a>正常控制流</h2><p>正常控制流包含两种顺序</p>
<ul>
<li>按照指令存放的顺序执行，新的 PC 数值为当前指令地址加上指令长度</li>
<li>跳转到由于转移类指令指出的转移目标地址处执行，新的 PC 数值为转移目标地址</li>
</ul>
<h2 id="进程与进程上下文的切换"><a href="#进程与进程上下文的切换" class="headerlink" title="进程与进程上下文的切换"></a>进程与进程上下文的切换</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>进程是资源分配的最小单位，每个应用程序在运行时均有自己的存储空间，用来存储自己的程序代码和数据，包括只读区（代码和只读数据），可读可写数据区（初始化数据和未初始化数据），动态的堆区和栈区</p>
<p>进程的引入为程序提供了以下两方面的抽象。一个独立的逻辑控制流和一个私有的虚拟内存地址。每个进程拥有一个独立的逻辑，使得程序员以为程序似在执行过程中独占处理器。一个私有的虚拟地址空间，使得程序员以为程序在执行过程中独占存储器。</p>
<p>为了实现以上两方面的抽象，操作系统必须提供一整套管理机制，包括处理器调度、进程上下文切换、虚拟存储管理等。</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>一个可执行目标文件被加载并启动执行后，就成为一个进程。他们代码段中的每一条指令都有一个确定的地址，在这些指令的执行过程中，会形成一个指令执行的地址序列，对于确定的输入数据，其指令的地址序列也是确定的。这个确定的指令执行地址序列被称为进程的<strong>逻辑控制流</strong>。</p>
<p>对于一个具有单核处理器的系统，如果有多个进程运行，这些进程会轮流使用处理器，处理器的<strong>物理控制流</strong>是由多个逻辑控制流组成。<br><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/多个逻辑控制流.png" alt="多个逻辑控制流"></p>
<p>图中可以看出有些进程的逻辑控制流在时间上有交错，通常把这种不同进程的逻辑控制流在时间上交错或者重叠称为<strong>并发</strong>。而<strong>并行</strong>则是并发执行的一个特例，我们称两个进程是并行的，是指他们并发的运行在不同的处理器或者处理器核中。</p>
<p>连续执行同一个进程的时间段称为时间片，每个时间片结束时，通过进程的上下文切换，换一个新的进程到处理器上执行，开始一个新的时间片，这个过程称为<strong>时间片轮转处理器调度</strong>。</p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>实现不同进程中指令交替执行的机制称为<strong>进程的上下文切换</strong>。</p>
<p>进程的物理实体（代码和数据）和支持进程运行的环境合称为<strong>进程的上下文</strong>，可以细分为</p>
<ul>
<li>由用户进程的程序块，数据块，运行时的堆和用户栈等组成的用户空间信息被称为<strong>用户级上下文</strong>。</li>
<li>进程表示信息，进程现场信息，进程控制信息和系统内核堆栈组成的<strong>内核空间信息</strong>被称为<strong>系统级上下文</strong>。</li>
<li>处理器中各个寄存器的内存被称为<strong>寄存器上下文</strong>。</li>
</ul>
<p>用户级上下文和系统级上下文地址空间一起构成了一个进程的整个存储器映像。进程控制信息包含各种内核数据结构，如有关进程信息的进程表，页表，文件表等。<br><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/进程的存储映像.png" alt="进程的存储映像"></p>
<p>上下文切换发生在操作系统调度一个新进程到处理器上运行，他需要完成以下三件事</p>
<ul>
<li>将当前进程的寄存器上下文保存到当前进程的系统级上下文的现场信息中</li>
<li>将新进程系统上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中</li>
<li>将控制转移到新进程执行</li>
</ul>
<p>一个重要的上下文信息是 PC，当前进程被打断的断点处的 PC 作为寄存器上下文的一部分被保存在进程现场信息中。</p>
<h3 id="进程的私有地址空间"><a href="#进程的私有地址空间" class="headerlink" title="进程的私有地址空间"></a>进程的私有地址空间</h3><p><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/虚拟地址空间映像.png" alt="虚拟地址空间映像"></p>
<p>整个虚拟地址空间分为两大部分。<strong>内核虚拟存储空间</strong>（简称内核空间）和<strong>进程虚拟内存空间</strong>（简称用户空间）。在采用虚拟存储机制的系统中，每个程序的可执行目标文件在装入时都被映射到同样的虚拟地址空间上，即所有用户进程的虚拟地址空间是一致的，只是在相应的制度区域和可读写数据区域中映射的信息不同而已。</p>
<p>linux 将用户空间对应的进程虚拟存储空间组织成若干“区域”的集合，<br>内核为每个进程维护了一个进程描述符，记录或者指向内核运行该进程所需要的所有信息，如进程 pid，指向用户栈的指针，可执行目标文件的文件名，程序计数器 PC 等。</p>
<h3 id="程序的加载和运行"><a href="#程序的加载和运行" class="headerlink" title="程序的加载和运行"></a>程序的加载和运行</h3><p>当启动一个可以行目标文件执行时，首先会通过某种方式调出常驻内存的一个称为加载器的操作系统程序来处理。在 UNIX/Linux 系统中，可以通过 execve() 函数来启动加载器，其作用是在当前进程的上下文中加载并且运行一个新程序。</p>
<h2 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h2><p>除了时间片到，当前进程的执行被新进程打断，还有用户按下 CTRL+C，当前执行执行中发生了不能使指令执行的意外事件，IO 设备完成了系统交给的任务需要进一步处理，这些特殊事件统称为<strong>异常</strong>或者<strong>中断</strong>。<br>当发生异常或者终端，正在执行进程的逻辑控制流被打断，CPU 转到具体的特殊处理事件的内核程序去执行。他与上下文切换有一个明显的不同：上下文切换后 CPU 执行另一个用户进程，但是，中断或异常处理程序执行的代码不是一个进程，而是一个<strong>内核控制路径</strong>，它代表异常或终端发生时正在运行的当前进程在内核态执行的一个独立的指令序列。作为一个内核控制路径，他比进程更轻，其上下文信息比一个进程的上下文信息少得多。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>异常是在 CPU 内部执行时发生的，中断是 CPU 外部的 IO 设备向 CPU 发出的请求，通常称异常为<strong>内部异常</strong>，而称中断为<strong>外部中断</strong>。</p>
<p><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/中断处理过程.png" alt="中断处理过程"></p>
<p>大致处理流程如下：当 CPU 在执行当前程序或任务的第 i 条指令时检测到一个异常事件，或者在执行第 i 条指令后发现有一个中断请求信息，CPU 会打断当前用户进程，然后转到相应的异常或中断处理程序去执行。如果该处理程序能解决相应问题，则在该处理程序的最后，CPU 通过执行“异常/中断返回指令”回到被打断的用户进程的第 i 条指令或第 i+1 条指令继续执行。若异常或中断处理程序发现是不可恢复的知名错误，则中止用户进程。通常情况下，对于异常和中断事件的具体处理过程全部由操作系统（可能包括驱动程序）软件来完成。</p>
<h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>intel 将内部异常分为三类</p>
<p>故障</p>
<p><strong>故障</strong>是在引起故障的指令被启动后但未结束执行时 CPU 检测到的一类与指令执行相关的意外事件。这种意外事件有些可以回复，有些不能回复。如指令译码出现的非法操作码；取指令或者取数据时发生页故障，执行触发操作时发现除数为 0.</p>
<p>对于像溢出和非法操作码等这类故障，因为无法通过异常处理程序回复，会调用内核的 abort 例程，以中止发生故障的当前进程。</p>
<p>对于页故障。cpu 在指令执行过程中需要访问存储器，首先进行地址转换，在查页表进行地址转换时，判断相应页表项中的有效位是否是 1，并且确定是否地址越界或访问越权，如果检测到有效位不为 1 或者地址越界或者访问越权，都会产生页故障异常。页故障异常包含多种不同情况：处理程序首先检测是否发生地址越界或访问越权，如果是的话，故障不可恢复，否则是缺陷故障，可通过从磁盘读入页面来恢复。Linux 中不可恢复的访存故障（地址越界和访问越权）都称为<strong>段故障</strong>。</p>
<p>陷阱</p>
<p><strong>陷阱</strong>也成为自陷或者陷入，与故障等其他异常事件不同，是预先安排的一种异常事件，就像预先设定的陷阱一样，当执行到陷阱指令，CPU 就调出特定的程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令执行。</p>
<p>陷阱的重要作之一是在用户程序和内核之间提供一个像过程调用一样的接口，这个接口称为<strong>系统调用</strong>。操作系统给每个服务编一个号，称为系统调用号，每个服务功能通过一个对应的<strong>系统调用服务例程</strong>提供。如在 linux 中就提供了创建子线程（fork），读文件（read），加载并且运行新程序（execve）等服务功能。</p>
<p>用于程序调试的<strong>断点设置</strong>也是一种陷阱指令。</p>
<p>在 IA-32 中，陷阱指令引擎的异常称为编程异常，这些指令包括 INT n，int 3，into（溢出检查），bound（地址越界检查）,通常将 INT n 称为软中断指令，该指令引起的异常通常也称为<strong>软中断</strong>。在 IA-32/Linux 中可以使用快速系统调用指令 sysenter 或者软中断指令 int $0x80 进行系统调用。</p>
<p>终止</p>
<p>如果在执行指令的过程中发生了严重错误，如控制器出现问题，访问 DRAM 或者 SRAM 时发生校验错误等，则程序无法继续执行，只好终止发生问题的进程。</p>
<h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p><strong>中断</strong> 是由外部 IO 设备请求处理器进行的一种信号。他不是由当前执行的指令引起的，外部 IO 设备通过特定的<strong>中断请求信号线</strong>向 CPU 提出中断申请。CPU 在执行指令过程中，每执行一条指令就查看中断请求引脚，如果中断请求引脚的信号有效，则进入中断响应周期。在<strong>中断响应周期</strong>中，CPU 先将当前 PC 值和当前机器状态保存到栈中，并设置成为<strong>关中断</strong>状态，然后从数据总线读取<strong>中断类型号</strong>，根据中断类型号跳转到对应的中断服务程序执行。中断响应过程由硬件完成，而中断服务程序执行具体的中断处理工作，中断处理完成后，再回到被打断程序的断点处继续执行。</p>
<p><img src="/2020/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/外部中断的处理过程.png" alt="外部中断的处理过程"></p>
<p>可屏蔽中断</p>
<p>是指通过<strong>可屏蔽中断请求线</strong>INTR 向 CPU 进行请求的中断，主要来自 IO 设备的中断请求。CPU 可以通过在中断控制器中设置相应的屏蔽字来屏蔽他或者不屏蔽他。若一个 IO 设备的中断请求被屏蔽，他的中断请求信号不会被送到 CPU。</p>
<p>不可屏蔽中断</p>
<p>通常是非常紧急的硬件故障，通过专门的<strong>不可屏蔽中断请求线</strong>NMI 向 CPU 发出中断请求。</p>
<h3 id="异常和中断的响应过程"><a href="#异常和中断的响应过程" class="headerlink" title="异常和中断的响应过程"></a>异常和中断的响应过程</h3><p>CPU 从检测到异常或中断事件，到调出响应的异常或中断处理程序开始执行，整个过程称为<strong>异常和中断的响应</strong>。主要分为以下三个步骤：</p>
<ul>
<li>保护断点和程序状态</li>
<li>关中断</li>
<li>识别异常和中断事件并转到响应处理程序执行</li>
</ul>
<p>保护断点和程序状态</p>
<p>对于不同的异常事件，其返回地址不同。如却也故障异常的断点是发生页故障的当前指令的地址。陷阱的断点是陷阱指令后面一条指令的地址。</p>
<p>为了能够支持异常或者中断的嵌套处理，大多数处理器将断点保存到栈中，如 IA-32 处理器的断点被保存到栈中，如果系统不支持桥套处理，则可以将断点保存到特定寄存器中。MIPS 处理器用 EPC 寄存器专门存放断点，其 CPU 用于中断的开销较小。</p>
<p>被中断时源程序状态（如产生的各种标志信息，允许自陷标志等）都必须保存起来。每个正在运行程序的状态信息存放在一个专门的寄存器中，这些专门寄存器统称为<strong>程序状态字寄存器</strong>（PSWR），存放在 PSWR 中的信息称为<strong>程序状态字</strong>。</p>
<p>关中断</p>
<p>应有一种机制来禁止在处理异常或中断时再响应新的异常或中断，通常通过设置<strong>中断允许位</strong>来实现。</p>
<p>识别异常和中断事件并转到响应处理程序执行</p>
<p>在调出异常和中断你处理程序之前，必须知道发生了什么异常或者那个 IO 设备发出了中断请求。一般来说，内部异常事件和外部中断源的识别方式不同，大多数处理器会将二者分开来处理。</p>
<p>内部异常事件的识别很简单，只要 CPU 在执行期间把检测到的事件对应的异常类型或者表示异常类型的信息记录到特定的内部寄存器中即可。</p>
<p>外部中断源的识别比较复杂，只能通过在每条指令执行完成后，取下条指令之前去查询是否有中断请求。通常 CPU 通过采样对应的中断请求引脚来进行查询。但是到底是那个 IO 设备发出的请求，还需要进一步识别。</p>
<p>异常中断的识别可以采用软件识别和硬件识别两种方式。</p>
<p>软件识别是指，CPU 中设置一个原因寄存器，该寄存器中有一些标识异常原因或终端类型的标志信息。操作系统使用一个统一的异常或中断查询程序，按一定的优先级顺序查询原因寄存器，先查询到的先处理。MIPS 采用软件识别方式</p>
<p>硬件识别方式称为<strong>向量中断方式</strong>，这种方式下，异常或中断处理程序的首地址称为<strong>中断向量</strong>，所有中断向量存放在一个表中，称为<strong>中断向量表</strong>。每个异常和中断都被设定一个<strong>中断类型号</strong>，中断向量存放的位置与对应的中断类型号相关。可以根据类型号快速找到对应的处理程序。IA-32 中的异常和中断识别就采用这种方式。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>BIOS（Basic Input/Output System）是基本输入/输出系统的简称</p>
<p>Intel 从奔二处理器开始，引入了指令 sysenter 和 sysexit，sysenter 被称为<strong>快速系统调用指令</strong>，他提供了从用户态到内核态的快速切换方式。</p>
<p>页的大小是 4kb，当对于页起始地址的发起第一次访问时，会发生缺页异常。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>异常和中断</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础之数据的机器级表示与处理</title>
    <url>/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="数据的机器级表示与处理"><a href="#数据的机器级表示与处理" class="headerlink" title="数据的机器级表示与处理"></a>数据的机器级表示与处理</h3><h4 id="数制和编码"><a href="#数制和编码" class="headerlink" title="数制和编码"></a>数制和编码</h4><h5 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h5><p>计算机内部处理的所有数据都必须是<strong>数字化编码</strong>了的数据。</p>
<p>采用二进制表示方式的原因如下：</p>
<ul>
<li>二进制只有两种基本状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，而制造有两个稳定状态的物理器件要比制造有多个稳定状态的物理器件容易得多。如用高低两个电位，脉冲的有无，脉冲的正负极性。</li>
<li>二进制的编码，计数和运算规则都很简单</li>
<li>两个符号 1 和 0 正好与逻辑命题的真假相对应，为计算机中实现逻辑运算和程序中的逻辑判断提供了便利的条件</li>
</ul>
<p>机器指令的操作数只能是以下四种简单的基本数据类型：无符号定点整数，带符号定点整数，浮点数和非数值型数据</p>
<p>指令所处理的数据类型分为数值数据和非数值数据两种。<strong>数值数据</strong>可用来表示数量的多少，可比较其大小，分为整数和实数，整数又分为无符号整数和带符号整数，实数用浮点数表示。<strong>非数值数据</strong>是一个没有大小之分的位串，不表示数量的多少，主要用来表示字符数据和逻辑数据。</p>
<p>在计算机内部，数值的表示方法又两大类，第一种是直接用二进制数表示，另一种是采用二进制编码的十进制数（Binary Coded Decimal Number 简称 BCD）表示。</p>
<p>表示一个数值数据要确定三个要素：进位计数制，定/浮点表示和编码规则。</p>
<h5 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h5><script type="math/tex; mode=display">(25.6)_{10} = 2*10^1 + 5*10^0 + 6 * 10 ^{-1}</script><p>十进制数字可以表示成以上形式，10 称为基数，$10^i$ 称为第 i 位上的权，运算时采用逢十进一。</p>
<p>类似地，二进制数的基数是 2，运算时逢二进一。</p>
<p>以上规律可以扩展到 R 进制的数字系统。</p>
<p>进制转换相关不再赘述。</p>
<h5 id="定点与浮点表示"><a href="#定点与浮点表示" class="headerlink" title="定点与浮点表示"></a>定点与浮点表示</h5><p>定点表示</p>
<p>定点表示法用来对定点小数和定点整数进行表示，对于定点小数，其小数点总是固定在数的左边，一般用来表示浮点数的尾数部分。对于定点整数，其小数点总是固定在数的最右边。</p>
<p>浮点表示</p>
<p>对于任意一个实数 X，可以表示成如下形式：</p>
<script type="math/tex; mode=display">X=(-1)^s*M*R^E</script><p>其中 S 取值为 0 或 1，用来决定数 X 的符号；M 是一个二进制定点小数，称为数 X 的<strong>尾数</strong>（mantissa），E 是一个二进制定点整数，称为数 X 的<strong>阶</strong>或<strong>指数</strong>；R 是<strong>基数</strong>（radix、base）。在基数 R 一定的情况下，尾数 M 的位数反映数 X 的有效位数，它决定了数的表示精度，有效位数越多，表示精度就越高，阶 E 的位数决定数 X 的表示范围，阶 E 的位数决定数 X 的表示范围；阶 E 的值确定了小数点的位置。</p>
<p>从浮点数的形式来看，绝对值最小的非零数是如下形式的数：$0.0···01<em>R^{-11···1}$，而绝对值最大的数的形式应为 $0.11···1</em>R^{11···1}$，所以假设 m 和 n 分别表示阶和尾数的位数，基数为 2，则浮点数 X 的绝对值的范围为：</p>
<script type="math/tex; mode=display">2^{-(2^m-1)}*2^{-n} \leq |X|\leq (1-2^{-n})*2^{(2^m-1)}</script><p>浮点数的最小数是定点小数的最小数 $2^{-n}$ 去除一个很大的数$2^{2^m-1}$,而浮点数的最大数则是定点小数的最大数 $1-2^{-n}$乘以这个大数$2^{2^m-1}$</p>
<h5 id="定点数的编码表示"><a href="#定点数的编码表示" class="headerlink" title="定点数的编码表示"></a>定点数的编码表示</h5><p>定/浮点表示解决了小数点的表示问题，但是对于一个数值数据来说，还有一个正负号的表示问题。一般用 0 和 1 来表示数字的符号，称为<strong>符号数字化</strong>，一般规定 0 表示正号，1 表示负号。</p>
<p>通常将数值数据在计算机内部编码表示的数称为<strong>机器数</strong>，而机器数真正的值称为机器数的<strong>真值</strong>。</p>
<p>约定一个机器数$X$的真值$X_T$用 n 位的二进制数编码，有以下方式：</p>
<p>原码表示法</p>
<p>一个数的原码表示由符号位直接跟数值位构成，称为“符号-数值”表示法。</p>
<p>原码编码规则如下</p>
<ul>
<li>当 $X<em>T$为正数时，$X</em>{n-1} = 0,X_i=X_i^” (0\leq i \leq n-2)$</li>
<li>当 $X<em>T$为负数时，$X</em>{n-1} = 1,X_i=X_i^” (0\leq i \leq n-2)$</li>
</ul>
<p>原码表示的优点是：与真值的对应关系直观，方便，用原码实现乘除运算也比较简便。</p>
<p>缺点是：0 的表示不唯一，加减法运算规则复杂。在加减运算过程中，要判定是否是两个异号数相加或两个同号数详见，若是，则必须判定两个数的绝对值大小，根据判断结果决定结果符号，然后用绝对值大的数减去绝对值小的数。现代计算机不用原码表示整数，只用定点原码小数来表示浮点数的尾数部分。</p>
<p>补码表示法</p>
<p>补码表示可以实现加减运算的统一，用加法来实现减法运算。计算机中，补码用来表示带符号整数，补码表示法也称为“2-补码”（two’s complement）表示法，由符号位后跟上真值的模$2^n$补码构成。</p>
<p>可以用以下方法求一个数的补码：对于正数，符号位取 0，其余各位同真值中对应的各位。对于负数，符号位取 1，其余各位由真值各位取反，末尾加 1 得到。</p>
<p><img src="/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/补码运算的推导.png" alt="补码运算的推导"></p>
<p>两个正数相加，两个负数相加，可能会出现<strong>溢出</strong>的情况。</p>
<p>变形补码</p>
<p>为了便于判断运算结果是否溢出，某些计算机中采用了一种双符号位的补码表示方式，也成为变形补码，或者模 4 补码。在双符号位中，左符是真正的符号位，右符用来判别溢出。</p>
<p>反码表示法</p>
<p>负数的补码可用各位求反，末尾加 1 得到，如果仅仅求反而不加 1，得到的是负数的反码表示。</p>
<p>反码表示存在以下不足：0 的表示不为 1，表数范围比补码少 1，运算时需考虑循环进位。</p>
<p>移码表示法</p>
<p>浮点数实际上使用两个定点数来表示的，用一个定点小数来表示浮点数的尾数，一个定点整数表示浮点数的阶。一般来说，浮点数的阶都用一种称为移码的编码方式，通常将阶的编码表示称为<strong>阶码</strong>。</p>
<p>阶可以是正数，也可以是负数。当进行浮点数的加减运算时，必须先对阶，为了简化比较操作，在操作过程中不涉及阶的符号，可以对每个阶都加上一个正的常数，称为<strong>偏置常数（bias）</strong>。</p>
<h4 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h4><p>计算机中的整数分为<strong>无符号整数</strong>和<strong>带符号整数</strong>两种。</p>
<p>省略有关 C 语言相关处理内容。</p>
<h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><h5 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h5><p><img src="/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/浮点数的表示范围.png" alt="浮点数的表示范围"></p>
<p>根据浮点数的格式格式，只要尾数为 0，阶码取任何值都为 0，这样的数被称为<strong>机器零</strong>。因此机器零不唯一。</p>
<h5 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h5><p>规格化数的标志是真值的尾数部分中最高位具有非零数字。</p>
<ul>
<li>右规 当有效数位进到小数点前面时，需要进行右规，右规时，尾数每右移一位，阶码+1</li>
<li>左规 当尾数出现 $ 0.0···bbbb $的结果时，需要进行左规，右规时，尾数每左移一位，阶码-1</li>
</ul>
<h5 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h5><p>32 位包括 1 位符号位 8 位阶码 23 位有效位</p>
<p>64 位包括 1 位符号位 52 位有效位</p>
<p>规格化尾数最高位总是 1，所以隐含表示，省略一位</p>
<p>阶码使用移码表示 大小为 $2^{n-1}-1$</p>
<p>全 0 +0</p>
<p>符号位 1 之后全 0 -0</p>
<p>浮点数除 0 的结果是正负无穷大，而不是一出一场</p>
<p>0 11111111 00000000000000000000000 正无穷大</p>
<p>1 11111111 00000000000000000000000 负无穷大</p>
<p>Not a Number 非数 sqrt(-0.4) 0/0 使用全 1 的阶码和非 0 的尾数</p>
<p>非规格化数 阶码全 0 尾数非 0</p>
<h4 id="十进制数的表示"><a href="#十进制数的表示" class="headerlink" title="十进制数的表示"></a>十进制数的表示</h4><p>ASCII</p>
<p>BCD 码</p>
<p>有权 BCD 码</p>
<p>每个十进制数位的 4 个二进制数位都有一个确定的权，它选取 4 位二进制按照计数顺序的前 10 个代码与十进制数字相对应。每位的权分别为 8，4，2，1，因此称为 8421 码，也称自然 BCD 码。</p>
<p>无权 BCD 码</p>
<p>无权 BCD 码是指每个十进制数位的 4 个基 2 码没有确定的权。如余 3 码和格雷码。</p>
<p>余 3 码是在 8421 BCD 数码的基础上每个码加上 3 （0011）形成的</p>
<p>格雷码在一组数的编码中，任意两个相邻的代码只有一位二进制数不同。最大数和最小数也仅有一位不同，即收尾相连。</p>
<h4 id="数据的宽度和存储"><a href="#数据的宽度和存储" class="headerlink" title="数据的宽度和存储"></a>数据的宽度和存储</h4><h5 id="数据的宽度和单位"><a href="#数据的宽度和单位" class="headerlink" title="数据的宽度和单位"></a>数据的宽度和单位</h5><p><strong>机器字长</strong>是 CPU 内部用于整数运算时的数据通路的宽度，字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度。</p>
<p>描述距离，频率等数值通常用 10 的幂次表示，因而在由时钟频率计算得到的总线带宽或外设数据传输率中，度量单位表示的也是 10 的幂次，通常用 K 表示 1024，k 表示 1000，其他前缀字母均大写，表示大小由上下文决定。</p>
<h5 id="数据的存储和排列顺序"><a href="#数据的存储和排列顺序" class="headerlink" title="数据的存储和排列顺序"></a>数据的存储和排列顺序</h5><p>一般用<strong>最低有效位</strong>和<strong>最高有效位</strong>分别表示数的最低位和最高位。对于带符号的数，最高位就是符号位。</p>
<p>如果以字节为一个排列基本单位 LSB 表示 <strong>最低有效字节</strong>，MSB 表示 <strong>最高有效字节</strong></p>
<p>排列方式有两种，大端和小端</p>
<p>小端方式将最高有效字节放在高地址单元，最低有效字节存放在地地质单元。Intel 80x86 采用小端方式。</p>
<h4 id="数据的基本运算"><a href="#数据的基本运算" class="headerlink" title="数据的基本运算"></a>数据的基本运算</h4><p>!(x^y) 等价于表达式 x == y</p>
<h5 id="左移运算和右移运算"><a href="#左移运算和右移运算" class="headerlink" title="左移运算和右移运算"></a>左移运算和右移运算</h5><p>C 的移位操作有<strong>逻辑移位</strong>和<strong>算数移位</strong>。</p>
<ul>
<li>逻辑移位不考虑符号位的问题，左移时，高位移出，低位补 0。右移时，低位移出，高位补 0。</li>
<li>算数移位左移时，高位移出，低位补 0.右移时，低位移出，高位补符号。</li>
</ul>
<h5 id="位扩展运算和位截断运算"><a href="#位扩展运算和位截断运算" class="headerlink" title="位扩展运算和位截断运算"></a>位扩展运算和位截断运算</h5><p>截断一个数可能因为溢出而改变它的数值。</p>
<h5 id="整数加减运算"><a href="#整数加减运算" class="headerlink" title="整数加减运算"></a>整数加减运算</h5><p>整数加法运算器通常包含以下输出标志：</p>
<ul>
<li>零标志 ZF，当结果所有位都是 0 时，ZF=1，否则，ZF=0</li>
<li>溢出标志 OF，OF=1 表示带符号整数的加减运算发生溢出<br>全加器 溢出标志的逻辑表达式<br>$OF=C<em>n \oplus C</em>(n-1)$<br>因为若为两个正数相加，最高位必然没有进位，而若次高位有进位，则说明溢出 若为两个负数相加，最高位必然有进位，若次高位没有进位，则说明溢出</li>
<li>符号标志 SF 一般取有符号数的最高位</li>
<li>进/借位标志 CF 表示无符号数加减法时的进/借位。加法时，CF=1 表示加法有进位，减法时，CF=1 表示不够减。因此，加法时 CF 等于进位输出 C，减法时，CF 等于进位输出 C 的取反。</li>
</ul>
<h5 id="整数乘除运算"><a href="#整数乘除运算" class="headerlink" title="整数乘除运算"></a>整数乘除运算</h5><p>好难啊，看不懂，先坑着</p>
<h5 id="常量的乘除运算"><a href="#常量的乘除运算" class="headerlink" title="常量的乘除运算"></a>常量的乘除运算</h5><p>编译器在处理变量与常数相乘，往往用移位和加减法组合代替乘法运算。</p>
<h5 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h5><p>加减运算</p>
<script type="math/tex; mode=display">x+y = (M_x\times2^{E_x-E_y}+M_y)\times2^{E_y}</script><script type="math/tex; mode=display">x-y = (M_x\times2^{E_x-E_y}-M_y)\times2^{E_y}</script><p>计算机实现上述过程需要经过对阶，尾数相减，规格化和舍入四个步骤</p>
<p>阶码溢出判断<br>在进行尾数规格化和尾数舍入时，可能会对结果的阶码执行加减运算，必须考虑阶码的溢出问题。如果阶码全为 1，发生阶码上溢，此时可将结果置为无穷，若阶码全为 0，发生阶码下溢，此时可将结果置为 0。</p>
<p>乘除运算</p>
<script type="math/tex; mode=display">x \times y = (M_x \times M_y)\times2^{E_x+E_y}</script><script type="math/tex; mode=display">x \div y = (M_x \times M_y)\times2^{E_x-E_y}</script><p>无需对阶的步骤，但是对于结果的处理步骤是一样的。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础学习笔记</title>
    <url>/2019/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="数字逻辑电路基础"><a href="#数字逻辑电路基础" class="headerlink" title="数字逻辑电路基础"></a>数字逻辑电路基础</h2><p>全加器 溢出标志的逻辑表达式 <script type="math/tex">OF=C_n \oplus C_(n-1)</script> 因为若为两个正数相加，最高位必然没有进位，而弱次高位有进位，则说明溢出 若为两个负数相加，最高位必然有进位，若次高位没有进位，则说明溢出</p>
<h2 id="IEEE754-标准"><a href="#IEEE754-标准" class="headerlink" title="IEEE754 标准"></a>IEEE754 标准</h2><ul>
<li>32 位包括 1 位符号位 8 位阶码 23 位有效位</li>
<li>64 位包括 1 位符号位 52 位有效位</li>
<li>规格化尾数最高位总是 1，所以隐含表示，省略一位</li>
<li>阶码使用移码表示</li>
<li>全 0 +0</li>
<li>符号位 1 之后全 0 -0</li>
<li>浮点数除 0 的结果是正负无穷大，而不是一出一场</li>
<li>0 11111111 00000000000000000000000 正无穷大</li>
<li>1 11111111 00000000000000000000000 负无穷大</li>
<li>Not a Number 非数 sqrt(-0.4) 0/0 使用全 1 的阶码和非 0 的尾数</li>
<li>非规格化数<ul>
<li>阶码全 0 尾数非 0</li>
</ul>
</li>
</ul>
<h4 id="C-语言中涉及的运算"><a href="#C-语言中涉及的运算" class="headerlink" title="C 语言中涉及的运算"></a>C 语言中涉及的运算</h4><ul>
<li>无符号数 逻辑左（右）移动，有符号数 算数左（右）移动</li>
<li>溢出标志 of，最高位和次高位的进位 Cn 异或 Cn-1， 当两个正数相加时，最高位不会进位，若次高位进位，则为溢出 ，当两个负数相加，最高位必然进位，若次高位不进位，则为溢出，正数加负数永远不会溢出</li>
<li>乘法指令分有符号乘和无符号乘 若只取低 n 位 不考虑溢出 则可以只使用无符号乘 由程序员自行判断是否溢出</li>
<li>乘法可以转换成加法和移位运算的组合</li>
<li>对于带符号正数 出了 -2^n / -1 = 2^n-1 会发生溢出外，其余情况都不会发生溢出</li>
<li>对于正数 对商取 floor 对于负数 对商取 ceil</li>
<li>编译器对于除数为 2 的倍数的除法运算使用移位优化，对于无符号数，带符号数正整数，移除的低位直接舍弃，对于带符号负整数，由于商取 ceil，需要现加上一个偏移量 2^k-1，然后再右移 k 位，低位截断</li>
</ul>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>汇编结果是一个可重定位目标文件，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容</p>
<p>生成的.o 文件可重定位的目标文件 程序中的地址尚未确定 通过链接后方可执行</p>
<h4 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h4><p>柱面号就是磁道号</p>
<h4 id="层次结构存储系统"><a href="#层次结构存储系统" class="headerlink" title="层次结构存储系统"></a>层次结构存储系统</h4><ul>
<li>非易失存储器 Nonvolatile Memory 易失存储器 Volitile Memory</li>
<li>SRAM 不采用地址引脚复用方式，DRAM 采用地址引脚复用方式</li>
<li>内存位宽是 64bit DDR3 采用 8 位预读，若内部核心频率为 133.25MHZ，则每秒传送的数据次数为 133.25M*8 = 1066M 次，带宽为 1066 M*8B=8.5GB/S</li>
<li>当写不命中时，有写分配法和非写分配法。采用写分配法时，需要分配一个 cache 空行，以将主存块复制到 cache，当采用非写分配法时，不将主存块分配到 cache。因此，回写策略下，一定采用写分配法，在全写策略下，两种分配方式都可采用</li>
<li>栈和堆合称堆栈，栈区从 0xc0000000 开始向低地址增长，共享库区从 0x400000000 向高地址增长，只读区从 0x08048000 开始向高地址增长。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机系统基础</tag>
      </tags>
  </entry>
  <entry>
    <title>http权威指南</title>
    <url>/2020/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录一下自己不太清楚的知识点</p>
<h2 id="第二章-URL-与资源"><a href="#第二章-URL-与资源" class="headerlink" title="第二章 URL 与资源"></a>第二章 URL 与资源</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>url 的语法 <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p>
<p>基础 URL HTML 标记<code>&lt;BASE&gt;</code>，可以设定基础 URL</p>
<p>URL 编码机制 urlencode 通过转义表示不安全的字符 包含一个百分号(%)，后面跟着两个表示字符 ASCII 码的十六进制数</p>
<h2 id="第三章-HTTP-报文"><a href="#第三章-HTTP-报文" class="headerlink" title="第三章 HTTP 报文"></a>第三章 HTTP 报文</h2><h3 id="报文的组成"><a href="#报文的组成" class="headerlink" title="报文的组成"></a>报文的组成</h3><p>组成 对报文进行描述的其实航 包含属性的首部块 可选的包含数据的主题 body<br>一般只有 PUT 和 POST 方法包含 body<br>PUT 方法的语义是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，如果那个 URL 已经存在的话，就用这个主题来替代它</p>
<p>Http 协议中的 Header 与 Body。Header 的每行最后要加\r\n。Header 与 Body 之间要用\r\n 隔开。Body 后无需加\r\n。</p>
<p>ACSII 码中</p>
<p>‘\n’ 10 换行</p>
<p>‘\r’ 13 回车</p>
<p>也可以表示为’\x0a’和’\x0d’.(16 进制)</p>
<p>示例：HTTP 开始部分为 header，html 部分为 body。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line">Content-Encoding: gzip\r\n</span><br><span class="line">Content-Type: text/xml\r\n</span><br><span class="line">Content-Length: 399\r\n</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">X-Varnish-Cache: HIT\r\n</span><br><span class="line">X-Varnish-Cache-Hits: 1241\r\n</span><br><span class="line">\r\n</span><br><span class="line">&lt;html.....&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>101 Switching Protocols</li>
<li>300 Multiple Choices 请求一个实际指向多个资源的 URL</li>
<li>301 Moved Permanently 响应的 Location 首部包含资源现在所处的 URL</li>
<li>302 Found 响应的 Location 首部的 URL 来临时定位资源 HTTP 1.0</li>
<li>303 See Other HTTP 1.1</li>
<li>307 Temporary Redirect POST 不会转为 GET</li>
</ul>
<p>当 HTTP/1.0 客户端发起一个 POST 请求,并在响应中收到 302 重定向状态码时,它会接受 Location 首部的重定向 URL,并向那个 URL 发起一个 GET 请求(而不会像原始请求中那样发起 POST 请求)。<br>问题出在 HTTP/1.1。HTTP/1.1 规范使用 303 状态码来实现同样的行为(服务器发送 303 状态码来重定向客户端的 POST 请求,在它后面跟上一个 GET 请求)。<br>为了避开这个问题,HTTP/1.1 规范指出,对于 HTTP/1.1 客户端,用 307 状态码取代 302 状态码来进行临时重定向。这样服务器就可以将 302 状态码保留起来,为 HTTP/1.0 客户端使用了。</p>
<h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h3><p>在 HTTP1.1 中默认开启，可以用 Connection:close 关闭，在 HTTP1.0 默认关闭，通过 Connection:keep-alive 开启</p>
<p>哑代理问题，所谓哑代理，是不会处理 Keep-Alive 连接，而是直接将其转发的代理。<br>在网景的变通做法是,浏览器会向代理发送非标准的 Proxy-Connection 扩展首部,而不是官方支持的著名的 Connection 首部。如果代理是盲中继,它会将无意义的 Proxy-Connection 首部转发给 Web 服务器,服务器会忽略此首部,不会带<br>来任何问题。但如果代理是个聪明的代理(能够理解持久连接的握手动作),就用一个 Connection 首部取代无意义的 Proxy-Connection 首部,然后将其发送给服务器,以收到预期的效果。</p>
<p>HTTP1.1 会使用管道优化，将一连串请求放入管道中，但是对于 POST 这个样非幂等的请求不应该放在管道中</p>
<h3 id="代理和网关的区别"><a href="#代理和网关的区别" class="headerlink" title="代理和网关的区别"></a>代理和网关的区别</h3><p>严格来说,代理连接的是两个或多个使用相同协议的应用程序,而网关连接的则是两个或多个使用不同协议的端点。网关扮演的是“协议转换器”的角色,即使客户端和服务器使用的是不同的协议,客户端也可以通过它完成与服务器之间的事务处理。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存有两种，强缓存和协商缓存<br>强缓存使用 Expired 和 Cache Control 字段，不需要向服务器通信<br>协商缓存需要携带协商字段与服务器通信，如果服务器返回 304 NOT Modified 信息，就使用缓存中的资源，并在相应中插入新鲜度信息<br>no-store 不缓存<br>no-cache 在与服务器进行新鲜度验证前不使用缓存</p>
<h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><h5 id="为什么要有代理缓存"><a href="#为什么要有代理缓存" class="headerlink" title="为什么要有代理缓存"></a>为什么要有代理缓存</h5><p>对于源服务器，它是有缓存的，如 Redis，Memcache。但对于 HTTP 缓存来说，如果每次客户端缓存失效都从源服务器获取，那么给源服务器的压力是很大的。<br>由此引入了<strong>缓存代理</strong>机制，让代理服务器接管一部分的服务端 HTTP 缓存。客户端缓存过期后就近到代理服务器缓存中获取，代理缓存过期了才请求源服务器。</p>
<p>缓存代理的控制分为两部分，一部分是源服务器的控制，一部分是客户端的控制。</p>
<h5 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h5><h6 id="private-和-public"><a href="#private-和-public" class="headerlink" title="private 和 public"></a>private 和 public</h6><p>在源服务器的响应头中，会加上 Cache-Control 字段进行缓存的控制，它的值中可以加入 private 或 public 表示是否允许代理服务器缓存。public 表示允许。</p>
<h6 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a>proxy-revalidate</h6><p>must-revalidate 的意思是<strong>客户端</strong>缓存过期就去源服务器获取，而<strong>proxy-revalidate</strong>表示<strong>代理服务器</strong>的缓存过期后到源服务器获取</p>
<p>前者使用范围主体更广，后者不应用于用户代理的本地缓存，应用在缓存服务器上</p>
<h6 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h6><p>s 是 share 的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的 max-age 并不冲突</p>
<h5 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h5><h6 id="客户端宽容设置"><a href="#客户端宽容设置" class="headerlink" title="客户端宽容设置"></a>客户端宽容设置</h6><p>在客户端的请求中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max-stale:5</span><br></pre></td></tr></table></figure>
<p>表示客户端到代理服务器上拿缓存的时候，只要过期时间在 5s 之内，依然可以从代理中获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min-fresh:5</span><br></pre></td></tr></table></figure>
<p>表示客户端到代理服务器上拿缓存的时候，一定要在过期前 5s 之前的时间内</p>
<h6 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h6><p>表示客户端只会接受代理缓存，而不会接受源服务器的响应，如果代理缓存无效，则直接返回 504</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>CSRF Cross Site Request Forgery<br>点击劫持 设置 X-FRAME-OPTIONS</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="cookie-的域名属性"><a href="#cookie-的域名属性" class="headerlink" title="cookie 的域名属性"></a>cookie 的域名属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-cookie: user=&quot;mary17&quot;; domain=&quot;airtravelbargains.com&quot;</span><br></pre></td></tr></table></figure>
<p>将 cookie user=”mary17” 发送给域 “.airtravelbargains.com” 中的所有站点:</p>
<h4 id="cookie-的路径属性"><a href="#cookie-的路径属性" class="headerlink" title="cookie 的路径属性"></a>cookie 的路径属性</h4><p>cookie 规范允许用户将 cookie 与部分 Web 站点关联起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-cookie: pref=compact; domain=&quot;airtravelbargains.com&quot;; path=/autos/</span><br></pre></td></tr></table></figure>
<p>如果用户访问 <code>http://www.airtravelbargains.com/specials.html</code>,就只会获得这个 cookie:<br>Cookie: user=”mary17”<br>但 如 果 访 问 <code>http://www.airtravelbargains.com/autos/cheapo/index.html</code>, 就会获得这两个 cookie:<br>Cookie: user=”mary17”<br>Cookie: pref=compact<br>Cache-Control:no-cache=” Set-Cookie” 除了 cookie 以外是可以缓存的</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="HTTP-首部参考"><a href="#HTTP-首部参考" class="headerlink" title="HTTP 首部参考"></a>HTTP 首部参考</h3><ul>
<li>Accept</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept */* 表示所有类型</span><br><span class="line">Accept: text/*, image/* 图片</span><br><span class="line">Accept: text/*, image/gif, image/jpeg; q=1 图片 q表示质量</span><br></pre></td></tr></table></figure>
<ul>
<li>Age HTTP/1.1 缓存必须在发送的每条响应中都包含一个 Age 首部</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记之传输层</title>
    <url>/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>本篇笔记是 计算机网络-自顶而下分析 第六版 第三章的学习笔记。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>运输层协议是运行在端系统而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段 segment。实现的方法(可能)是将应用报文划分为较小的块，并为每块<br>加上一个运输层首部以生成运输层报文段 然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组(即数据报)并向目的地发送。:网络路由器仅作用于该数据报的网络层字段;即它们不检查封装在该数据报的运输层报文段的字段 在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层 运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<h4 id="与网络层的关系"><a href="#与网络层的关系" class="headerlink" title="与网络层的关系"></a>与网络层的关系</h4><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。即使底层网络协议是不可靠的，也就是说网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务。</p>
<h4 id="概述运输层服务"><a href="#概述运输层服务" class="headerlink" title="概述运输层服务"></a>概述运输层服务</h4><p>因特网网络层协议有一个名字叫 IP ，即网际协议 IP 主机之间提供了逻辑通信 IP 的服务模型是尽力而为交付服务( besl- e[[ort delivery service)。这意味着 IP 尽它”最大的努力”在通信的主机之间交忖报文段，但它并不做任何确保<br>特别是，它不确保报文段的交付 不保证报文段的按序交付，不保证报文段数据的完整。由于这些原因， IP 被称为不可靠服务 (unreliable service) 在此还要指出的是，每台主机至少有一个网络层地址，即所谓的 IP 地址。</p>
<p>UDP TCP 最基本的责任是，将两个端系统间 的交付服务扩展为运行在端系统上的两个进程之间的交付服务 将主机间交付扩展到进程间交付被称为运输层的多路复用( transport -layer multiplexing) 与多路分解( demultiplexing) 。</p>
<p>与 IP 一样， UDP 也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地(或全部! )到达目的进程。<br>TCP 为应用程序提供了几种附加服务 首先，它提供可靠数据传输( reliable dala tTansfer) 通过使用流量控制、序号、确认和定时器(本章将详细介绍这些技术)， TCP 确保正确地、按序地将数据从发送进程交付给接收进程。<br>TCP 还提供拥塞控制( congestion conlrol) 。TCP 力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽 这可以通过调节 TCP 连接的发送端发送进网络的流量速率来做到 在另一方面， UDP 流量是不可调节的 使用 UDP 传输的应用程序可以根据其需要以其愿意的任何速率发送数据。</p>
<h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p><strong>多路复用的要求是</strong></p>
<ul>
<li>套接宇有唯一标识符</li>
<li>每个报文段有特殊字段来指示该报文段所要交付到的套接字</li>
</ul>
<p>这些特殊字段是源端口号字段 (source port oumber field) 和目的端口号字段 (destination port nurnber field)。端口号’是一个 16 比特的数，其大小在 0-65535。<br>0-1023 范围的端口号称为周知端口号( well- known porl number) ，是受限制的，这是指它们保留给诸如 HTTP (它使用端口号 80) 和盯’p (它使用端口号 1)之类的周知应用层协议来使用。</p>
<p>假设主机 A B 进行 UDP 通信，主机 能够运行多个进程，每个进程有自己的 UDP 套接字及相应的端口号。当从网络到达 UDP 报文段时，主机 通过检查该报文段中的目的端口号，将每个报文段定向(分解)到相应的套接字。</p>
<p>一个 UDP 套接字是由一个二元组来全面标识的，该二元组包含一个目的 地址和一个目的端口号。</p>
<p>服务器主机可以支持很多并行的 TCP 套接字，每个套接字与一个进程相联系，并由其四元组（源地址，源端口，目的地址，目的端口）来标识每个套接字。</p>
<h3 id="无连接服务-UDP"><a href="#无连接服务-UDP" class="headerlink" title="无连接服务 UDP"></a>无连接服务 UDP</h3><h4 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h4><p>UDP 首部只有 4 个字段（源端口号，目的端口号，长度，检验和），每个字段由两个字节组成。长度字 32 比特段指示了在 UDP 报文段中的字节数(首部加数据) 。因为数据字段在一个 UDP 段中不同于另一个段中，需要一个明确的长度。接收方使用检验和来检查该报文段中是否出现了差错。</p>
<h4 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h4><p>发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在 UDP 报文段中的检验和字段。在接收方，如果没有差错，全部的数据段 16 比特字加上检验和的和将是 1111111111111111。</p>
<p>为什么 UDP 提供了检验和。许多链路层协议，包括流行的以太计算机网协议，也提供了差错检测，其原因是不能保证源和目的之间的所有链路都提供插座检测。这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。在既无法确保连链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测， UDP 就必须在端到端基础上在运输层提供差错检测。这是 个在系统设计巾被称颂的端到端原则( end - end principle)。</p>
<p>因为假定 IP 是可以运行在任何第二层协议之上的，运输层提供差错检测作为 种保险措施是非常有用的 虽然 UDP 提供差错检测，但它对差错恢复无能为力。 UDP 的某种实现只是丢弃受损的报文段; 其他实现是将受损的报文段交给应用程序并给出警告。</p>
<h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><p>本节一步步研究一系列协议，逐步构建一个无错、可靠的数据传输协议。</p>
<h4 id="经完全可靠信道的可靠传输-rdt-1-0"><a href="#经完全可靠信道的可靠传输-rdt-1-0" class="headerlink" title="经完全可靠信道的可靠传输 rdt 1.0"></a>经完全可靠信道的可靠传输 rdt 1.0</h4><p>首先考虑最简单的情况，即底层信道是完全可靠的。<br><img src="/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/rdt1.0.png" alt="rdt1.0"></p>
<p>在这个简单的协议中，一个单元数据与一个分组没差别。，所有计算机#### 经具有比特差错信道的可靠数据传输 rdt 2.0</p>
<p>底层信道更为实际的模型是分组中的比特可能受损 在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中 我们眼下还将继续假定所有发送的分组(虽然有些比特可能受损)将按其发送的顺序被接收。</p>
<p>协议使用了<strong>肯定确认</strong>与<strong>否定确认</strong>，这种形式使得接收方可以让发送方知道那些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这种重传机制的可靠传输协议被称为 <strong>自动重传请求（Automatic Repeat reQuest，ARQ）协议</strong>。</p>
<p>ARQ 协议还需要另外三种协议功能来处理存在比特差错的情况。</p>
<ul>
<li>差错检测 需要一种机制以使接收方检测到何时出现了比特差错</li>
<li>接收方反馈 因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里，发送方要了解接收方情况(此时为分组是再被正确接收)的唯一途径就是让接收方提供明确的反馈信息给发送方</li>
<li>重传 接收方收到有差错的分组时，发送方将重传该分组文</li>
</ul>
<p><img src="/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.0.png" alt="rdt2.0"></p>
<p>目前该协议有一个致命缺陷，没有考虑到 ACK 或者 NAK 分组受损的可能性。</p>
<p>可以在发送方收到受损的 ACK 或 NAK 分组时，重传当前数据分组，但是这种方法引入了 <strong>冗余分组</strong>，其根本困难在于接收方不知道它上次所发送的 ACK 或者 NAK 是否被发送方正确地收到，因此它无法事先知道接收到的分组是新的还是一次重传。</p>
<p>解决这个问题的一个简单方法，是在数据分组增加一个新字段，让发送方对其数据分组编号，即将发送数据的分组的序号放在该字段，接收方只需要检查序号即可确定收到的分组是否一次重传。对于停等协议，1 比特序号就足够了，因为它可以让接收方知道发送方是否正在重传前一个发送分组（接收到的分组序号与最近收到的分组序号相同），或是一个新分组（序号变化了）。</p>
<h4 id="具有比特差错的丢包信道的可靠数据传输-rdt-3-0"><a href="#具有比特差错的丢包信道的可靠数据传输-rdt-3-0" class="headerlink" title="具有比特差错的丢包信道的可靠数据传输 rdt 3.0"></a>具有比特差错的丢包信道的可靠数据传输 rdt 3.0</h4><p>问题是怎么检测丢包以及发生丢包后该做什么。为了解决检测丢包的问题，还需要增加新的协议机制。</p>
<p>假定发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失，如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需要重传该数据分组即可。这个时间至少应当是发送方和接受方之间的一个往返时延，加上接收方处理一个分组所需要的时间。</p>
<p>为了实现基于时间的重传机制，需要一个倒计数定时器。发送方需要做到：1. 每次发送一个分组时，启动一个定时器 2. 响应定时器中断 3. 终止定时器</p>
<h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>上述 rdt 3.0 协议的问题在于它是一个停等协议，对于信道的利用率太低。如果每次可以发送多个分组，那么需要增加以下机制：</p>
<ul>
<li>必须增加序号范围，每个输送中的分组必须有一个唯一的序号，而且也许有多个输送中未确认的报文</li>
<li>协议的发送方和接收方也许必须缓存多个分组</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。解决流水线的差错恢复有两种基本方法：<strong>回退 N 步</strong>和<strong>选择重传</strong></li>
</ul>
<h4 id="回退-N-步"><a href="#回退-N-步" class="headerlink" title="回退 N 步"></a>回退 N 步</h4><p>那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 的窗口 随着协议的运行，该窗口在序号空间向前滑动。因此 N 常被称为窗口长度 (window size) , GBN 协议也常被称为滑动窗口协议。<br>为什么要限制这些被发送的、未被确认的分组的数目为 N 呢？流量控制是对发送发施加限制的原因之一，拥塞控制则是另一个原因。</p>
<p><img src="/2020/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/GBN.png" alt="GBN"></p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络学习笔记之概述</title>
    <url>/2018/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul>
<li>对等连接 即 p2p（peer to peer），是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（p2p 软件），他们就可以进行对等，平等连接通信，这时，双方下载对方已经存储在硬盘中的共享文档。对等连接工作方式可以支持大量对等用户同事工作</li>
<li>在互联网的信息起特殊作用的是路由器，它是一种专用计算机，是实现分组交换（packet switching）的关键构建，其任务是转发收到的分组。</li>
<li>电路交换的一个重要特点是，在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。使用电路交换来传送计算机数据时，传输效率往往很低，因为计算机数据是突发地出现在传输线路上的，真正用来传送数据的时间很短，被用户占用的通信线路资源在大部分时间都是空闲的。</li>
<li>分组交换采用存储转发技术，路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。</li>
<li>边缘部分 由所有连接在因特网上的主机组成，由用户直接使用，用来运行各种网络应用，为用户直接提供各种网络服务</li>
<li>核心部分 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的</li>
</ul>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ul>
<li>速率 指的是数据的传送速度，单位是 bit/s</li>
<li>带宽 在计算机网络中，表示网络中某通道传送数据的能力，表示在单位时间内网络中某信道所能通过的“最高数据率”，单位是 bit/s</li>
<li>吞吐量 表示在单位时间内通过某个网络（或者信道，接口）的实际的数据量 额定速度 1Gbit/s 的以太网，实际拓扑两可能只是 100Mbit/s</li>
<li>时延（delay 或者 latency）是指数据（一个报文或分组，甚至比特）从网络（或者链路）的一个端传送到另一端所需的时间。<ul>
<li>发送时延 是主机或路由器发送数据帧所需要的时间<br>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li>
<li>传播时延 是电磁波在信道中传播一定的距离需要花费的时间<br>传播时延长 = 信道长度（m）/ 电磁波在信道上的传播速率（m/s）<br>电磁波在自由空间的传播速率是光速，在光纤中速率约为 2.0 * 10^5km/s，1000km 长的光纤线路的传播时延大约为 5ms</li>
<li>处理时延 主机或路由器在收到分组时要花费一定的时间进行处理造成的时延</li>
<li>排队时延 分组在经过网络传输时，要经过许多路由器，分组进入路由器后，要先在输入队列中排队等待处理</li>
<li>时延带宽积 又称为以比特为单位的链路长度<br>时延带宽积 = 传播时延 * 带宽</li>
<li>往返时间 RTT 即数据双向交互一次所需要的时间</li>
<li>利用率 有信道利用率和网络利用率两种。信道或网络利用率过高会产生非常大的时延。</li>
</ul>
</li>
<li>OSI（open system interconnection）开放系统互联标准，只是法律上的国际标准，TCP/IP 是实际上的国际标准<br>OSI 的七层模型包括应用层，表示层，会话层，运输层，网络层，数据链路层，物理层<br>TCP/IP 的四层模型包括应用层（TELNET，FTP，SMTP），传输层（TCP/UDP），网际层（IP），网络接口层<br>在学习计算机网络原理时，采取这种的办法，采用一种五层协议，包括应用层，运输层，网络层，数据链路层，物理层<ul>
<li>应用层 任务是通过应用程序间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则，对于不同的网络应用需要有不同的应用层协议，包括 HTTP 协议，域名系统 DNS，SMTP，应用层交互的数据单元称为报文</li>
<li>运输层 任务是负责向两台主机中进程之间的通信提供通用的数据传输服务，主要使用两种协议<br>传输控制协议 TCP（Transmission Control Protocol），提供面向连接的，可靠的数据传输服务，其数据传输的单位是报文段（segment）<br>用户数据包协议 UDP（User Datagram Protocol），提供无连接的，尽最大努力的数据传输服务，不保证可靠性，传输的单位是用户数据报</li>
<li>网络层 负责为分组交换网上的不同主机提供通信服务。在发送数据是，网络层把运输层产生的报文或用户数据报封装成分组或包进行传送。在 TCP/IP 体系中，网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称数据报。</li>
<li>数据链路层 将网络层交下来的 IP 数据报组装成数据帧（framing），在两个相邻节点的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制）。控制信息能使接受端能检测到所收到的帧有无差错，如果有差错，数据链路层就简单的丢弃这个出了差错的帧，如果有需要改正的数据在传输中出现了差错，就要采用可靠传输协议来纠错</li>
<li>物理层 在物理层上所传数据的单位是比特</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记之物理层</title>
    <url>/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><ul>
<li>物理层的作用是尽可能屏蔽掉传输媒体和通信手段的差异，用于物理层的协议常称为规程（procedure）</li>
<li>数据在通信线路上的传输方式一般都是串行传输</li>
<li>可以将物理层的主要任务描述为与传输媒体的接口有关的一些特性<ul>
<li>机械特性</li>
<li>电气特性</li>
<li>功能特性</li>
<li>过程特性</li>
</ul>
</li>
</ul>
<h3 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h3><h4 id="数据通信的基本模型"><a href="#数据通信的基本模型" class="headerlink" title="数据通信的基本模型"></a>数据通信的基本模型</h4><ul>
<li>一个数据通信系统可以分为三大部分，即源系统（发送端，发送方）、传输系统（或传输网络）和目的系统（接受端、接收方）。<ul>
<li><strong>源点</strong> 源点设备产生要传输的数据，如从计算机的键盘输入汉字，计算机产生输出的数字比特流。又称源站或者信源。</li>
<li><strong>发送器</strong> 源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器是调制器。</li>
<li><strong>接收器</strong> 接受传输系统传送过来的信号，把它转换为能够被目的设备处理的信息。典型的接收器就是解除调器。它把模拟信号解调，还原成数字信号</li>
<li><strong>终点</strong> 终点设备从接收器获取传送来的数字比特流，然后把信息输出（例如，把汉字在计算机屏幕上显示出来）。终点站又称目的站，或信宿。</li>
</ul>
</li>
<li>通信的目的是传送<strong>消息（message）</strong>，如话音，文字，图像，视频都是消息</li>
<li><strong>数据（data）</strong>是运送消息的实体，通常是有意义的符号序列</li>
<li>信号是数据的电气或者电磁的表现</li>
<li><strong>模拟信号</strong>，或<strong>连续信号</strong>，代表消息的参数的取值是连续的</li>
<li><strong>数字信号</strong>，或<strong>离散信号</strong>，代表消息的参数的取值是离散的</li>
</ul>
<h4 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h4><ul>
<li><strong>信道</strong>（channel）表示向某一个方向传送消息的媒体</li>
<li><strong>单向通信</strong>，又称为<strong>单工通信</strong>，只有一个方向的通信而没有反方向的交互，代表有无线电广播或者有线电广播</li>
<li><strong>双向交替通信</strong>，又称为<strong>半双工通信</strong>，通信的双方都可以发送消息，但不能双方同时发送或接受</li>
<li><strong>双向同时通信</strong>，又称为<strong>全双工通信</strong>，通信的双方可以同时发送和接收信息</li>
<li>来自信源的信号常称为<strong>基带信号</strong>，即基本频带信号。基带信号往往包含较多低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或者直流分量，因此必须对基带信号进行<strong>调制（modulation）</strong><ul>
<li><strong>基带调制</strong>，仅仅对基带信号的波形进行变换，使它能够与信道的特性相适应，这种过程是把狮子信号转换成另一种形式的数字信号，也称为<strong>编码</strong></li>
<li>使用<strong>载波（carrier）</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并且转换为模拟信号，这样就能够更好地在模拟信道中传输，经过载波调制后的信号称为<strong>带通信号</strong>（仅在一段频率范围内能够通过信道，可以被正弦公式描述，又叫做宽带信号，其携带的数据量更多），使用载波的调制称为带通调制。</li>
<li>对模拟信号数字化取样，将抽样信号变为离散时间，离散幅度的数字化信号，编码后称为一个二进制码组输出，这种方式叫做<strong>脉编调制</strong>，是 VCD 和 DVD 的视频编码原理。</li>
</ul>
</li>
<li>常用编码方式<br><img src="/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/编码方式.jpg" alt="常用的编码方式"><br><em> <strong>不归零制</strong> 正电平代表 1 复电平代表 0
</em> <strong>归零制</strong> 正脉冲代表 1，负脉冲代表 0<br><em> <strong>曼彻斯特编码</strong> 位周期中心的向上跳代表 0，向下跳代表 1，也可以反过来定义
</em> <strong>差分曼彻斯特编码</strong> 在每一位的中心处都有跳变，位开始边界有跳变代表 0，位开始边界没有跳变代表 1 * 不归零不能从波形本身提取信号时钟频率，这叫做没有自同步能力，而曼彻斯特编码具有自同步能力</li>
<li>基本的带通调制方法<br><img src="/2019/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/带通调制方法.jpg" alt="基本的带通调制方法"><br><em> <strong>调幅（AM）</strong> 载波的振幅随着基带数字信号而变化，如 0 或者 1 分别对应无载波或者有载波输出
</em> <strong>调频（FM）</strong> 载波的频率随着基带数字信号而变化，如 0 或者 1 分别对应于频率 f1 或者 f2 * <strong>调相（PM）</strong> 载波的初始相位随着基带数字变化而变化，如 0 或者 1 分别对应于相位 0 或者 180 度</li>
<li>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法，例如<strong>正交振幅调制 QAM（Quadrature Amplitede Modulation）</strong></li>
</ul>
<h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><ul>
<li><strong>码间串扰</strong>是指信号中的高频分量在传输时收到缩减，接收端收到的波形前沿和后沿不再那么陡峭，码元之间的时间间隔也不明确，码元之间失去了清晰的界限</li>
<li><strong>奈氏准则</strong>给出了假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。我们需要知道，在任何信道，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的识别称为不可能</li>
<li><strong>信噪比</strong> 是信号的平均功率和噪声的平均功率之比，常记为 S/N，并用分贝作为度量<script type="math/tex; mode=display">信噪比(dB) = 10 log_{10}(S/N)</script></li>
<li>香农公式指出 信道的极限信息传输速率 C 是，W 是信道的带宽，S 是信道内所传信号的平均速率，N 为信道内部的高斯噪声功率，它表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高<script type="math/tex; mode=display">C = W log_{2}(1+S/N) (bit/s)</script></li>
<li>对于频带宽度已经确定的信道，如果信噪比不能再提高，码元传输速率也达到了上限，可以用编码的方法让每一个码元携带更多比特的信息量</li>
</ul>
<h4 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h4><ul>
<li><strong>传输媒体</strong>也称为传输介质或者传播媒介<ul>
<li><strong>导引型传输媒体</strong> 电磁波沿着固定媒介（铜线或者光纤）传播</li>
<li><strong>非导引型传输媒体</strong> 媒介是自由空间，称为无线传输</li>
</ul>
</li>
</ul>
<h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul>
<li>导引型传输媒体<ul>
<li>双绞线 把两根互相绝缘的铜导线并排放在一起，然后<strong>绞合（twist）</strong>起来。绞合可以减少对相邻导线的电磁干扰</li>
<li>同轴电缆 由内导体铜质芯线（单股实心线或多股绞合线），绝缘层，网状编织体的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成，具有很好的抗干扰特性</li>
<li>光缆</li>
</ul>
</li>
</ul>
<h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><ul>
<li>非导引型传输媒体<ul>
<li>甚高频</li>
<li>特高频</li>
<li>超高频</li>
<li>极高频</li>
</ul>
</li>
<li>短波通信（高频通信）主要靠电离层的反射。但电离层不稳定所产生的衰落现象和电离层反射产生的多径效应，使得短波信道的通话质量较差，因此短波无线电台传输数据一般都是低速传输</li>
<li>传统的微波通信主要有两种方式，地面微波接力通信（通过中继站）和卫星通信</li>
</ul>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="频分复用，时分复用和统计时分复用"><a href="#频分复用，时分复用和统计时分复用" class="headerlink" title="频分复用，时分复用和统计时分复用"></a>频分复用，时分复用和统计时分复用</h4><ul>
<li><strong>频分复用</strong>的所有用户在同样的时间占用不同的带宽资源</li>
<li><strong>时分复用</strong>是所有的用户在不同的时间占用同样的频带宽度</li>
<li>复用器和分用器成对地使用</li>
<li>分用器的作用和复用器相反，它把高速信道传送过来的数据进行分用，分别送交到相应的用户</li>
<li><strong>统计时分复用（Statistic TDM）</strong>是一种改进的时分复用，它能明显地提高信道的利用率，集中器常使用这种统计时分复用。其用 STDM 帧传送复用的数据，每一个 STDM 帧小于连接在集中器上的用户数。各个用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入 STDM 帧中，对没有数据的缓存就跳过去，当一个帧的数据放满了，就发送出去。因此 STDM 帧不是固定分配时间间隙，而是按需动态的分配时间间隙。</li>
</ul>
<h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><ul>
<li><strong>波分复用（Wavelength Division Multiplexing）</strong>就是光的频分复用。</li>
</ul>
<h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><ul>
<li><strong>码分复用（Code Division Multiplexing）</strong> 更常用的名词是<strong>码分多址 CDMA（Code Division Multiple Access）</strong>。各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰，这种系统有很强的抗干扰能力</li>
<li>CDMA 使用了<strong>扩频（spread spectrum）</strong>的方式，属于<strong>直接序列扩频 DSSS（Direct Sequence Spread Spectrum）</strong>，另一种是<strong>跳频扩频 FHSS（Frequency Hopping Spread Spectrum）</strong></li>
</ul>
<h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><ul>
<li>最初在数字传输系统中使用的传输标准是<strong>脉冲编码调制 PCM</strong>，现在的高速数字传输系统使用同步光纤网<strong>SONET</strong>（美国标准）或者<strong>同步数字系列 SDH（Synchronous Digital Hierarchy）</strong>（国际标准）</li>
</ul>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><ul>
<li><strong>非对称数字用户线 ADSL（Asymmetric Digital Subscriber LIne）</strong>是用数字技术对现有的模拟电话用户线进行改造，使其能够承载数字宽带业务。他需要在用户线的两端各安装一个 ADSL 调制解调器，我国采用的是<strong>离散多音调 DMT（Discrete Multi-Tone）</strong>调制技术。ADSL 不能保证固定的数据率。</li>
<li>基于 ADSL 的接入网由数字用户线接入复用器，用户线和用户家中的一些设施三部分组成<ul>
<li><strong>数字用户线接入复用器 ASLAM（DSL Access Multiplexer）</strong>，包括许多 ADSL 调制解调器，ADSL 调制解调器又称为<strong>接入端单元 ATU（Access Termination Unit）</strong></li>
<li>用户电话通过<strong>电话分离器</strong>和 ATU-R（远端站的调制解调器）连接，它利用低通滤波器将电话信号和数字信号分开。</li>
<li>ADSL 有两个接口，较大的 RJ-45 和计算机相连，较小的 RJ-11 和电话分离器项链。</li>
</ul>
</li>
</ul>
<h4 id="光纤同轴混合网（HFC-网）"><a href="#光纤同轴混合网（HFC-网）" class="headerlink" title="光纤同轴混合网（HFC 网）"></a>光纤同轴混合网（HFC 网）</h4><ul>
<li><strong>光纤同轴混合网 HFC（Hybird Fiber Coax）</strong>是在有线电视网的基础，对有线电视网进行了改造，将有线电视网中的同轴电缆主干部分改换为光纤。光纤藏头端连接到<strong>光纤节点（fiber node）</strong>，在光纤节点被转换为电信号，然后通过同轴电缆传输到每个用户家庭。</li>
<li>为了使现有的模拟电视机能够接受数字电视信号，需要<strong>机顶盒（set-top box）</strong>。为了用户利用 HFC 网接入互联网，还需要增加<strong>电缆调制解调器（cable modem）</strong></li>
</ul>
<h4 id="光纤入户（FTTX）"><a href="#光纤入户（FTTX）" class="headerlink" title="光纤入户（FTTX）"></a>光纤入户（FTTX）</h4><ul>
<li><strong>光纤入户（Fiber To The Home）</strong>是技术上的最好选择，将光纤一直铺设到用户家庭，在光纤入户后，才将光信号转换为电信号。</li>
<li>一个家庭远用不了一根光纤的通信容量，在光纤干线和广大用户之间，还铺设一段中间的转换装置即<strong>光配线网 ODN（Optical Distribution Network）</strong>，使数十个家庭能够共享一根光纤干线。</li>
<li><strong>光线路终端 OLT（Optical Line Terminal）</strong>是连接到光纤干线的终端设备，OLT 把收到的下行数据发往无源的 1：N 的<strong>光分路器（splitter）</strong>，然后用广播的方式向所有用户端的<strong>光网络单元 ONU（Optical Network Unit）</strong>发送。当 ONU 发送上行数据术，先将电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 的方式发往 OLT，发送时间和长度都有 OLT 集中控制。</li>
<li>光配线网采用波分复用，上行和下行分别使用不同的波长</li>
<li>最流行的无源光配线网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记之网络层</title>
    <url>/2020/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>网络层是实现主机到主机的通信服务的。每一台主机和路由器都有一个网络层部分。网络层协议是协议栈中最具挑战性的部分。</p>
<p><strong>转发</strong>涉及分组在单一的路由器中从一条入链路到一条出链路的传送。<strong>路由选择</strong>涉及一个网络的所有路由器，他们经路由选择协议共同交互，以决定分组从源到目的地节点所采用的路径。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美学习笔记1</title>
    <url>/2020/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="封装、抽象、继承、多态"><a href="#封装、抽象、继承、多态" class="headerlink" title="封装、抽象、继承、多态"></a>封装、抽象、继承、多态</h3><p>面向对象的关键是其四大特性</p>
<h4 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h4><p>也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。<br>课程中提供的代码是 java，我用 ts 重新实现了一遍，当做是练习 ts 的熟练度了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> id: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> createTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">private</span> balance: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> balanceLastModifiedTime: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.createTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getId(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> getCreateTime(): <span class="built_in">Date</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.createTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> getBalance(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> getBalanceLastModifiedTime(): <span class="built_in">Date</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.balanceLastModifiedTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> increaseBalance(amount: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance += amount;</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> decreaseBalance(amount: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于封装这个特性，需要编程语言本身提供访问权限控制的语法机制来支持。</p>
<p>之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所有只提供 get 方法，这两个属性的初始化设置，对于调用者也是透明的，所以不提供用构造参数的方式进行外部赋值。</p>
<p>对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。alanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改，所以其相关的操作，都封装在 increaseBalance() 和 decreaseBalance() 方法中了</p>
<p><strong>封装可以解决这些问题</strong></p>
<p>如果对类中的属性访问不做控制，类的属性可能在代码的各个角落被随意修改，影响代码的可读性和可维护性<br>类通过有效的方法暴露必要的操作，也可以提高类的易用性</p>
<h4 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h4><p>隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Picture &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  blob: Blob;</span><br><span class="line">  metaInfo: <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IPictureStorage &#123;</span><br><span class="line">  savePicture(pic: Picture): <span class="built_in">void</span>;</span><br><span class="line">  getPicture(id: <span class="built_in">string</span>): Picture;</span><br><span class="line">  deletePicture(id: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  midifyMetaInfo(id: <span class="built_in">string</span>, <span class="attr">metaInfo</span>: <span class="built_in">Object</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureStorage</span> <span class="title">implements</span> <span class="title">IPictureStorage</span> </span>&#123;</span><br><span class="line">  savePicture(pic: Picture): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  getPicture(id: <span class="built_in">string</span>): Picture &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">blob</span>: <span class="keyword">new</span> Blob(),</span><br><span class="line">      <span class="attr">metaInfo</span>: &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  deletePicture(id: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">midifyMetaInfo</span>(<span class="params">id: <span class="built_in">string</span>, metaInfo: <span class="built_in">Object</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象这个特性非常用以实现，不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，函数本身就是一种抽象。</p>
<p>相较于课程中代码，为了简化代码，有所改动。调用者在使用图片存储功能时，只需要了解 IPictureStorage 暴露了哪些方法就可以了，不需要查看 PictureStorage 里面的具体实现。</p>
<p><strong>抽象可以解决这些问题</strong></p>
<p>只关注功能点，不关注实现，很多设计原则体现了抽象的设计思想，如基于接口而非实现编程，开闭原则，代码解耦。我们在定义方法的时候，也要有抽象思维，不要再方法定义中，暴露太多的细节。如 getAliyunPictureUrl() 就不好，如果某一天讲图片存储地址改变了，那么函数命名也要改变，相反，应该叫做 getPictureUrl()，即便内部存储方式修改了，我们也不需要修改命名</p>
<h4 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h4><p>上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。</p>
<p>度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。我们应当 “多用组合少用继承”</p>
<h4 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h4><p>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</p>
<p>这里就没有改写课程中的代码，换了一个更浅显的例子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;animal bark&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;dog wang wang&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;cat miao miao&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlayWith</span>(<span class="params">ani: Animal</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  ani.bark();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">PlayWith(dog);</span><br><span class="line">PlayWith(cat);</span><br></pre></td></tr></table></figure>
<p>多态需要编程语言拥有一下特殊语法机制</p>
<ul>
<li>编程语言要支持父类对象可以引用子类对象</li>
<li>第二个语法机制是编程语言要支持继承</li>
<li>第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法</li>
</ul>
<p>多态除了利用 继承加方法重写的方式来实现外，还有两种比较常见的实现方式，一个是利用接口类语法，另一个是 duck-typing 语法。</p>
<h5 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CanBark &#123;</span><br><span class="line">  bark(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="title">implements</span> <span class="title">CanBark</span> </span>&#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;老虎吼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="title">implements</span> <span class="title">CanBark</span> </span>&#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;狮子吼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LookAt</span>(<span class="params">ani: CanBark</span>) </span>&#123;</span><br><span class="line">  ani.bark();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lion = <span class="keyword">new</span> Lion();</span><br><span class="line"></span><br><span class="line">LookAt(tiger);</span><br><span class="line"></span><br><span class="line">LookAt(lion);</span><br></pre></td></tr></table></figure>
<h5 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck-typing"></a>duck-typing</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CanBark &#123;</span><br><span class="line">  bark(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tiger = &#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;老虎吼&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lion = &#123;</span><br><span class="line">  bark(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;狮子吼&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LookAt</span>(<span class="params">ani: CanBark</span>) </span>&#123;</span><br><span class="line">  ani.bark();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LookAt(tiger);</span><br><span class="line"></span><br><span class="line">LookAt(lion);</span><br></pre></td></tr></table></figure>
<p>多态能提高代码的可扩展性和复用性，也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p>
<h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p>
<h4 id="基于接口而非基于实现编程"><a href="#基于接口而非基于实现编程" class="headerlink" title="基于接口而非基于实现编程"></a>基于接口而非基于实现编程</h4><p><strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong></p>
<p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。</p>
<p>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>而有一天，我们要将图片改为上传到私有云，首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。<br>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。</p>
<p>而要解决这些问题，编写代码的时候，要遵从 “基于接口而非实现编程”的原则</p>
<ul>
<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>
<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>
<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ul>
<p>在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p>
<h5 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h5><p>在项目中很多地方，我们都是通过下面第 8 行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">&quot;ai_images_bucket&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; Image image = ...;</span><br><span class="line">    ImageStore imageStore = <span class="keyword">new</span> PrivateImageStore(<span class="comment">/*省略构造函数*/</span>);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了评论区的答案，一种比较好的解决方式是使用工厂方法+配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);</span><br></pre></td></tr></table></figure>
<h4 id="多用组合-少用继承"><a href="#多用组合-少用继承" class="headerlink" title="多用组合 少用继承"></a>多用组合 少用继承</h4><p>继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决继承存在的问题。</p>
<p>接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Flyable &#123;</span><br><span class="line">  fly(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyAbility</span> <span class="title">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">fly</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fly&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Tweetable &#123;</span><br><span class="line">  tweet(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetAbility</span> <span class="title">implements</span> <span class="title">Tweetable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">tweet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;tweet&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Egglayable &#123;</span><br><span class="line">  egglay(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EgglayAbility</span> <span class="title">implements</span> <span class="title">Egglayable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">egglay</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;egglay&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="title">implements</span> <span class="title">TweetAbility</span>, <span class="title">EgglayAbility</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> tweetAbility = <span class="keyword">new</span> TweetAbility();</span><br><span class="line">  <span class="keyword">private</span> egglayAbility = <span class="keyword">new</span> EgglayAbility();</span><br><span class="line">  <span class="keyword">public</span> tweet(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tweetAbility.tweet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> egglay(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.egglayAbility.egglay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>cron计划任务</title>
    <url>/2019/09/13/%E8%BF%90%E7%BB%B4/cron%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>cron 在类 Unix 系统中是一种基于时间的的任务调度器(job scheduler)，其有多种实现，在 archlinux 中，可以使用 pacman -S cronie 安装该软件。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>开启启动 systemctl enable cronie<br>编辑，推荐使用命令，crontab -e，默认的编辑器是 vim，可以使用 EXPORT EDITOR=XXX 覆盖设置</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习</title>
    <url>/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>强烈推荐这个博主的系列文章 <a href="https://blog.csdn.net/u011541946/category_8605832.html">docker 基础</a></p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>docker images 显示出所有的镜像<br>docker tag 给镜像打 tag eg docker tag unbuntu myubuntu:last<br>docker inspect 查看镜像信息<br>docker history 显示 layer 基础信息<br>docker search —filter=is-automated=true nginx<br>docker rmi [-f 强行删除] 镜像 tag/镜像 ID 删除镜像 当镜像有容器在运行时，会提示无法删除。当不加 tag 时默认为 latest<br>docker commit [OPTIONS]</p>
<ul>
<li>-a —author 作者信息</li>
<li>-c —change = [] 提交的时候执行 dockerfile 指令</li>
<li>-m —message 提交信息</li>
<li>-p —pause=true 提交时暂停容器运行</li>
</ul>
<p>docker commit -a “xxx” -m “xxx” [容器名称 容器 id] 镜像名称 基于已有镜像的容器创建<br>docekr create [options] 镜像名 新建一个容器 此时容器处于停止状态<br>docker run [option] 镜像名 新建一个容器 并且容器处于运行状态</p>
<ul>
<li>-P 暴露在 Dockerfile 中 Expose 的端口</li>
<li>-idt -i 让容器标准输入打开 -d 创建后台守护进程 -t 给 docker 分配一个伪终端</li>
<li>—name 命名容器</li>
<li>docker run -d -P —name web -v /src/webapp:/opt/webapp:ro [镜像 id 镜像名称] 容器名称 运行程序</li>
<li>docker run -it -v /dbdata —name dbdata ubuntu 创建数据卷容器</li>
<li>docker run -it —volumes-from dbdata —name db1 ubuntu 共享数据卷</li>
<li>docker run -d -P —name web —link db:db 镜像名 程序名 —link name:alias</li>
</ul>
<p>docker start 容器名或容器 ID<br>docker restart 容器名或者容器 ID 先将一个运行态的容器先停止，然后重新启动它<br>docker attach 容器名称或容器 ID 所有窗口会同步显示，当有一个窗口阻塞的时候，其他窗口也会阻塞<br>docker exec -it 容器名或容器 id /bin/bash<br>docker rm 删除处于终止或者退出状态的容器<br>docker top 镜像名 查看镜像内的进程<br>docker logs 镜像名 获取容器的日志</p>
<h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>可以查看这本 Gitbook <a href="https://yeasy.gitbooks.io/docker_practice/image/dockerfile/copy.html">Docker 从入门到实践</a> 以下记录一些我不熟悉的知识点，便于复习</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：<br>VOLUME [“&lt;路径 1&gt;”, “&lt;路径 2&gt;”…]<br>VOLUME &lt;路径&gt;<br>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据<br>VOLUME /data<br>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。<br>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令</p>
<p>docker volume prune 清理无主的数据卷</p>
<h2 id="如何修改已存在容器的配置"><a href="#如何修改已存在容器的配置" class="headerlink" title="如何修改已存在容器的配置"></a>如何修改已存在容器的配置</h2><p>直接修改 /var/lib/docker/contains/[container_hash]/ 目录下的 config.v2.json 和 hostconfig.json 文件，修改之后需要重启 docker，再重新启动容器，就生效啦</p>
<h2 id="docker-架构"><a href="#docker-架构" class="headerlink" title="docker 架构"></a>docker 架构</h2><p>docker 采用 C/S 架构，包含客户端和服务端，通过镜像仓库来存储镜像。客户端和服务端可以不在一个机器上，通过 socket 或者 restful api 来进行通信。</p>
<h2 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h2><p>镜像是文件和 meta data 的集合 root filesystem</p>
<p>如一个 centos 的镜像，里面包含一些最精简版的 centos 文件系统，还有其他软件包等。</p>
<p>镜像是分层的，每层都可以添加删除改变文件，变成一个新的 image</p>
<p>不同的 image 可以共享同一层 layer</p>
<p>镜像本身是只读的</p>
<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器通过 image 创建</p>
<p>在 image layer 之上创建了一个 container layer，这个容器层可以读写操作</p>
<p>image 负责 app 的存储和分发，container 负责运行 app</p>
<h3 id="容器的-created-状态"><a href="#容器的-created-状态" class="headerlink" title="容器的 created 状态"></a>容器的 created 状态</h3><p>docker create 只创建容器，但是不启动，docker run 是启动并且创建容器</p>
<p>docker start 可以启动容器</p>
<h2 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h2><p>ADD 功能更强大，会拷贝文件并且解压，COPY 只会拷贝文件</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>一般在宿主机后台运行， dockerd 作为服务端接受来自客户的请求，通过 containerd 具体处理与容器相关的请求。包括创建，运行，删除容器等。</p>
<p>dockerd 为客户端提供 rest api，响应来自客户端的请求，采用模块化的解构，通过专门的 Engine 模块来分发管理各个来自客户端的任务。</p>
<p>docker-proxy 是 dockerd 的子进程，当需要进行容器端口映射时，docker-proxy 完成网络映射配置。</p>
<p>containerd 是 docker 的子进程，提供 gRPC 接口响应来自 dockerd 的请求，对下管理 runC 镜像和容器环境</p>
<p>containerd——shim, containerd 的子进程，作为容器内进程的根进程。</p>
<p>runC 是从 Docker 公司开源的 libcontainer 项目演化而来，。runC 支持 linux 系统中容器相关技术栈。</p>
<p>dockerd 默认监听本地 unix:///var/run/docker.sock 套接字，只允许本地 root 用户或者 docker 用户组成员能访问。</p>
<p>可以通过 -H 选项修改监听方式。</p>
<p>Docker 还支持通过 TLS 认证方式来验证访问。</p>
<p>docker-proxy 只有当启动容器并且开启端口映射才会执行，负责配置容器的端口映射规则。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>默认通过本地的 unix:///var/run/docker.sock 套接字向服务端发出命令。如果服务端没有监听默认地址，需要手动指定。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>namespace 是 linux 内核一个强大特性，利用这一特性，每个容器都可以拥有自己的单独命名空间。运行在其中的应用都像在独立的操作系统环境中一样。命名空间机制保证了容器之间彼此不受影响。</p>
<h3 id="进程命名空间"><a href="#进程命名空间" class="headerlink" title="进程命名空间"></a>进程命名空间</h3><p>Linux 通过进程命名空间管理进程号。对于同一个进程在不同的命名空间中，看到的进程号不同。每个进程命名空间有一套自己的进程号管理方法。进程命名空间是一个父子关系的结构，子空间的进程对于父空间是可见的。新 fork 出来的一个进程，在父命名空间和子命名空间将分别对应不同的进程号。</p>
<p>一般运行一个容器，以 docker run —name test -d ubuntu:18.04 sleep 9999 为例，相关进程关系如下：</p>
<p>docker 服务主进程 dockerd 作为父进程启动了 docker-containerd 进程，docker-containerd 作为父进程启动了 docker-containerd-shim，其作为容器内所有进程的根进程。</p>
<h3 id="IPC-命名空间"><a href="#IPC-命名空间" class="headerlink" title="IPC 命名空间"></a>IPC 命名空间</h3><p>容器内进程交互还是采用了 Linux 常见的进程间交互方法，包括信号量，消息队列和共享内存等方式.PID 命名空间和 IPC 命名空间可以组合起来使用，同一个 IPC 命名空间的进程可以交互，不同空间的进程则无法交互。</p>
<h3 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h3><p>有了进程命名空间，不同命名空间中的进程号可以相互隔离，但是网络端口还是共享本地系统的端口。通过网络命名空间，可以实现网络隔离。一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPV4 和 IPV6 协议栈，IP 路由表，防火墙规则，sockets 等。</p>
<p>docker 采用虚拟网络设备 Virtual Network Device VND 的方式，将不同命名空间的网络设备连接到一起。默认情况下，Docker 在宿主机上创建多个虚拟网桥，如默认的 docker0 网桥，容器中的虚拟网卡通过网桥进行桥接。</p>
<p>docker network ls 可以查看当前系统中的网桥。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker网桥.png" alt="docker网桥"></p>
<p>使用 brctl 工具，可以看到连接到网桥上的虚拟网口信息。每个容器默认分配一个网桥上的虚拟网口，并将 docker0 的 IP 地址设置为默认的网关。容器发起的网络流量通过 宿主机的 iptables 规则进行转发。</p>
<h4 id="虚拟网卡-veth"><a href="#虚拟网卡-veth" class="headerlink" title="虚拟网卡 veth"></a>虚拟网卡 veth</h4><p>这里参考了这篇文章 <a href="https://www.jianshu.com/p/369e50201bce">Linux 网络命名空间</a>，下面简述一下其中的内容。</p>
<p>虚拟网卡成对出现，像一个管道的两端，从这个管道一端的 veth 进去的数会从另一端的 veth 出来，可以用 veth 接口把一个网络命名空间连接到外部的默认命名空间或者 global 命名空间，而物理网卡就存在这些命名空间里。</p>
<p>创建一个网络命名空间，默认包含 lo 回环网络。然后创建一对虚拟网卡，将其中一端 veth1 加入命名空间中，设置该命名空间中的路由，使得找不到目的地址的数据包都通过 veth1 转发。这时就可以 ping 通 host 上的 veth0 网卡了。但是依然不能连接外部网络。</p>
<p>Linux 中 IP 转发的意思是 Linux 主机存在多个网卡的时候，允许一个网卡的数据包转发到另外一张网卡。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.1.1.0/255.255.255.0 -o ens160 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>添加了一条规则到 NAT 表的 POSTROUTING 链中，对于源 IP 地址为 10.1.1.0 网段的数据包，用 ens160 网口的 IP 地址替换并发送。这样在容器中就可以访问外部网络了。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/整个流程.png" alt="整个流程"></p>
<h2 id="两个容器为什么能通信"><a href="#两个容器为什么能通信" class="headerlink" title="两个容器为什么能通信"></a>两个容器为什么能通信</h2><p>只要有容器运行，docker0 接口的状态就从 down 变成了 up。</p>
<p>主机上的 veth 只能和 docker0 通信。容器内的 veth 可以和主机上的配对的 veth 通信。</p>
<p>veth 成对出现，docker0 是多个容器之间能通信的关键。</p>
<p><img src="/2019/04/05/%E8%BF%90%E7%BB%B4/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker容器间通信.png" alt="docker容器间通信"></p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name=test2 --link test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure>
<p>当于添加了 DNS 解析，同时 link 是单向的。只能在 test2 通过 test1 ping 通 test1。</p>
<h2 id="none-和-host-网络"><a href="#none-和-host-网络" class="headerlink" title="none 和 host 网络"></a>none 和 host 网络</h2><p>连接到 none 网络</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d test1 --network none busybox /bin/sh</span><br></pre></td></tr></table></figure>
<p>使用 none 模式，没有物理地址和 ip 地址，容器内只有 lo 回环网络，意味着容器不能被其他容器访问。</p>
<p>连接到 host 网络</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d test1 --network host busybox /bin/sh</span><br></pre></td></tr></table></figure>
<p>容器和外层 linux 共享一套网络接口</p>
<h2 id="数据持久化-data-volume"><a href="#数据持久化-data-volume" class="headerlink" title="数据持久化 data volume"></a>数据持久化 data volume</h2><p>在 docker 中，默认数据存储在 container layer，也就是容器层中，因为只有这一层是可读可写的。但这样如果容器关闭了，并且被删除了，数据也就被删除了。docker 为了解决这种问题，出现一种机制。就是把数据转移到外挂或者 mount 的磁盘上。例如把容器里数据，同步到外层 linux 主机磁盘上。这样即使容器被删除了，容器里面数据还是保留在 linux 主机上，下次我们再启动一个容器，配置读取外层 linux 这个外挂的文件系统中数据，这个容器恢复正常服务功能。</p>
<h2 id="VOLUME-的类型"><a href="#VOLUME-的类型" class="headerlink" title="VOLUME 的类型"></a>VOLUME 的类型</h2><p>有两种，第一种是受管理的 data Volume，由 docker 后台自动创建。第二种是绑定挂载的 Volume，具体挂载位置可以由用户指定。</p>
<h2 id="安全防护与配置"><a href="#安全防护与配置" class="headerlink" title="安全防护与配置"></a>安全防护与配置</h2><p>Docker 是基于 Linux 操作系统实现的应用虚拟化。运行在容器内的进程，与运行在本地系统的进程在本质上没有区别。Docker 容器的安全性，很大程度上依赖于 Linux 系统自身。在评估 Linux 安全性上，主要考虑一下几个方面</p>
<ul>
<li>Linux 内核的命名空间机制提供的容器隔离安全</li>
<li>Linux 控制组机制对容器资源的控制能力安全</li>
<li>Linux 内核的能力机制所带来的操作权限安全</li>
<li>Docker 程序本身的抗攻击性</li>
<li>其他安全增强机制对容器安全性的影响</li>
</ul>
<p>从网络架构上来看，所有的容器实际上是通过本地主机的网络接口 docker0 来进行相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>与虚拟机方式相比，通过命名空间来实现的隔离并不那个绝对，运行在容器中的应用可以直接访问系统内核和部分系统文件。因此用户必须保证容器中的应用是安全可信的。</p>
<p>控制组是 Linux 容器机制的另一个关键组件，它负责实现资源的审计和限制。当用户执行 docker run 启动一个 容器的时候，docker 将通过 Linux 相关的调用，在后台为容器创建一个独立的控制组策略集合，该集合将限制容器内应用对资源的消耗。</p>
<p>控制组提供了很多有用的特性，他可以确保各个容器公平地分享主机的内存，cpu，磁盘 IO 等资源，当然，更重要的是，通过控制组可以限制容器对资源的占用，确保了当某个容器对资源消耗过大时，不会影响到本地主机系统和其他容器。</p>
<p>Linux 内核自 2.2 版本起支持能力机制，将权限划分为更加细粒度的操作能力，默认情况下，Docker 启动的容器有严格限制，只允许使用内核的一部分能力。通常，在服务器上会运行一堆特权进程，包括 ssh，cron，syslogd 等，容器与这些进程是不同的，而容器大部分情况下不需要真正的 root 权限，为了加强安全，容器可以禁用一些没必要的权限，包括：</p>
<ul>
<li>完全禁止任何文件挂载操作</li>
<li>禁止直接访问本地主机的套接字</li>
<li>禁止访问一些文件系统的操作</li>
<li>禁止模块加载</li>
</ul>
<h2 id="高级网络功能"><a href="#高级网络功能" class="headerlink" title="高级网络功能"></a>高级网络功能</h2><h3 id="容器内-dns"><a href="#容器内-dns" class="headerlink" title="容器内 dns"></a>容器内 dns</h3><p>docker 服务启动后悔默认启用一个内嵌的 DNS 服务，来自动解析同一个网络中的容器主机名和地址，如果无法解析，则通过容器内的 DNS 相关配置来进行解析。</p>
<p>容器运行时，可以再运行中的容器直接编辑 /etc/hosts /etc/hostname /etc/resolve.conf 文件，但这种改动连 docker commit 也无法保存。</p>
<h3 id="容器访问外部的实现"><a href="#容器访问外部的实现" class="headerlink" title="容器访问外部的实现"></a>容器访问外部的实现</h3><p>假设容器内部的网络地址为 172.17.0.2，本地网络地址为 10.0.2.2。容器要能访问外部网络，需要进行源地址映射（Source NAT），修改为本地系统的 IP 地址 10.0.2.2。</p>
<p>映射是通过 iptables 的源地址伪装操作实现的。 主机 nat 表上的 POSTROUTING 链规则负责网包离开主机前，改写其源地址：</p>
<h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以再 docker run 时候通过 -p 或者 -P 参数来启用。其实也是在本地的 iptable 的 nat 表 中添加相应的规则，将访问外部 IP 地址的包进行目标地址 DNAT，将目标地址修改为容器的 IP 地址。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>nginxLocation模块学习</title>
    <url>/2020/04/04/%E8%BF%90%E7%BB%B4/nginxLocation%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="uri-匹配规则"><a href="#uri-匹配规则" class="headerlink" title="uri 匹配规则"></a>uri 匹配规则</h3><h4 id="location-规则类型"><a href="#location-规则类型" class="headerlink" title="location 规则类型"></a>location 规则类型</h4><p>这部分内容来自<a href="https://www.cnblogs.com/dreamanddead/p/how-uri-match-location-rule-in-nginx.html">详细解析 nginx uri 如何匹配 location 规则</a></p>
<h5 id="exact-uri"><a href="#exact-uri" class="headerlink" title="= exact uri"></a>= exact uri</h5><p>完全匹配规则，要求 url 和规则完全相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /api/v1 &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="case-sensitive-regex"><a href="#case-sensitive-regex" class="headerlink" title="~ case-sensitive regex"></a>~ case-sensitive regex</h5><p>区分大小写的正则表达式匹配规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /api/v1 &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="case-insensitive-regex"><a href="#case-insensitive-regex" class="headerlink" title="~* case-insensitive regex"></a>~* case-insensitive regex</h5><p>不区分大小写的正则表达式匹配规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /api/v1 &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="case-insensitive-regex-1"><a href="#case-insensitive-regex-1" class="headerlink" title="~* case-insensitive regex"></a>~* case-insensitive regex</h5><p>不大小写的正则表达式匹配规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /api/v1 &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="～-disable-regex-prefix"><a href="#～-disable-regex-prefix" class="headerlink" title="^～ disable regex prefix"></a>^～ disable regex prefix</h5><p>匹配流程与 prefix 规则相同，有一点区别在于，如果最长匹配是当前规则，则之后不进行 正则表达式 规则的搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /api/v1 &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="uri-如何选择-location"><a href="#uri-如何选择-location" class="headerlink" title="uri 如何选择 location"></a>uri 如何选择 location</h4><ol>
<li>如果存在 exact uri 规则与 uri 匹配，至步骤 6</li>
<li><p>在所有 prefix 规则和 disable regex prefix 规则中进行匹配（与这些规则定义的顺序无关），<br>如果没有匹配到规则，至步骤 3；如果存在匹配的规则，选择出最长匹配 uri 的规则：</p>
<ul>
<li>如果规则是 disable regex prefix 类型，至步骤 6</li>
<li>如果规则是 prefix 类型，记住当前匹配的 prefix 规则，选为待定，至步骤 3</li>
</ul>
</li>
<li><p>逐个遍历 case-sensitive regex 规则和 case-insensitive regex 规则（按照这些规则定义的前后顺序）:</p>
<ul>
<li>如果规则匹配，则遍历终止，至步骤 6</li>
<li>如果规则没有匹配，则继续</li>
</ul>
</li>
<li><p>如果之前有 prefix 规则条目被选择为待定，至步骤 6</p>
</li>
<li>匹配失败，返回 404，结束</li>
<li>选择当前规则，使用其配置，结束</li>
</ol>
<h4 id="try-files-解析"><a href="#try-files-解析" class="headerlink" title="try_files 解析"></a>try_files 解析</h4><p><code>$uri</code> 指代访问的 uri 资源，<code>$uri/</code>语法可以用来检测一个目录的存在，如果没有找到，一个内置的重定向将请求重定向到最后一个参数<br>最后一个参数可以指向一个命名的 location</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    try_files $uri $uri/ index.html $uri.html =404;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    try_files /system/maintenance.html</span><br><span class="line">              $uri $uri/index.html $uri.html</span><br><span class="line">              @mongrel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @mongrel &#123;</span><br><span class="line">    proxy_pass http://mongrel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>oj运维笔记-持续更新</title>
    <url>/2018/11/25/%E8%BF%90%E7%BB%B4/oj%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>接到协会老师的任务，我负责了学校 oj 的开发和运维工作，这篇博客记录我在运维过程中遇到的一些问题和解决办法。</p>
<ul>
<li>重启容器 找不到 java，vi 等命令 使用 update update-alternatives —config 配置 java javac vi 等</li>
<li>java 遇到　 OpenJDK 64-Bit Server VM warning: Can’t detect initial thread stack location - find_vma failed 　错误原因是 chroot 系统中，需要挂载/proc，只需要执行以下语句即可<br>mount -t proc none /proc</li>
<li><p>php 下载 excel 文件 nginx 报错 502<br>首先查看 nginx 日志，发现在站点配置文件中没有设置输出日志，在站点配置文件末尾加入<br>error_log logs/errors.log error;<br>输入命令 nginx -t 发现报错<br>nginx: [emerg] open() “/usr/share/nginx/logs/errors.log” failed (2: No such file or directory)<br>使用 touch 创建日志文件，查看日志文件发现<br>*4 upstream sent too big header while reading response header from upstream<br>百度之后，说是 header 过大的问题，在 nginx.conf 的 http 段加入以下配置<br>proxy_buffer_size 128k;<br>proxy_buffers 32 32k;<br>proxy_busy_buffers_size 128k;</p>
<pre><code>  fastcgi_buffer_size 128k;
  fastcgi_buffers 4 256k;
  fastcgi_busy_buffers_size 256k;
</code></pre><p>问题搞定！</p>
<ul>
<li>手动执行 judge_client<br>judge_client 1000 1 /home/judge/hustoj_core debug</li>
</ul>
</li>
<li><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p>
</li>
<li>supervisor 的使用 运行命令 supervisorctl 然后参照配置文件的写法运行命令</li>
<li>docker-compose 要注意 services 不能重名，即使是在不同的目录下，如果 services 重名，会覆盖之前的容器，建议使用项目名+容器名进行命名</li>
</ul>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>因为使用 redis 缓存了问题数据，我想要测试一下有没有带来性能上提升<br>首先我尝试的是 postman 的 runner，但是测试之后发现并没有什么区别。后来了解到 postman 的 runner 是串行的。<br>又看到 jMeter 这个工具，但是它在 linux 下没有 GUI，配置又很繁琐，直接劝退。<br>之后又看到 linux 下几款 命令行压力测试工具，最终选择使用 ab。</p>
<h3 id="ab-的使用"><a href="#ab-的使用" class="headerlink" title="ab 的使用"></a>ab 的使用</h3><p>使用很简单，最基础的设置，请求 10000 次，并发数量 1000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab -n 10000 -c 1000 http://localhost:8080/api/problem/1</span><br></pre></td></tr></table></figure>
<h3 id="socket-Too-many-open-files-24-的解决办法"><a href="#socket-Too-many-open-files-24-的解决办法" class="headerlink" title="socket: Too many open files (24)的解决办法"></a>socket: Too many open files (24)的解决办法</h3><p>打开的文件太多了，超过了系统限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -n 204800</span><br></pre></td></tr></table></figure>
<h3 id="redigo"><a href="#redigo" class="headerlink" title="redigo"></a>redigo</h3><p>文献 系统优点</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx 容器配置反向代理，无法使用 localhost 访问主机，可以使用宿主机 docker 0 的网卡 ip 代替</p>
<h3 id="mysql-相关"><a href="#mysql-相关" class="headerlink" title="mysql 相关"></a>mysql 相关</h3><p>innodb_lock_wait_timeout 和 lock_wait_timeout<br>前者是 innodb 的 dml 操作的行级锁的等待时间 后面是数据结构 ddl 操作的锁的等待时间</p>
<p>减少锁等待时间，防止数据库卡死</p>
<p>set GLOBAL innodb_lock_wait_timeout = 50;<br>set GLOBAL lock_wait_timeout = 10;</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>记使用docker-compose对OJ系统部署优化重构</title>
    <url>/2019/03/07/%E8%BF%90%E7%BB%B4/%E8%AE%B0%E4%BD%BF%E7%94%A8docker-compose%E5%AF%B9OJ%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E4%BC%98%E5%8C%96%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>这几天研究了一下用把上学期写的 oj 部署在 docker 容器中，自己编写了 Dockerfile 构建主容器，并将数据库容器分离，使用了 docker-compose 对容器进行管理，实现了自动化的部署，感觉收获挺多的。写下这篇博客记录一下自己新 get 到的技能。</p>
<h3 id="重构原因"><a href="#重构原因" class="headerlink" title="重构原因"></a>重构原因</h3><p>其实我接触到 docker 这门技术已经很久了。在学习 Laravel 的时候使用了 laradock 快速构建开发环境，那时候感觉 docker 真是太方便了。不过长久以来，我对于 docker 的了解，仅仅停留在基础的使用上，也没有尝试过自己编写 Dockerfile 构建镜像，对于 docker 中一些基础的概念都很模糊，像什么端口映射啊，数据持久化啊，都不了解，结果在部署应用的时候，白白费了很多功夫，实在是得不偿失。这就不得不说之前部署 OJ 的血泪史（菜啊(⊙﹏⊙)b）。我校 OJ 是基于 HUSTOJ 进行二次开发的，在本地开发的时候使用了作者的一键部署脚本，没有使用容器构建。之前学长在学校的服务器上用 docker 跑了一个 hustoj 的镜像。本地开发倒是没有什么问题，但是怎么部署到服务器的 docker 上？我的做法现在看来非常的傻逼，把项目改动部分的代码上传到 github 仓库，然后进入到学校 oj 的 hustoj 容器中，把其中 web 部分的代码删除，再从 github 上 pull 下我的代码。我想的是很简单，实际操作起来。先是部署上去就花了将近一整天，而之后像是 OJ 判不了 JAVA，文件权限不对，配置文件不对等各种问题等前前后后修复了好几次才搞定，一点都不<strong>优雅</strong>。之后过了一个寒假，倒是一直稳定运行到现在。但是我觉得不能就这样放着，因为这系统除了我自己。趁开学事情少，我学习了一下怎么编写 Dockerfile，以及编写 docker-compose 的配置脚本，实现了 OJ 的自动化部署。</p>
<h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><p>之前看 docker 的书的时候，是有看过怎么编写 Dockerfile 的，但是没有自己写过。所以一上来就陷入了僵局。基础镜像选择我比较熟悉的 ubuntu，但之后该干嘛啊。百度学习一番后，我了解到 docker 有 history 这个命令，其加上—no-trunc 可以完整显示镜像构建每个步骤执行的命令（但是后来我才意识到 hustoj 的项目中就有 Dockerfile 文件，僵）。先复制过来，然后看着基础镜像 ubuntu:Trusty，不明所以，百度了一下才知道这个 ubuntu14 的代号，这也太老了吧。直接换成 ubuntu18.04，把里面的软件都换成了比较新的版本，把 php5 换成了 php7，去掉了 mysql，因为要放到单独的容器中。就这样小改了一下，感觉没啥问题，那就构建一下试试吧。<br>进行构建，显示命令报错，很多软件包都不存在。果断开一个 ubuntu 的容器，一个个测试能不能下载，确认没问题再次构建。然后 apt 能下载了，但是官方源的速度实在是太慢了。因此添加了<code>COPY sources.list /etc/apt/sources.list</code>命令到最前面。这下下载速度没问题了，但是在安装某个依赖 tzdata 时，需要手动选择时区，但是我按照指令选择并没有相应，重新构建了几次，都是如此。百度解决办法，需要这样来安装</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">export</span> DEBIAN_FRONTEND=noninteractive \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y tzdata</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="bash">    &amp;&amp; dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure>
<p>我把它放在安装其他软件之前。docker 的构建步骤是有缓存的，之前成功构建的步骤会缓存起来，每一个步骤对应一个镜像层，下次不需要再次构建。一条 RUN 语句的执行就创建了一个镜像层。如果构建步骤发生了改变，就从开始改变的那一步开始重新构建。开始构建的时候，往往少安装很多软件包，可以把新添加的包放在新的 RUN 语句下安装，避免把原先安装的包再下载一遍。<br>hustoj 的构建镜像的项目代码是从 github 上 clone 下来的，我最开始也是这么写的，后来发现有更好的方法，这个后面再说。</p>
<h3 id="使用-docker-compose"><a href="#使用-docker-compose" class="headerlink" title="使用 docker-compose"></a>使用 docker-compose</h3><p>因为打算把 mysql 容器分离，所以要使用 docker-compose 进行容器的管理。laradock 就是基于 docker-compose 的一个项目。在配置文件中，我们需要定义服务，每个服务对应一个容器，服务的选项对应了 docekr 启动是的各种启动选项。将其写在配置文件中，我们只要简单的两行命令就可以了，非常高效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>下面记录几个我认为重要的点</p>
<ul>
<li>tty 选项，主容器应该设置为 true，否则会因为确实控制终端的配置导致启动失败</li>
<li>ports 选项，设置容器的端口映射，按照 主机端口：容器端口 的顺序映射</li>
<li>expose，说明容器暴露的端口，但没有实际作用，仍需要设置 ports 选项才能让映射生效</li>
<li>links，容器间数据互联，容器的中会解析服务名为对应的 ip 地址，我让主容器连接到了 mysql 容器</li>
<li>depends_on 依赖，被依赖的服务会现行构建</li>
<li>enviroment 环境变量，对于 mysql 可以通过环境变量设置管理员密码，新建用户和新建数据库</li>
<li>volumes，数据卷，像/var/lib/mysql 这样存放数据的目录应该放在可持久化的数据卷中，也可以映射本机目录到容器</li>
<li>.env 文件可以定义当前目录中的环境变量，这是 linux 系统的特性，会自动读取.env 中定义的变量到环境变量</li>
<li>entrypoint，容器<strong>启动</strong>时自动运行的脚本，一般用于启动后台服务进程。是启动而不是构建时，每次<code>docker-compose start</code>时都会运行，Dockerfile 中也有 ENTRYPOINT 选项，也是在每次容器启动的时候运行。</li>
</ul>
<p>总结一下，Dockerfile 中 RUN 命令只在构建的时候运行，用于安装软件包，和简单的一些配置。两个 entrypoint 区别不大，都是容器启动时运行，一般用于启动后台服务。而对于只需要进行一次的操作，比如运行 sql 建库，修改文件权限，可以编写一个 shell 脚本，在容器创建之后手动执行一次</p>
<h3 id="整合到项目"><a href="#整合到项目" class="headerlink" title="整合到项目"></a>整合到项目</h3><p>这样构建起来的项目，代码是保存在镜像中的，没办法用 vscode 打开。回想起来之前用 laradock 的经历，似乎可以将本地项目目录映射到容器，看了 laradock 的配置文件，果然如此。于是把项目代码文件目录也整合了进来，在 volumes 选项中设置映射代码目录。目录结构是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── docker</span><br><span class="line">│   ├── ahpuoj</span><br><span class="line">│   └── docker-compose.yml</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── core</span><br><span class="line">    ├── install</span><br><span class="line">    └── web</span><br></pre></td></tr></table></figure>
<p>这样只要 clone 到本地，简单构建一下容器，就可以进行开发了。<br>对于不要提交的配置文件，我将其放在 install 文件夹中，并且在创建后执行的安装脚本中设置了软连接指向本该所在的目录。个人认为是个不错的方法。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>depends_on 虽然决定了容器创建的顺序，但是容器中的服务启动仍然需要时间。因此在 entrypoint.sh 中访问数据库会失败，因为这时候数据库容器中的服务可能还没有启动完成</li>
<li>sed 修改软连接文件会将其变成真正的文件，需要添加<code>--follow-symlinks</code>选项</li>
<li>entrypoint.sh 文件的最后应加上<code>/bin/bash</code>,运行 bash 前台应用，否则也会造成容器启动后就停止</li>
</ul>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>最后是<a href="https://github.com/jiezi19971225/ahpuoj-docker">项目的地址</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2020/10/01/java/javase/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>byte：-128 ~ 127<br>short: -32768 ~ 32767<br>int: -2147483648 ~ 2147483647<br>long: -9223372036854775808 ~ 9223372036854775807</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">2_000_000_000</span>; <span class="comment">// 加下划线更容易识别</span></span><br><span class="line">        <span class="keyword">int</span> i4 = <span class="number">0xff0000</span>; <span class="comment">// 十六进制表示的16711680</span></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">0b1000000000</span>; <span class="comment">// 二进制表示的512</span></span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">9000000000000000000L</span>; <span class="comment">// long型的结尾需要加L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.79e308</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = -<span class="number">1.79e308</span>;</span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br></pre></td></tr></table></figure>
<p>对于 float 类型，需要加上 f 后缀</p>
<h4 id="强制转型"><a href="#强制转型" class="headerlink" title="　强制转型"></a>　强制转型</h4><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。<br>如果要进行四舍五入，可以对浮点数加上 0.5 再强制转型。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>除了整型，浮点型，布尔类型，字符类型，其他都为引用类型</p>
<h4 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h4><p>判断引用类型的变量内容是否相等，必须使用 equals() 方法</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>对于多行的字符串，使用 “””…”””表示多行字符串（java13 开始）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">           SELECT * FROM</span></span><br><span class="line"><span class="string">             users</span></span><br><span class="line"><span class="string">           WHERE id &gt; 100</span></span><br><span class="line"><span class="string">           ORDER BY name DESC</span></span><br><span class="line"><span class="string">           &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>由于多行字符串是作为预览特性（Preview Language Features）实现的，编译的时候，我们还需要给编译器加上参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac --source 14 --enable-preview Main.java</span><br></pre></td></tr></table></figure>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义变量的时候，如果加上 final 修饰符，这个变量就变成了常量：</p>
<h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>
<p>编译器会自动推导类型</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能使用基本类型，而要使用它们对应的类</span></span><br><span class="line">        Integer[] ns = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ns, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>引用类型传的是引用，会修改传递的应用类型数据本身</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Student(); <span class="comment">// upcasting, ok</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Student s1 = (Student) p1; <span class="comment">// ok</span></span><br><span class="line">Student s2 = (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>
<p>为了避免向下转型出错，Java 提供了 instanceof 操作符，可以先判断一个实例究竟是不是某种类型：</p>
<h3 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h3><p>加上@Override 可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。@Override 不是必需的。</p>
<p>所有的 class 最终都继承自 Object，而 Object 定义了几个重要的方法：</p>
<ul>
<li>toString()：把 instance 输出为 String；</li>
<li>equals()：判断两个 instance 是否逻辑相等；</li>
<li>hashCode()：计算一个 instance 的哈希值。</li>
</ul>
<p>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 final。用 final 修饰的方法不能被 Override：</p>
<h3 id="多态-Polymorphic"><a href="#多态-Polymorphic" class="headerlink" title="多态 Polymorphic"></a>多态 Polymorphic</h3><p>Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<h3 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Point</span>(<span class="params">int x, int y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">x</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 final 定义 class，除此以外，还需要正确覆写 equals() 和 hasCode()</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h3><p>class 是由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存。</p>
<p>每加载一种 class，JVM 就为其创建一个 Class 类型的实例，并关联起来。注意：这里的 Class 类型是一个名叫 Class 的 class。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 String 类为例，当 JVM 加载 String 类时，它首先读取 String.class 文件到内存，然后，为 String 类创建一个 Class 实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure>
<p>这个 Class 实例是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现 Class 类的构造方法是 private，只有 JVM 能创建 Class 实例，我们自己的 Java 程序是无法创建 Class 实例的。<br>所以，JVM 持有的每个 Class 实例都指向一个数据类型（class 或 interface）：</p>
<p>一个 Class 实例包含了该 class 的所有完整信息。由于 JVM 为每个加载的 class 创建了对应的 Class 实例，并在实例中保存了该 class 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 Class 实例，我们就可以通过这个 Class 实例获取到该实例对应的 class 的所有信息。</p>
<p>这种通过 Class 实例获取 class 信息的方法称为反射（Reflection）。</p>
<p>获取一个 class 的 Class 实例有三个方法<br>方法一：直接通过一个 class 的静态变量 class 获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure>
<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 getClass()方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>
<p>方法三：如果知道一个 class 的完整类名，可以通过静态方法 Class.forName()获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>因为 Class 实例在 JVM 中是唯一的，所以，上述方法获取的 Class 实例是同一个实例。可以用==比较两个 Class 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>
<p>用 instanceof 不但匹配指定类型，还匹配指定类型的子类。而用==判断 class 实例可以精确地判断数据类型，但不能作子类型比较。<br>通常情况下，我们应该用 instanceof 判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 class 的时候，我们才使用==判断 class 实例。</p>
<h3 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以调用 f.setAccessible(true); 改变字段的可访问性</p>
<p>设置字段，可以使用 Field.set(Object, Object) 实现的，其中第一个 Object 参数是指定的实例，第二个 Object 参数是待修改的值。</p>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法是静态的，无需指定实例对象。invoke 方法传入的第一个参数永远为 null。如果调用非 public 方法，可以先通过 Method.setAccessible(true)设置可访问性<br>使用反射调用方法时，仍然遵循多台原则，即总是调用实际类型的覆写方法。</p>
<h3 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h3><p>调用 Class.newInstance()的局限是，它只能调用该类的 public 无参数构造方法。如果构造方法带有参数，或者不是 public，就无法直接通过 Class.newInstance()来调用。<br>为了调用任意的构造方法，Java 的反射 API 提供了 Constructor 对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor 对象和 Method 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>有三种方式</p>
<p>方法一：从 Thread 派生一个自定义类，然后覆写 run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：创建 Thread 实例时，传入一个 Runnable 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用 Java8 引入的 lambda 语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以对线程设定优先级，设定优先级的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java 线程对象 Thread 的状态包括：New、Runnable、Blocked、Waiting、Timed Waiting 和 Terminated；<br>通过对另一个线程对象调用 join()方法可以等待其执行结束；<br>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；<br>对已经运行结束的线程调用 join()方法会立刻返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程是指为其他线程服务的线程。在 JVM 中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>synchronized 关键字对一个对象进行加锁，保证代码块在任意时刻最多只能有一个线程来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>JVM 规范定义了几种原子操作：</p>
<ul>
<li>基本类型（long 和 double 除外）赋值，例如：int n = m；</li>
<li>引用类型赋值，例如：List<String> list = anotherList。</String></li>
</ul>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>使用 synchronized 封装逻辑，这样的类就是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了少数情况，大部分类，如 ArrayList 都是非线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
<p>以上两种写法是等价的</p>
<p>对于 static 方法，是没有 this 实例的，因此 static 方法是针对类而不是实例。但是我们注意到任何一个类都有一个由 JVM 自动创建的 Class 实例，因此，对 static 方法添加 synchronized，锁住的是该类的 Class 实例。上述 synchronized static 方法实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>java 的线程锁是可重入的锁。JVM 允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。<br>由于 Java 的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出 synchronized 块，记录-1，减到 0 的时候，才会真正释放锁。</p>
<h3 id="多线程协调"><a href="#多线程协调" class="headerlink" title="多线程协调"></a>多线程协调</h3><p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p>hashmap 通过以空间换时间的方式，提高查询速度。它用一个大数组存储所有的 value，并根据 key 直接计算出 value 应该存储在那个索引<br>在 map 的内部，对 key 做比较是通过 equals() 实现的，正确使用 Map 必须保证：</p>
<ul>
<li><p>作为 key 的对象必须正确覆写 equals()方法，相等的两个 key 实例调用 equals()必须返回 true；</p>
</li>
<li><p>作为 key 的对象还必须正确覆写 hashCode()方法，且 hashCode()方法要严格遵循以下规范： - 如果两个对象相等，则两个对象的 hashCode()必须相等； - 如果两个对象不相等，则两个对象的 hashCode()尽量不要相等。 -<br>上述第一条规范是正确性，必须保证实现，否则 HashMap 不能正常工作。<br>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的 hashCode()，会造成 Map 内部存储冲突，使存取的效率下降。</p>
</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>实际上 HashMap 初始化时默认的数组大小只有 16，任何 key，无论它的 hashCode()有多大，都可以简单地通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure>
<p>添加超过一定数量的 key-value 时，HashMap 会在内部自动扩容，每次扩容一倍，即长度为 16 的数组扩展为长度 32，由于扩容会导致重新分布已有的 key-value，所以，频繁扩容对 HashMap 的性能影响很大。如果我们确定要使用一个容量为 10000 个 key-value 的 HashMap，更好的方式是创建 HashMap 时就指定容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><h3 id="servletContext"><a href="#servletContext" class="headerlink" title="servletContext"></a>servletContext</h3><p>单例对象，在 web 部署启动的时候创建，在 web 工程停止的时候销毁</p>
<ul>
<li>获取 web.xml 配置的 context.param</li>
<li>获取当前的工程路径 /</li>
<li>获取工程部署后在服务器的绝对路径</li>
<li>像 Map 一样存取数据</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>可以 forward 共享 req 和 resp 对象<br>可以访问 WEB-INF 目录</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>es6学习笔记1</title>
    <url>/2019/08/03/javascript/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在全局变量 tmp，但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 let 声明变量前，对 tmp 赋值会报错</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用 但是浏览器的实现与规范不同，应避免使用该写法</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心</p>
<p>如果真的想将对象冻结，应该使用 Object.freeze 方法</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>如果解构不成功，变量的值就等于 undefined。</p>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p>
<p>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>如果解构失败，变量的值等于 undefined</p>
<p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &#x27;hello&#x27;</span><br><span class="line">l // &#x27;world&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><ul>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</li>
</ul>
<h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象</p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>交换变量的值 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 结构 输入模块的指定方法</p>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h4><p>允许采用<code>\uxxxx</code>形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点 可将码点放入大括号</p>
<p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。</p>
<h4 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h4><p>ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<p>模板字符串之中可以放入表达式，还能调用函数</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法</p>
<h3 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h3><h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符</p>
<h4 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h4><p>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法</p>
<h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>能够正确处理 4 个字节储存的字符，返回一个字符的码点</p>
<h4 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h4><p>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化</p>
<h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次</p>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>padStart()用于头部补全，padEnd()用于尾部补全</p>
<h4 id="trimStart-，trimEnd"><a href="#trimStart-，trimEnd" class="headerlink" title="trimStart()，trimEnd()"></a>trimStart()，trimEnd()</h4><p>trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<h4 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h4><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配</p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示"><a href="#二进制和八进制表示" class="headerlink" title="二进制和八进制表示"></a>二进制和八进制表示</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。</p>
<h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>判断是否为极限和 NaN</p>
<h4 id="Number-isFinite-Number-isNaN-1"><a href="#Number-isFinite-Number-isNaN-1" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变</p>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger()用来判断一个数值是否为整数</p>
<h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差</p>
<h4 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h4><p>ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量<br>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内</p>
<h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分<br>Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值<br>Math.cbrt 方法用于计算一个数的立方根</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<p>参数变量是默认声明的，所以不能用 let 或 const 再次声明</p>
<h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure>
<h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。如果传入 undefined，将触发该参数等于默认值，null 则没有这个效果。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&#x27;Missing parameter&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了 sort 默认是按照 unicode 码点顺序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const sortNumber = (...number) =&gt; number.sort()</span><br><span class="line">console.log(sortNumber(3, 2, 1))</span><br></pre></td></tr></table></figure>
<p>rest 参数之后不能再有其他参数</p>
<h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>函数的 name 属性，返回该函数的函数名</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，在箭头函数中，它是固定的</p>
<p>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误</p>
<p>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(&#x27;s1: &#x27;, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(&#x27;s2: &#x27;, timer.s2), 3100);</span><br><span class="line">// s1: 3</span><br><span class="line">// s2: 0</span><br></pre></td></tr></table></figure>
<p>上面代码中，Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 this 绑定定义时所在的作用域（即 Timer 函数），后者的 this 指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1 被更新了 3 次，而 timer.s2 一次都没更新。</p>
<p>不能用 call()、apply()、bind()这些方法去改变 this 的指向</p>
<h4 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h4><p>由于箭头函数使得 this 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义对象的方法，且该方法内部包括 this。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const cat = &#123;</span><br><span class="line">  lives: 9,</span><br><span class="line">  jumps: () =&gt; &#123;</span><br><span class="line">    this.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用 cat.jumps()时，如果是普通函数，该方法内部的 this 指向 cat；如果写成上面那样的箭头函数，使得 this 指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</p>
<p>第二个场合是需要动态 this 的时候，也不应使用箭头函数。</p>
<h4 id="函数式相关"><a href="#函数式相关" class="headerlink" title="函数式相关"></a>函数式相关</h4><p>省略</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。替代函数的 apply 方法</p>
<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><ul>
<li>复制数组</li>
<li>合并数组</li>
<li>与解构赋值结合</li>
<li>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</li>
</ul>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>Array.from 方法用于将两类对象转为真正的数组<br>类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异。</p>
<h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<h4 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined</p>
<p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>fill 方法使用给定值，填充一个数组。fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h4><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似</p>
<h4 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h4><p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat()方法的参数写成一个整数，表示想要拉平的层数，默认为 1。</p>
<p>flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。</p>
<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>不建议保留空位，es6 对于空位设置文 undefined</p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</p>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性/方法名，即把表达式放在方括号内。</p>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]</p>
<h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的 name 属性，返回函数名</p>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上 get 和 set。有两种特殊情况：bind 方法创造的函数，name 属性返回 bound 加上原函数的名字；Function 构造函数创造的函数，name 属性返回 anonymous。</p>
<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><p>描述对象 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p>
<p>enumerable 属性，称为“可枚举性”目前，有四个操作会忽略 enumerable 为 false 的属性。只有 for…in 会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for…in 循环，而用 Object.keys()代替。</p>
<ul>
<li>for…in 循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性</li>
</ul>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super，指向当前对象的原型对象 目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法 avaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<h4 id="对象的解构赋值-1"><a href="#对象的解构赋值-1" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象</p>
<p>解构赋值必须是最后一个参数</p>
<h4 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><ul>
<li>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</li>
<li>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</li>
<li>如果扩展运算符后面是一个空对象，则没有任何效果。</li>
<li>如果扩展运算符后面不是对象，则会自动将其转为对象。</li>
<li>如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象</li>
<li>对象的扩展运算符等同于使用 Object.assign()方法。</li>
<li>如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">const clone1 = &#123;</span><br><span class="line">  __proto__: Object.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">const clone2 = Object.assign(</span><br><span class="line">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">const clone3 = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>修改现有对象部分的属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: &#x27;New Name&#x27; // Override the name property</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式</li>
<li>扩展运算符的参数对象之中，如果有取值函数 get，这个函数是会执行的</li>
</ul>
<h3 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致</p>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。浅拷贝，同名属性的替换 ，可以用来处理数组，但是会把数组视为对象，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h4><p>返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<p>Object.getOwnPropertyDescriptors()方法的另一个用处，是配合 Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const clone = Object.create(Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const shallowClone = (obj) =&gt; Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p><strong>proto</strong>属性 用来读取或设置当前对象的 prototype 对象 建议使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替</p>
<p>如果一个对象本身部署了<strong>proto</strong>属性，该属性的值就是对象的原型。</p>
<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><p>Object.fromEntries()方法是 Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础学习</title>
    <url>/2020/03/30/react/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>闭关学习 react！</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Josh Perez&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在大括号中可以填入任何有效的 javascript 表达式。</p>
<p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<p>也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：</p>
<p>React DOM 在渲染所有输入内容之前，默认会进行转义。这可以有效防止 XSS 攻击。</p>
<p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。他会创建这样一个虚拟 dom 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;greeting&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello, world!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>React 元素是不可变对象，一旦被创建，就无法更改他的子元素或者属性。更新 UI 的唯一方式就是创建一个新的元素，将其传入 ReactDOM.render()。</p>
<p>React 只更新它需要更新的部分。React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<h3 id="组件-amp-props"><a href="#组件-amp-props" class="headerlink" title="组件&amp;props"></a>组件&amp;props</h3><p>函数组件，接受 props，返回 jsx</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件可以是用户自定义的组件，这时它会将 jsx 所接收的属性以及自组件转换为单个对象传给组件。组件必须以大写字母开头。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>解构写法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Comment</span> &#123;<span class="attr">...data</span>&#125;&gt;</span>,document.getElementById(&#x27;root&#x27;));</span></span><br></pre></td></tr></table></figure>
<p>props 应该是只读的，函数组件都应该为纯函数</p>
<p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<p>当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在下一章节中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p>
<h4 id="组件的运作方式"><a href="#组件的运作方式" class="headerlink" title="组件的运作方式"></a>组件的运作方式</h4><ul>
<li>render 发现一个用户自定义组件，如果标签名是大写字母开头的，就会认为它是一个用户自定义组件</li>
<li>先把 jsx 属性封装为一个 props 对象</li>
<li>把它作为参数传递给组件</li>
<li>render 方法会把次 react 元素渲染到页面上</li>
</ul>
<h3 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state&amp;生命周期"></a>state&amp;生命周期</h3><h4 id="不要直接修改-state"><a href="#不要直接修改-state" class="headerlink" title="不要直接修改 state"></a>不要直接修改 state</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.state.comment = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>而应该使用 setState()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123; <span class="attr">comment</span>: <span class="string">&quot;Hello&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="state-更新可能是异步的"><a href="#state-更新可能是异步的" class="headerlink" title="state 更新可能是异步的"></a>state 更新可能是异步的</h4><p>不要依赖他们的值来跟新下一个状态</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="built_in">this</span>.state.counter + <span class="built_in">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.counter + props.increment,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>state 的更新可以被合并</p>
<h4 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h4><p>state 是局部的，除了拥有并且设置了它的组件，其他组件都无法访问。组件可以选择把它的 state 作为 props 向下传递给它的子组件中</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>react 事件命名采用小驼峰。</p>
<p>使用 jsx 语法时，需要传入一个函数作为事件处理函数，而不是一个字符串，不能使用 return false 的方式组织默认行为，必须显式使用 preventDefault。</p>
<h4 id="传参的方式"><a href="#传参的方式" class="headerlink" title="传参的方式"></a>传参的方式</h4><p>默认会将 e 作为最后一个参数传递，如果使用箭头函数的方式绑定，需要使用如下形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(e) =&gt; handleFunc(e);</span><br></pre></td></tr></table></figure>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>if &amp;&amp; || 三目运算符</p>
<h4 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h4><p>让 render 函数返回 null</p>
<h3 id="列表-amp-key"><a href="#列表-amp-key" class="headerlink" title="列表&amp;key"></a>列表&amp;key</h3><h4 id="渲染多个组件"><a href="#渲染多个组件" class="headerlink" title="渲染多个组件"></a>渲染多个组件</h4><p>使用 map 数组方法，渲染列表时应该提供一个 key 属性，通常使用数据中的 id 来作为元素的 key。</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>在 HTML 中，表单元素（如 input、 textarea 和 select）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleSubmit = <span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;提交的名字: &quot;</span> + <span class="built_in">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">          名字:</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>在 html 中，textarea 使用子元素定义其文本，在 react 中，使用 value 属性代替</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>在 html 中 使用 selected 表明属性默认选中，react 在根 select 标签使用 value 属性</p>
<h4 id="input-type-file"><a href="#input-type-file" class="headerlink" title="input type=file"></a>input type=file</h4><p>在 react 中，它是一个非受控组件</p>
<h4 id="处理多个输入"><a href="#处理多个输入" class="headerlink" title="处理多个输入"></a>处理多个输入</h4><p>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</p>
<h4 id="受控输入空值"><a href="#受控输入空值" class="headerlink" title="受控输入空值"></a>受控输入空值</h4><p>在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null<br>如果确实是只读属性，应当加上 readOnly 属性</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>传递共同父组件的 props，props 是只读的，要在子组件中改变它，通常使用受控组件来解决，将父组件中改变 state 的函数作为 props 传递给子组件调用。</p>
<h4 id="组合-amp-继承"><a href="#组合-amp-继承" class="headerlink" title="组合&amp;继承"></a>组合&amp;继承</h4><p>使用组合而非继承实现组件之间的代码重用</p>
<p>类似于 vue 的 slot，默认放在组件内部会作为 props.children 传递给子组件，当需要区分的时候，需要自定约定传入的 props</p>
<h2 id="高级指引"><a href="#高级指引" class="headerlink" title="高级指引"></a>高级指引</h2><h3 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h3><h4 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h4><p>使用 React Fragments 来组合各个组件，类似于 Vue 中的 template<br>简写形式是 &lt;&gt;&lt;/ &gt;</p>
<p>其他内容看起来不是那么重要，略过</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="react-createContext"><a href="#react-createContext" class="headerlink" title="react.createContext"></a>react.createContext</h4><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。<br>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<h4 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h4><p>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。不对其赋值是无法使用 this.context 获取值的。</p>
<h3 id="refs-转发"><a href="#refs-转发" class="headerlink" title="refs 转发"></a>refs 转发</h3><p>refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素</p>
<p>基本用法 首先声明引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = React.createRef();</span><br></pre></td></tr></table></figure>
<p>然后再你希望获取引用的节点上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;ref&#125; value=&#123;props.content&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>这样在声明周期函数中，就可以使用 ref.current 获取到该节点的引用的</p>
<h4 id="在高阶组件转发-refs"><a href="#在高阶组件转发-refs" class="headerlink" title="在高阶组件转发 refs"></a>在高阶组件转发 refs</h4><p>一般我们用高阶组件，会将所有 props 传递到其包裹的组件。但是 refs 不会传递，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 React.forwardRef API 明确地将 refs 转发到内部的组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;old props:&quot;</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;new props:&quot;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">  <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">  <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">  <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 React.forwardRef,普通的函数组件是不会获得该参数的，因为函数组件没有实例。<br>不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 DOM 元素或 class 组件：<br>使用 hooks</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里必须声明 textInput，这样 ref 才可以引用它</span></span><br><span class="line">  <span class="keyword">const</span> textInput = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;textInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有个问题，useRef 和 createRef 看起来没啥区别啊</p>
<p>百度之后得到的答案是 createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</p>
<p>useRef 仅能用在 FunctionComponent，createRef 仅能用在 ClassComponent。！！！</p>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p>
<h2 id="珠峰前端"><a href="#珠峰前端" class="headerlink" title="珠峰前端"></a>珠峰前端</h2><h3 id="生命周期详解"><a href="#生命周期详解" class="headerlink" title="生命周期详解"></a>生命周期详解</h3><h4 id="初始渲染阶段"><a href="#初始渲染阶段" class="headerlink" title="初始渲染阶段"></a>初始渲染阶段</h4><p>componentWillMount -&gt; render -&gt; componentDidMount</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>shouldComponentUpdate</p>
<ul>
<li>返回 true -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</li>
<li>返回 false 不处理</li>
</ul>
<p>从父组件传来的 props 改变<br>componentWillReceiveProps</p>
<ul>
<li>返回 true -&gt; shouldComponentUpdate -&gt; 走上面的流程</li>
<li>返回 false 不处理</li>
</ul>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><p>componentWillUnmount<br>在这个生命周期勾子中清除定时器，防止内存泄漏</p>
<p><img src="/2020/03/30/react/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/生命周期.png" alt="生命周期"></p>
<h4 id="react16-3-生命周期的变化"><a href="#react16-3-生命周期的变化" class="headerlink" title="react16.3 生命周期的变化"></a>react16.3 生命周期的变化</h4><p>我看的这个视频时 18 年的，在之后 react 的生命周期有一次大的变动，增加了 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 这两个生命周期函数，同时 componentWillMount 和 componentWillReceiveProps 已经不推荐使用，将在未来的 react 版本中移除</p>
<p>getDerivedStateFromProps</p>
<p>这个生命周期会在每次 re-rendering 之前被调用<br><strong>意味着即使你的 props 没有任何变化，而是父 state 发生了变化，导致子组件发生了 re-render，这个生命周期函数依然会被调用</strong></p>
<p><img src="/2020/03/30/react/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/生命周期新.png" alt="生命周期新"></p>
<h3 id="PropTypes-类型检查"><a href="#PropTypes-类型检查" class="headerlink" title="PropTypes 类型检查"></a>PropTypes 类型检查</h3><ul>
<li>array 数组</li>
<li>bool 布尔值</li>
<li>func 函数</li>
<li>number 数字</li>
<li>object 对象</li>
<li>string 字符换</li>
<li>symbol 符号</li>
<li>node 任何节点 numbers strings elements 或者包含这些类型的数组或者片段</li>
<li>element React 元素</li>
<li>instanceOf(Message) 类的一个实例</li>
<li>oneOf([‘News’,’Photos’]) 枚举值</li>
<li>oneOfType([PropTypes.string,PropTypes.number]) 多种类型中其中之一</li>
<li>arrayOf(PropTypes.number) 某种类型的数组</li>
<li>objectOf(PropTypes.number) 某种类型的对象</li>
<li>shape 特定形式的对象</li>
<li>.required 必填</li>
<li>function(){return new Error()} 自定义验证器</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>分析性能 react 可以直接使用 react_perf，然后使用 chrome 进行录制分析</p>
<h3 id="避免重复渲染"><a href="#避免重复渲染" class="headerlink" title="避免重复渲染"></a>避免重复渲染</h3><p>重写 shouldComponentUpdate 减少重新渲染</p>
<h4 id="PureConponent"><a href="#PureConponent" class="headerlink" title="PureConponent"></a>PureConponent</h4><p>继承自 component，它做了一个优化，它重写了 shouleComponentUpdate 方法<br>这个比较是浅比较，所以 props 如果是对象，会出现无法更新的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> nextProps)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextProps[prop]!==<span class="built_in">this</span>.props[prop])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> state <span class="keyword">in</span> nextStates)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextStates[state]!==<span class="built_in">this</span>.states[state])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h3><p>可共享的变化是万恶之源，js 中的对象一般是可变的，因为使用引用赋值，对引用对象的修改会影响的原始对相关，为了避免这种影响，一般采用浅拷贝或者深拷贝的方式，但是如果对象的属性很多，就会造成 CPU 和内存的浪费。</p>
<p>immutable 中的数据一旦被创建，就不能被更改，所有修改和添加删除操作都会返回一个新的 immutable 对象。immutable 的实现原理是 Persistent Data Structure(持久化数据结构)，这个咱之前也接触过，主席树的原理啊，抽空研究一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="built_in">Map</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;immutable&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> m1 = <span class="built_in">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(m1.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> m2 = m1.set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;11&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m2.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(m1.get(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(m1 === m2);</span><br></pre></td></tr></table></figure>
<p>缺陷 体积过大 20k</p>
<h4 id="seamiess-immutable"><a href="#seamiess-immutable" class="headerlink" title="seamiess-immutable"></a>seamiess-immutable</h4><p>使用 Object.defineProperty 扩展的 Javascript 的 Array 和 Object 对象来实现，只支持 Array 和 Objcet 两种数据类型</p>
<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>标准写法，参数就是 state 的初始值，解构得到的第二个变量是设置该 state 的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。</p>
<p>当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。</p>
<p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><p>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</p>
<p>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中。）</p>
<h3 id="通过跳过-Effect-进行性能优化"><a href="#通过跳过-Effect-进行性能优化" class="headerlink" title="通过跳过 Effect 进行性能优化"></a>通过跳过 Effect 进行性能优化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure>
<h2 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal"></a>createPortal</h2><p>将组件渲染到组件树之外的地方，可以用来做弹窗</p>
<h3 id="diff-算法处理-key"><a href="#diff-算法处理-key" class="headerlink" title="diff 算法处理 key"></a>diff 算法处理 key</h3><p>// TODO<br>希望操作最小化</p>
<p>第一步，把老数组在新数组中没有的元素移除掉</p>
<h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><h3 id="React-render"><a href="#React-render" class="headerlink" title="React render"></a>React render</h3><h4 id="触发-render-的场景"><a href="#触发-render-的场景" class="headerlink" title="触发 render 的场景"></a>触发 render 的场景</h4><ul>
<li>状态更新时，类组件调用 setState 或者 函数组件的 state 更新</li>
<li>父容器重新渲染，无论子组件的实现如何，都会重新渲染</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>谨慎分配 state，为了避免不必要的 render，可以将状态下放到更低层级的组件</p>
<h4 id="合并状态更新"><a href="#合并状态更新" class="headerlink" title="合并状态更新"></a>合并状态更新</h4><h4 id="使用-PureComponent-和-React-memo-避免不必要的-render-调用"><a href="#使用-PureComponent-和-React-memo-避免不必要的-render-调用" class="headerlink" title="使用 PureComponent 和 React.memo 避免不必要的 render 调用"></a>使用 PureComponent 和 React.memo 避免不必要的 render 调用</h4><p>避免组件不必要的渲染的方法有：React.memo 包裹的函数式组件，继承自 React.PureComponent 的 class 组件。</p>
<h5 id="浅比较"><a href="#浅比较" class="headerlink" title="浅比较"></a>浅比较</h5><p>用 PureComponent 或者 React.memo 修饰的组件，每次更新的时候都对 props 和 state 进行一次浅比较。如果有对象，且对象引用变化，就会触发重渲染。由于函数也是引用类型，如果传递的是箭头函数（匿名函数），组件也会在父组件重新渲染的时候重新渲染。</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [foo] = useState(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> main = useMemo(</span><br><span class="line">    <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;1&#125;</span> <span class="attr">x</span>=<span class="string">&#123;1&#125;</span> <span class="attr">foo</span>=<span class="string">&#123;foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;2&#125;</span> <span class="attr">x</span>=<span class="string">&#123;2&#125;</span> <span class="attr">foo</span>=<span class="string">&#123;foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;3&#125;</span> <span class="attr">x</span>=<span class="string">&#123;3&#125;</span> <span class="attr">foo</span>=<span class="string">&#123;foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;4&#125;</span> <span class="attr">x</span>=<span class="string">&#123;4&#125;</span> <span class="attr">foo</span>=<span class="string">&#123;foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;5&#125;</span> <span class="attr">x</span>=<span class="string">&#123;5&#125;</span> <span class="attr">foo</span>=<span class="string">&#123;foo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    [foo]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;setCount<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;main&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2文档查漏补缺</title>
    <url>/2020/10/01/vue/vue2%E6%96%87%E6%A1%A3%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<p>即将去一家 vue 技术栈的公司干活了，其实对于 vue2 的掌握，我还是有不少欠缺的，自己通读 vue2 的文档还是大一的时候，后面 vue2 的版本经历了多次更新，这些更新的内容我基本就没怎么看过了，这次就来查漏补缺一下，这份笔记只记录自己不熟悉的内容。</p>
<h2 id="不同构建版本"><a href="#不同构建版本" class="headerlink" title="不同构建版本"></a>不同构建版本</h2><p>这里有几个概念</p>
<ul>
<li>完整版，同时包含运行时和编译器的版本</li>
<li>编译器，如果需要使用 template 选项，需要使用带编译器的完整版。如果你仍然希望使用完整版，则需要在打包工具里配置一个别名：</li>
<li>运行时，除去编译器的一切</li>
<li>UMD，统一模块规范，提供了一个 AMD,CMD,ES Module 的兼容层</li>
<li>CMD，这是 nodejs 的模块化规范，配合老的打包工具如 Browserify 或 webpack 1。</li>
<li>ES Module 从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件：<ul>
<li>为打包工具提供的 ESM：为诸如 webpack 2 或 Rollup 提供的现代打包工具。ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。为这些打包工具提供的默认文件 (pkg.module) 是只有运行时的 ES Module 构建 (vue.runtime.esm.js)。</li>
<li>为浏览器提供的 ESM (2.6+)：用于在现代浏览器中通过 script type=”module” 直接导入。</li>
</ul>
</li>
</ul>
<h3 id="CSP-环境"><a href="#CSP-环境" class="headerlink" title="CSP 环境"></a>CSP 环境</h3><p>在某些环境，如 Google Chrome Apps，会强制应用内容安全策略 CSP，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。运行时版本是完全兼容 CSP 的，当通过 webpack + vue-loader 或者 Browserify + vueify 构建时，模板将被预编译为 render 函数，可以在 CSP 环境中完美运行。</p>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p>这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。这里 Vue 3 直接提供了一个 api markRaw</p>
<p>v-once 可以执行一次性的插值，当数据改变时，插值处的内容不会更新。</p>
<h3 id="模板中的全局变量"><a href="#模板中的全局变量" class="headerlink" title="模板中的全局变量"></a>模板中的全局变量</h3><p>模板中的表达式都被放在沙盒中，只能访问全局变量的一个白名单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allowedGlobals = makeMap(</span><br><span class="line">  <span class="string">&quot;Infinity,undefined,NaN,isFinite,isNaN,&quot;</span> +</span><br><span class="line">    <span class="string">&quot;parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,&quot;</span> +</span><br><span class="line">    <span class="string">&quot;require&quot;</span> <span class="comment">// for Webpack/Browserify</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>动态参数，2.6.0 新增，可以使用 方括号括起来的 js 表达式作为一个指令的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]=<span class="string">&quot;url&quot;</span>&gt; ... &lt;/a&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="对动态参数值的约束"><a href="#对动态参数值的约束" class="headerlink" title="对动态参数值的约束"></a>对动态参数值的约束</h4><p>动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p>
<h4 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h4><p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">在 DOM 中使用模板时这段代码会被转换为 <span class="string">`v-bind:[someattr]`</span>。</span><br><span class="line">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span><br><span class="line">--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值。这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">now</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#watch-example&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">question</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">answer</span>: <span class="string">&quot;I cannot give you an answer until you ask a question!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    <span class="attr">question</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&quot;Waiting for you to stop typing...&quot;</span>;</span><br><span class="line">      <span class="built_in">this</span>.debouncedGetAnswer();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    <span class="built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="built_in">this</span>.getAnswer, <span class="number">500</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">getAnswer</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.question.indexOf(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.answer = <span class="string">&quot;Questions usually contain a question mark. ;-)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&quot;Thinking...&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">      axios</span><br><span class="line">        .get(<span class="string">&quot;https://yesno.wtf/api&quot;</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">          vm.answer = <span class="string">&quot;Error! Could not reach the API. &quot;</span> + error;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="class-与-style-绑定"><a href="#class-与-style-绑定" class="headerlink" title="class 与 style 绑定"></a>class 与 style 绑定</h2><p>当在一个自定义组件上使用 class 属性时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</p>
<p>当 v-bind 使用需要添加浏览器引擎前缀的 CSS 属性值时，Vue.js 会自动侦测并添加响应的前缀。</p>
<h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div :style=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h3><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for-中使用对象"><a href="#v-for-中使用对象" class="headerlink" title="v-for 中使用对象"></a>v-for 中使用对象</h3><p>你也可以用 v-for 来遍历一个对象的属性。<br>你也可以提供第二个的参数为 property 名称 (也就是键名)：<br>还可以用第三个参数作为索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。</p>
<h3 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h3><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>Vue 将被侦听的数组变异方法进行了包裹，所以它们也会触发视图更新，这些方法包括：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push();</span><br><span class="line">pop();</span><br><span class="line">shift();</span><br><span class="line">unshift();</span><br><span class="line">splice();</span><br><span class="line">sort();</span><br><span class="line">reverse();</span><br></pre></td></tr></table></figure>
<h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>filter()、concat() 和 slice()。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p>
<h3 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h3><p>有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。<br>在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法：</p>
<h3 id="v-for-里使用值范围"><a href="#v-for-里使用值范围" class="headerlink" title="v-for 里使用值范围"></a>v-for 里使用值范围</h3><p>v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="template-上使用-v-for"><a href="#template-上使用-v-for" class="headerlink" title="template 上使用 v-for"></a>template 上使用 v-for</h3><p>类似于 v-if，你也可以利用带有 v-for 的 template 来循环渲染一段包含多个元素的内容。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h3 id="组件上使用-v-for"><a href="#组件上使用-v-for" class="headerlink" title="组件上使用 v-for"></a>组件上使用 v-for</h3><p>在 2.2.0+的版本里，在组件上使用 v-for 时，key 现在是必须的</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>当需要访问原始 DOM 事件时，可以用特殊变量 $event 把它传入方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.stop</span><br><span class="line">.prevent</span><br><span class="line">.capture</span><br><span class="line">.self</span><br><span class="line">.once 事件只会触发一次，可以被用到自定义的组建事件上</span><br><span class="line">.passive 对应于 addEventListener 的 passive 属性，表明这个函数不能使用 preventDefault。如果和 .prevent一起使用，浏览器会给予警告</span><br></pre></td></tr></table></figure>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>vue 允许为 v-on 在监听键盘事件时添加修饰符。</p>
<p>直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">KeyboardEvent.key</a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure>
<p>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>鼠标按钮修饰符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.middle</span><br></pre></td></tr></table></figure>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model 本质上是语法糖，他负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p>text 和 textarea 元素使用 value 属性和 input 事件；<br>checkbox 和 radio 使用 checked 属性和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。</p>
<p>在 textarea 处使用插值语法不会生效。<br>单个复选框，绑定到布尔值，多个复选框，应绑定到数组。<br>单选按钮，选项应绑定到同一个值。</p>
<p>select 单选时，如果 v-model 表达式的初始值未能匹配任何选项，select 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>select 多选时，应绑定到一个数组。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>.lazy 默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件<strong>之后</strong>进行同步。</p>
<p>.number 自动将用户输入转为 number 类型，如果这个值无法被 parseFloat 解析，就会返回原始值。</p>
<p>.trim 自动过滤用户输入的首尾空白字符</p>
<h3 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h3><p>默认会使用组件的 value 和 input 事件，可以使用 model 属性修改默认行为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-checkbox&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;checked&quot;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&quot;change&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;my-component-name&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>上述内容可以通过 Vue 的 component 元素加一个特殊的 is attribute 来实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请留意，这个 attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，若想让其如预期般工作，你需要使用 .prop 修饰器。</p>
<h4 id="dom-property-和-attribute-的区别"><a href="#dom-property-和-attribute-的区别" class="headerlink" title="dom property 和 attribute 的区别"></a>dom property 和 attribute 的区别</h4><p>当写 html 代码的时候，你可以在 html 标签上定义 attr，当浏览器解析你的 html 代码的时候，一个相应的 dom 节点会被创建，这个节点是一个对象，因此他具有他自己的属性。对于一个给定的 DOM 节点对象，属性是对象的属性，attributes 是对象的 attributes 属性里的元素。</p>
<p>当一个 DOM 节点被创建，dom 对象的许多 preperty 和 它的 attributes 里面的属性是相关联的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;the-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Name:&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>相应的 dom 节点会有 id，type 和 value 属性</p>
<p>id 属性是 id attribute 的反射，对其进行读写会直接改变 attribute 中的 id 属性。<br>type 属性 对其进行读写操作会改变 attribute 中的 type，但是它并不是一个纯的映射，因为它的值被限定在运行的列表内。<br>value 属性则不是一个映射，它是 input 控件元素的当前值，对其进行写入不会更改 attribute 中的 value。</p>
<h3 id="解析-dom-模板的注意事项"><a href="#解析-dom-模板的注意事项" class="headerlink" title="解析 dom 模板的注意事项"></a>解析 dom 模板的注意事项</h3><p>有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。<br>使用以下来源的模板，这种限制是不存在的。<br>字符串 (例如：template: ‘…’)<br>单文件组件 (.vue)<br>script type=”text/x-template”</p>
<h2 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h2><h3 id="prop-类型检查"><a href="#prop-类型检查" class="headerlink" title="prop 类型检查"></a>prop 类型检查</h3><p>type 可以是下列原生构造函数中的一个</p>
<p>String<br>Number<br>Boolean<br>Array<br>Object<br>Date<br>Function<br>Symbol</p>
<p>额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。</p>
<h3 id="非-prop-的-attribute"><a href="#非-prop-的-attribute" class="headerlink" title="非 prop 的 attribute"></a>非 prop 的 attribute</h3><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。这些 attribute 会被添加到这个组件的根元素上。</p>
<h3 id="替换-合并已有的-Attribute"><a href="#替换-合并已有的-Attribute" class="headerlink" title="替换/合并已有的 Attribute"></a>替换/合并已有的 Attribute</h3><p>对于大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。class 和 style attribute 会稍微智能一些，即两边的值会被合并起来。</p>
<h3 id="禁用-Attribute-继承"><a href="#禁用-Attribute-继承" class="headerlink" title="禁用 Attribute 继承"></a>禁用 Attribute 继承</h3><p>如果不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。<br>这尤其适合配合实例的 $attrs 属性使用，该属性包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="string">&#x27;Enter your username&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>如果希望监听原生事件，需要使用.native 修饰符。</p>
<p>.sync 语法糖 是以下方式的简写,带有.sync 修饰符的 v-bind 不能和表达式一起使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插槽-编译作用域"><a href="#插槽-编译作用域" class="headerlink" title="插槽 编译作用域"></a>插槽 编译作用域</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这里的 `url` 会是 undefined，因为 &quot;/profile&quot; 是</span></span><br><span class="line"><span class="comment">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="line"><span class="comment">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 submit-button 组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>在向具名插槽提供内容的时候，我们可以在一个 template 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意 v-slot 只能添加在 template 上</p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>绑定在 slot 元素上的 attribute 被称为插槽 prop。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span> &#123;&#123; user.lastName &#125;&#125; <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 slot 元素的一个 attribute 绑定上去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span> &#123;&#123; user.lastName &#125;&#125; <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>
<p>还可以更简单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span> &#123;&#123; slotProps.user.firstName &#125;&#125; <span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="解构插槽-prop"><a href="#解构插槽-prop" class="headerlink" title="解构插槽 prop"></a>解构插槽 prop</h3><p>插槽 prop 可以使用解构语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span> &#123;&#123; user.firstName &#125;&#125; <span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以定义默认值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h3><p>和动态属性名一样</p>
<h3 id="具名插槽缩写"><a href="#具名插槽缩写" class="headerlink" title="具名插槽缩写"></a>具名插槽缩写</h3><p>使用 #</p>
<h3 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h3><p>使用动态组件的时候，有时会向保持这些组件的状态</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h3 id="程式化的事件侦听器"><a href="#程式化的事件侦听器" class="headerlink" title="程式化的事件侦听器"></a>程式化的事件侦听器</h3><p>如此可以避免在实例上添加不必要的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">attachDatepicker</span>: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      <span class="attr">field</span>: <span class="built_in">this</span>.$refs[refName],</span><br><span class="line">      <span class="attr">format</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>可以在自己的模板中调用自身，只能通过 name 选项来做这件事</p>
<h3 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h3><p>当 inline-template 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component&#x27;s own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent&#x27;s transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>X-Template</p>
<p>另一个定义模板的方式是在一个 script 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;hello-world&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&quot;#hello-world-template&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h3><p>使用 <code>forceUpdate</code> 来做这件事,只有很少的情况下才需要做这件事</p>
<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p><img src="/2020/10/01/vue/vue2%E6%96%87%E6%A1%A3%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/css过渡.png" alt="css过渡"></p>
<h3 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h3><p>可以在节点上设置 appear，也可以设置自定义的类名和钩子函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition appear&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><p>默认是旧元素的离开和新元素的进入同时发生，可以设置 mode</p>
<p>in-out 新元素先进性过渡，完成后当前元素过渡离开<br>out-in 当前元素先进行过渡，完成后新元素过渡进入</p>
<h3 id="多个组件的过渡，使用动态组件"><a href="#多个组件的过渡，使用动态组件" class="headerlink" title="多个组件的过渡，使用动态组件"></a>多个组件的过渡，使用动态组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;component-fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb入门</title>
    <url>/2019/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Mongodb%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>跟着官方文档学习</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>db 显示当前数据库</p>
<h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">item</span>: <span class="string">&quot;journal&quot;</span>,</span><br><span class="line">    <span class="attr">qty</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="attr">size</span>: &#123; <span class="attr">h</span>: <span class="number">14</span>, <span class="attr">w</span>: <span class="number">21</span>, <span class="attr">uom</span>: <span class="string">&quot;cm&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&quot;blank&quot;</span>, <span class="string">&quot;red&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">item</span>: <span class="string">&quot;notebook&quot;</span>,</span><br><span class="line">    <span class="attr">qty</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="attr">size</span>: &#123; <span class="attr">h</span>: <span class="number">8.5</span>, <span class="attr">w</span>: <span class="number">11</span>, <span class="attr">uom</span>: <span class="string">&quot;in&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.inventory.find(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>美化查询结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.inventory.find(&#123;&#125;).pretty();</span><br></pre></td></tr></table></figure>
<h3 id="相等匹配"><a href="#相等匹配" class="headerlink" title="相等匹配"></a>相等匹配</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.inventory.find(&#123; <span class="attr">status</span>: <span class="string">&quot;D&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>对于数组，严格相等，数组项的顺序也要一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不匹配 &#123; tags: [&quot;blank&quot;, &quot;red&quot;] &#125;</span></span><br><span class="line">db.inventory.find(&#123; <span class="attr">tags</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>] &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="定义返回结构-Projection"><a href="#定义返回结构-Projection" class="headerlink" title="定义返回结构 Projection"></a>定义返回结构 Projection</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; &#125;, &#123; item: 1, status: 1 &#125; );</span><br></pre></td></tr></table></figure>
<p>默认全是 0 或者全是 1，不能既有 0 又有 1</p>
<h2 id="database-and-collections"><a href="#database-and-collections" class="headerlink" title="database and collections"></a>database and collections</h2><p>MongoDB 在集合中存储 BSON 文档，即数据记录;数据库中的集合。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>可以 使用 use 去切换到一个不存在的数据库</p>
<p>如果数据库不存在，MongoDB 将在您第一次为该数据库存储数据时创建数据库。</p>
<p>MongoDB 将文档存储在集合中。集合类似于关系数据库中的表。</p>
<p>如果一个集合不存在，MongoDB 会在您第一次存储该集合的数据时创建该集合。</p>
<h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><p>ObjectId 是一个 12 字节的 BSON 类型字符串。按照字节顺序，依次代表：</p>
<ul>
<li>4 字节 UNIX 时间戳</li>
<li>3 字节 运行 MongoDB 的机器</li>
<li>2 字节 代表生成次 id 的进程</li>
<li>3 字节 由一个随机数开始的的计数器生成的值</li>
</ul>
<p>使用这种机制可以保证唯一性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.myNewCollection2.insertOne(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br><span class="line">db.myNewCollection3.createIndex(&#123; <span class="attr">y</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>如果 insertOne()和 createIndex()操作还不存在，那么它们将创建各自的集合。确保集合名称遵循 MongoDB 命名限制。</p>
<p>db.createCollection() 可以显式以指定的选项创建一个数据库</p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view 是一个可查询的对象，由其他集合或者视图聚合产生。</p>
<p>MongoDB 并不在硬盘中保存 view，而是在需要的时候进行计算。view 不支持写操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.createCollection(</span><br><span class="line">  <span class="string">&quot;&lt;viewName&gt;&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;viewOn&quot;</span> : <span class="string">&quot;&lt;source&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pipeline&quot;</span> : [&lt;pipeline&gt;],</span><br><span class="line">    <span class="string">&quot;collation&quot;</span> : &#123; &lt;collation&gt; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">db.createView(</span><br><span class="line">  <span class="string">&quot;&lt;viewName&gt;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&lt;source&gt;&quot;</span>,</span><br><span class="line">  [&lt;pipeline&gt;],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;collation&quot;</span> : &#123; &lt;collation&gt; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>view 支持以下方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.collection.find();</span><br><span class="line">db.collection.findOne();</span><br><span class="line">db.collection.aggregate();</span><br><span class="line">db.collection.countDocuments();</span><br><span class="line">db.collection.estimatedDocumentCount();</span><br><span class="line">db.collection.count();</span><br><span class="line">db.collection.distinct();</span><br></pre></td></tr></table></figure>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.collsetion.update(</span><br><span class="line">  &lt;query&gt;,</span><br><span class="line">  &lt;updateObj&gt;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">upsert</span>:&lt;boolean&gt;,</span><br><span class="line">    multi:&lt;boolean&gt;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>update 更新后的对象或指定一些更新的操作符</p>
<ul>
<li><code>$set</code> 直接指定更新后的值</li>
<li><code>$inc</code> 在原基础上累加</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">age</span>: <span class="number">44</span> &#125; &#125;);</span><br><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;, &#123; <span class="attr">$inc</span>: &#123; <span class="attr">age</span>: <span class="number">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$unset</code> 删除字段，如果字段不存在不做处理</li>
<li><code>$push</code> 向数组添加数据</li>
<li><code>$ne</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">hobby</span>: &#123; <span class="attr">$ne</span>: <span class="string">&quot;smoking&quot;</span> &#125; &#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$each</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.students.update(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;zf&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">$push</span>: &#123; <span class="attr">hobby</span>: &#123; <span class="attr">$each</span>: [<span class="string">&quot;smok&quot;</span>, <span class="string">&quot;dringing&quot;</span>] &#125; &#125; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$addToSet</code> 插入到集合，可以保证唯一性，如果项是重复的，将不会被插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.students.update(&#123; <span class="attr">name</span>: <span class="string">&quot;zfpx&quot;</span> &#125;, &#123; <span class="attr">$addToSet</span>: &#123; <span class="attr">hobby</span>: <span class="string">&quot;drink&quot;</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<p>upsert 可选，不过不存在记录是否插入，默认不插入<br>muitl 可选，默认只更新找到的第一条记录，如果为 true，更新所有符合的记录</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><code>$eq</code>：匹配字段值等于指定值的文档</p>
<p><code>$gt</code>：匹配字段值大于指定值的文档</p>
<p><code>$gte</code>：匹配字段值大于等于指定值的文档</p>
<p><code>$lt</code>：匹配字段值小于指定值的文档</p>
<p><code>$lte</code>：匹配字段值小于等于指定值的文档</p>
<p><code>$ne</code>：匹配字段值不等于指定值的文档，包括没有这个字段的文档</p>
<p><code>$in</code>：匹配字段值等于指定数组中的任何值</p>
<p><code>$nin</code>：字段值不在指定数组或者不存在</p>
<p><code>$or</code>：文档至少满足其中的一个表达式</p>
<p><code>$not</code>：字段值不匹配表达式或者字段值不存在</p>
<p><code>$nor</code>：字段值不匹配所有的表达式的文档，包括那些不包含这些字段的文档</p>
<p><code>$exists</code>：boolean 等于 true 时，字段存在，包括字段值为 null 的文档</p>
<p><code>$type</code>：匹配字段值为指定数据类型的文档</p>
<p><code>$mod</code>：匹配字段值被除有指定的余数的文档</p>
<p><code>$regex</code>：正则表达式可以匹配到的文档</p>
<p><code>$text</code>：针对创建了全文索引的字段进行文本搜索</p>
<p><code>$where</code>：可以通过 js 表达式或 js 函数来查询文档<br><code>$all</code>: 字段值是包含所有指定元素的数组的文档<br><code>$elemMatch</code>：数组字段至少一个元素满足所有指定查询条件的文档<br><code>$size</code>：匹配数组字段元素个数等于指定数量的文档<br><code>$ (projection)</code>：限定查询结果中指定数组字段返回满足条件的第一个元素<br><code>$elemMatch (projection)</code>：限定查询结果中指定数组字段返回满足条件的第一个元素<br><code>$slice (projection)</code>：控制指定数组字段返回元素个数<br><code>$inc</code>：给一个字段增加指定值<br><code>$setOnInsert</code> ：upsert 为 true 时，有插入文档操作时插入指定字段值<br><code>$unset</code>：删除指定字段</p>
<p><code>$min</code>：指定值小于当前值则更新为指定值<br><code>$max</code>: 指定值大于当前值则更新为指定值<br><code>$currentDate</code>:设置字段值为当前日期</p>
<p><code>$</code>: 更新指定数组的第一个元素<br><code>$addToSet</code>:数组字段增加一个值<br><code>$pop</code>: 删除数组字段中的第一个或最后一个元素<br><code>$pullAll</code>: 删除数组字段中所有指定值，如果指定值为数组，则删除匹配数组内的元素<br><code>$pull</code>: 符合条件的值将被删除<br><code>$pushAll</code>：向数组中追加多个指定值<br><code>$push</code>：向数组中追加值<br><code>$each</code>：用于 <code>$addToSet</code> 添加多个值到数组中</p>
<h3 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h3><h4 id="通过配置项启动数据库"><a href="#通过配置项启动数据库" class="headerlink" title="通过配置项启动数据库"></a>通过配置项启动数据库</h4><p>—dbpath 数据库文件的目录<br>—port 默认是 27017 28017<br>—fork 以后台守护方式运行<br>—logpath 日志目录<br>—config 指定一个配置文件<br>—auth 以安全参数启动</p>
<h4 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h4><p>mongoimport 导出数据<br>mongoexport 导入数据</p>
<p>mongodb 使用 mongorestore 来恢复备份的数据</p>
<p>Mongodump 可以 backup 整个数据库，而 mongoexport 要对每个 conllection 进行操作。恢复使用 mongostore</p>
<p>mongoexport 输出的 json 比 mongodump 的 bson 可读性高，进而可以直接对 json 文件进行操作然后还原数据（bson 转换 json 存在潜在兼容问题）</p>
<h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><p>物理隔离<br>网络隔离<br>防火墙<br>用户名和密码验证</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">show roles 查看角色</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>:<span class="string">&#x27;zf&#x27;</span>,<span class="attr">pwd</span>:<span class="string">&#x27;123&#x27;</span>,<span class="attr">roles</span>:[&#123;<span class="attr">db</span>:<span class="string">&#x27;school&#x27;</span>&#125;,<span class="attr">role</span>:<span class="string">&#x27;read&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>ensure 表示升序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.students.ensureIndex(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="分析索引的执行过程"><a href="#分析索引的执行过程" class="headerlink" title="分析索引的执行过程"></a>分析索引的执行过程</h4><p>mongodb 提供了 explain 命令来分析查询过程</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1 为正序 -1 为倒序<br>索引可以提升查询速度，但会降低插入速度<br>数据量不大时不需要使用索引，性能的提升不明显，反而大大增加了内存和硬盘的消耗<br>查询数据超过表数据量 30%时，不要使用索引字段查询<br>排序工作的时候可以建立索引提高排序速度<br>数字索引要比字符串索引快得多</p>
<h3 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>数据库集群中明确知道谁是主服务器，主服务器只有一台<br>从服务器要知道自己的数据源也就是主服务器是谁<br>—master 用来确定主服务器，—slave 和—source 来控制从服务器</p>
<h5 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h5><p>-only 从节点 指定复制某个数据库<br>-slavedelay 从节点 设置主数据库同步数据的延迟<br>-fastsync 从节点 以主数据库的节点快照为节点启动从数据库<br>-autoresync 从节点 如果不同步则重新同步数据库<br>-oplogSize 主节点 设置 oplog 的大小</p>
<h5 id="db-sources"><a href="#db-sources" class="headerlink" title="db.sources"></a>db.sources</h5><p>提供了 api 设置从服务器的 source</p>
<h4 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h4><p>需要一台活跃服务器和两个备份服务器<br>当活跃服务器故障，集群根据权重算法推选出活跃服务器<br>当原来的主服务器恢复后又会变成从服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbpath=...</span><br><span class="line">prot=...</span><br><span class="line">replSet=group  // 每个副本集需要有一个名字</span><br></pre></td></tr></table></figure>
<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">  <span class="attr">binary</span>: Buffer,</span><br><span class="line">  <span class="attr">living</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">  <span class="attr">birthday</span>: <span class="built_in">Date</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">Number</span>,</span><br><span class="line">  <span class="attr">_id</span>: Schema.Types.ObjectId,</span><br><span class="line">  <span class="attr">_fk</span>: Schema.Types.ObjectId,</span><br><span class="line">  <span class="attr">array</span>: [],</span><br><span class="line">  <span class="attr">arrOfString</span>: [<span class="built_in">String</span>],</span><br><span class="line">  <span class="attr">arrOfNumber</span>: [<span class="built_in">Number</span>],</span><br><span class="line">  <span class="comment">// 内嵌文档</span></span><br><span class="line">  <span class="attr">nested</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="SchemaType"><a href="#SchemaType" class="headerlink" title="SchemaType"></a>SchemaType</h4><p>以下是 mongoose 的所有合法 SchemaTypes：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
<li>Decimal128<br>直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象。</li>
</ul>
<h5 id="全部可用"><a href="#全部可用" class="headerlink" title="全部可用"></a>全部可用</h5><ul>
<li>required: 布尔值或函数 如果值为真，为此属性添加 required 验证器</li>
<li>default: 任何值或函数 设置此路径默认值。如果是函数，函数返回值为默认值</li>
<li>select: 布尔值 指定 query 的默认 projections 为 false 默认不返回该字段</li>
<li>validate: 函数 adds a validator function for this property</li>
<li>get: 函数 使用 Object.defineProperty() 定义自定义 getter 这个 getter 是在访问该属性时生效的 consolelog 打印的还是初始值</li>
<li>set: 函数 使用 Object.defineProperty() 定义自定义 setter</li>
<li>alias: 字符串 仅 mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets</li>
</ul>
<h5 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h5><ul>
<li>index: 布尔值 是否对这个属性创建索引</li>
<li>unique: 布尔值 是否对这个属性创建唯一索引</li>
<li>sparse: 布尔值 是否对这个属性创建稀疏索引</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><ul>
<li>lowercase: 布尔值 是否在保存前对此值调用 .toLowerCase()</li>
<li>uppercase: 布尔值 是否在保存前对此值调用 .toUpperCase()</li>
<li>trim: 布尔值 是否在保存前对此值调用 .trim()</li>
<li>match: 正则表达式 创建验证器检查这个值是否匹配给定正则表达式</li>
<li>enum: 数组 创建验证器检查这个值是否包含于给定数组</li>
</ul>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><ul>
<li>min: 数值 创建验证器检查属性是否大于或等于该值</li>
<li>max: 数值 创建验证器检查属性是否小于或等于该值</li>
</ul>
<h5 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h5><ul>
<li>min: Date</li>
<li>max: Date</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p><strong>Dates</strong><br>内建 Date 方法 不会触发 mongoose 修改跟踪逻辑， 如果你对使用 setMonth() 修改文档里的 Date， mongoose 在 doc.save() 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库。 如果你一定要用内建 Date 方法， 请手动调用 doc.markModified(‘pathToYourDate’) 告诉 mongoose 你修改了数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Assignment = mongoose.model(<span class="string">&quot;Assignment&quot;</span>, &#123; <span class="attr">dueDate</span>: <span class="built_in">Date</span> &#125;);</span><br><span class="line">Assignment.findOne(<span class="function"><span class="keyword">function</span> (<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">  doc.dueDate.setMonth(<span class="number">3</span>);</span><br><span class="line">  doc.save(callback); <span class="comment">// THIS DOES NOT SAVE YOUR CHANGE</span></span><br><span class="line"></span><br><span class="line">  doc.markModified(<span class="string">&quot;dueDate&quot;</span>);</span><br><span class="line">  doc.save(callback); <span class="comment">// works</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Mixed</strong><br>一个啥都可以放的 SchemaType ， 虽然便利，但也会让数据难以维护。 Mixed 可以通过 Schema.Types.Mixed 或 传入一个空对象定义。以下三种方法效果一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: &#123;&#125; &#125;);</span><br><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: <span class="built_in">Object</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Any = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: Schema.Types.Mixed &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>ObjectIds</strong></p>
<p>创造 SchemaTypes 或子文档数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ToySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> ToyBox = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">toys</span>: [ToySchema],</span><br><span class="line">  <span class="attr">buffers</span>: [Buffer],</span><br><span class="line">  <span class="attr">string</span>: [<span class="built_in">String</span>],</span><br><span class="line">  <span class="attr">numbers</span>: [<span class="built_in">Number</span>],</span><br><span class="line">  <span class="comment">// ... etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>指定空数组相当于 Mixed</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Empty1 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [] &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty2 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: <span class="built_in">Array</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty3 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [Schema.Types.Mixed] &#125;);</span><br><span class="line"><span class="keyword">var</span> Empty4 = <span class="keyword">new</span> Schema(&#123; <span class="attr">any</span>: [&#123;&#125;] &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>mongoose.connect(‘mongodb://username:password@host:port/database?options…’);</p>
<h4 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a>操作缓存</h4><p>不必等待连接建立成功就可以使用 mongoose models</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&quot;mongodb://localhost/myapp&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> MyModel = mongoose.model(<span class="string">&quot;Test&quot;</span>, <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;));</span><br><span class="line"><span class="comment">// 可行</span></span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mongoose 会缓存操作，这样很方便，但有时也会造成疑惑，因为如果你没连上 ，Mongoose 不会 抛错。<br>要禁用缓存，请修改 bufferCommands 配置。 如果你打开了 bufferCommands 连接被挂起，尝试关闭 bufferCommands 检查你是否正确打开连接。 你也可以全局禁用 bufferCommands ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.set(<span class="string">&quot;bufferCommands&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是通过 Schema 构造而成的，除了具有 Schema 定义的数据库骨架以外，还可以操作数据库</p>
<p>第一个参数是跟 model 对应的集合（ collection ）名字的 单数 形式。 Mongoose 会自动找到名称是 model 名字 复数 形式的 collection 。 对于上例，Tank 这个 model 就对应数据库中 tanks 这个 collection。.model() 这个函数是对 schema 做了拷贝（生成了 model）。 你要确保在调用 .model() 之前把所有需要的东西都加进 schema 里了！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span>, <span class="attr">size</span>: <span class="string">&quot;string&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> Tank = mongoose.model(<span class="string">&quot;Tank&quot;</span>, schema);</span><br></pre></td></tr></table></figure>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>可以用 model 的 find，findById，findOne，where 这些静态方法</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>remove 方法</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>update 方法</p>
<h3 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h3><p>Mongoose document 代表着 MongoDB 文档的一对一映射。 每个 document 都是他的 Model 的实例。</p>
<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>有很多方法可以更新文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tank.findById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  tank.size = <span class="string">&quot;large&quot;</span>;</span><br><span class="line">  tank.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, updatedTank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(updatedTank);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用 .set() 修改 document，在底层 tank.size = ‘large’; 用 tank.set({ size: ‘large’ })实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tank.findById(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  tank.set(&#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125;);</span><br><span class="line">  tank.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, updatedTank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(updatedTank);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们仅仅需要更新而不需要获取该数据， Model#update 就很适合我们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tank.update(&#123; <span class="attr">_id</span>: id &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125; &#125;, callback);</span><br></pre></td></tr></table></figure>
<p>如果我们确实需要返回文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Tank.findByIdAndUpdate(</span><br><span class="line">  id,</span><br><span class="line">  &#123; <span class="attr">$set</span>: &#123; <span class="attr">size</span>: <span class="string">&quot;large&quot;</span> &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">new</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, tank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(tank);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>document 在被保存前会被验证</p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>可以用 .set() 覆盖整个文档，如果要修改在中间件中被保存的文档，这样很方便</p>
<h3 id="子文档-subdocument"><a href="#子文档-subdocument" class="headerlink" title="子文档 subdocument"></a>子文档 subdocument</h3><p>Mongoose 中子文档有两种不同的概念 子文档数组和单个嵌套子文档。</p>
<p>子文档与普通 document 类似。嵌套 schema 可以有自己的 中间件、自定义检验逻辑、 虚拟值以及其他顶层 schemas 可用的特性。两者主要的不同点是 子文档不能单独保存，他们会在他们的顶级文档保存时保存。</p>
<p>子文档跟普通 document 一样有 save 和 validate 中间件。 调用父文档的 save() 会触发其所有子文档的 save() 中间件， validate() 中间件同理。</p>
<p>子文档的 pre(‘save’) 和 pre(‘validate’) 中间件执行于 顶层 document 的 pre(‘save’) 之前， 顶层 document 的 pre(‘validate’) 之后。 因为 save() 前的验证就是一个内置中间件。（待修改）</p>
<h4 id="查找子文档"><a href="#查找子文档" class="headerlink" title="查找子文档"></a>查找子文档</h4><p>每个子文档都有一个默认的 <code>_id</code> 。Mongoose document 数组有一个特别的 id 方法， 这个方法只要传入 <code>_id</code> 就能返回文档数组中特定文档。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = parent.children.id(_id);</span><br></pre></td></tr></table></figure>
<h4 id="添加子文档到数组"><a href="#添加子文档到数组" class="headerlink" title="添加子文档到数组"></a>添加子文档到数组</h4><p>Mongoose 数组方法有 push、 unshift、 addToSet、 及其他：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = mongoose.model(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a comment</span></span><br><span class="line">parent.children.push(&#123; <span class="attr">name</span>: <span class="string">&quot;Liesl&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> subdoc = parent.children[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(subdoc); <span class="comment">// &#123; _id: &#x27;501d86090d371bab2c0341c5&#x27;, name: &#x27;Liesl&#x27; &#125;</span></span><br><span class="line">subdoc.isNew; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="代替声明语法的写法"><a href="#代替声明语法的写法" class="headerlink" title="代替声明语法的写法"></a>代替声明语法的写法</h4><p>如果你用对象的数组创建 schema ，mongoose 会自动 为你把对象转换成 schema：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">children</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span> &#125;],</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Equivalent</span></span><br><span class="line"><span class="keyword">var</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">children</span>: [<span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="string">&quot;string&quot;</span> &#125;)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个jsonParser</title>
    <url>/2021/02/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjsonParser/</url>
    <content><![CDATA[<p>想要学习编译原理这门课已经很久了，自己之前也有尝试看龙书或者听公开课，可是这样学到的公式性的知识太多，每次都没有坚持学习下去。</p>
<p>放假这几天学习了极客时间上的《编译原理之美 》这门专栏，把讲编译器前端部分的看完了。这个老师讲的是真的好，比较浅显的语言来讲解教科书上用大段公式说明的知识，同时结合了大量的实践内容，帮助我快速了解了编译原理的核心要点的同时，同时教授了我动手的能力。</p>
<p>之前面试 bilibili 的时候，面试官就问过我如何用代码实现验证一个 json 的有效性，当时回答很糟糕，完全没有使用编译技术这方面的意识。</p>
<p>其实编译技术就很好处理这种问题，走一边词法分析和语法分析的流程，在解析 token 或者 构建 ast 的过程中如果出错了，那么这个 json 就是非法的了。</p>
<p>既是为了练手，也是填上之前面试的这个坑，下面就简单实现一个 jsonParser。</p>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>写一个 jsonParse 其实很简单，但是自己还是花了不少时间来做这件事，也走了一些弯路，还抄了不少参考资料才写好的 😓。</p>
<p>资料列表：</p>
<ul>
<li><a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a> json 官网，里面有介绍 json 的语法规则</li>
<li><a href="https://github.com/microsoft/vscode/blob/master/src/vs/base/common/json.ts">https://github.com/microsoft/vscode/blob/master/src/vs/base/common/json.ts</a></li>
<li><a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/craft/SimpleLexer.java">专栏中的 SimpleLexer</a></li>
<li><a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/craft/SimpleParser.java">专栏中的 SimpleParser</a></li>
</ul>
<p>首先要解析 json，我们必须要了解 json 的语法规则。接触了 json 这么久，我还是第一次看 json 的语法规则定义，有不少新发现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json</span><br><span class="line">  element</span><br><span class="line"></span><br><span class="line">value</span><br><span class="line">  object</span><br><span class="line">  array</span><br><span class="line">  string</span><br><span class="line">  number</span><br><span class="line">  &quot;true&quot;</span><br><span class="line">  &quot;false&quot;</span><br><span class="line">  &quot;null&quot;</span><br><span class="line"></span><br><span class="line">object</span><br><span class="line">  &#x27;&#123;&#x27; ws &#x27;&#125;&#x27;</span><br><span class="line">  &#x27;&#123;&#x27; members &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">members</span><br><span class="line">  member</span><br><span class="line">  member &#x27;,&#x27; members</span><br><span class="line"></span><br><span class="line">member</span><br><span class="line">  ws string ws &#x27;:&#x27; element</span><br><span class="line"></span><br><span class="line">array</span><br><span class="line">  &#x27;[&#x27; ws &#x27;]&#x27;</span><br><span class="line">  &#x27;[&#x27; elements &#x27;]&#x27;</span><br><span class="line"></span><br><span class="line">elements</span><br><span class="line">  element</span><br><span class="line">  element &#x27;,&#x27; elements</span><br><span class="line"></span><br><span class="line">element</span><br><span class="line">  ws value ws</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line">  &#x27;&quot;&#x27; characters &#x27;&quot;&#x27;</span><br><span class="line"></span><br><span class="line">characters</span><br><span class="line">  &quot;&quot;</span><br><span class="line">  character characters</span><br><span class="line"></span><br><span class="line">character</span><br><span class="line">  &#x27;0020&#x27; . &#x27;10FFFF&#x27; - &#x27;&quot;&#x27; - &#x27;\&#x27;</span><br><span class="line">  &#x27;\&#x27; escape</span><br><span class="line"></span><br><span class="line">escape</span><br><span class="line">  &#x27;&quot;&#x27;</span><br><span class="line">  &#x27;\&#x27;</span><br><span class="line">  &#x27;/&#x27;</span><br><span class="line">  &#x27;b&#x27;</span><br><span class="line">  &#x27;f&#x27;</span><br><span class="line">  &#x27;n&#x27;</span><br><span class="line">  &#x27;r&#x27;</span><br><span class="line">  &#x27;t&#x27;</span><br><span class="line">  &#x27;u&#x27; hex hex hex hex</span><br><span class="line"></span><br><span class="line">hex</span><br><span class="line">  digit</span><br><span class="line">  &#x27;A&#x27; . &#x27;F&#x27;</span><br><span class="line">  &#x27;a&#x27; . &#x27;f&#x27;</span><br><span class="line"></span><br><span class="line">number</span><br><span class="line">  integer fraction exponent</span><br><span class="line"></span><br><span class="line">integer</span><br><span class="line">  digit</span><br><span class="line">  onenine digits</span><br><span class="line">  &#x27;-&#x27; digit</span><br><span class="line">  &#x27;-&#x27; onenine digits</span><br><span class="line"></span><br><span class="line">digits</span><br><span class="line">  digit</span><br><span class="line">  digit digits</span><br><span class="line"></span><br><span class="line">digit</span><br><span class="line">  &#x27;0&#x27;</span><br><span class="line">  onenine</span><br><span class="line"></span><br><span class="line">onenine</span><br><span class="line">  &#x27;1&#x27; . &#x27;9&#x27;</span><br><span class="line"></span><br><span class="line">fraction</span><br><span class="line">  &quot;&quot;</span><br><span class="line">  &#x27;.&#x27; digits</span><br><span class="line"></span><br><span class="line">exponent</span><br><span class="line">  &quot;&quot;</span><br><span class="line">  &#x27;E&#x27; sign digits</span><br><span class="line">  &#x27;e&#x27; sign digits</span><br><span class="line"></span><br><span class="line">sign</span><br><span class="line">  &quot;&quot;</span><br><span class="line">  &#x27;+&#x27;</span><br><span class="line">  &#x27;-&#x27;</span><br><span class="line"></span><br><span class="line">ws</span><br><span class="line">  &quot;&quot;</span><br><span class="line">  &#x27;0020&#x27; ws</span><br><span class="line">  &#x27;000A&#x27; ws</span><br><span class="line">  &#x27;000D&#x27; ws</span><br><span class="line">  &#x27;0009&#x27; ws</span><br></pre></td></tr></table></figure>
<p>通过看规范，我们知道 json 支持 <code>\u0020-\uffff</code> unicode 的，支持部分转义字符，支持数字的科学计数法表示，这些在我们写 parser 时都是要考虑进去的。</p>
<p>规则定义属性名是 string，也就是可以是空串，或者包含转义字符。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;\\n&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的 json 是合法的，至少我之前是想不到的。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>lexer 的写法参考了专栏的示例，用了 DFA 的方式，状态转移图直接参考 json 官网的弹珠图就好了。</p>
<p>举个典型的，数字的状态转移。</p>
<p><img src="/2021/02/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjsonParser/number.png" alt="number的弹珠图"></p>
<p>我们定义如下状态</p>
<p>NumberMinus,<br>NumberZeroStart,<br>NumberNormal,<br>NumberDot,<br>NumberAfterDot,<br>NumberE,<br>NumberESign,<br>NumberAfterE,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> DFAState.NumberMinus:</span><br><span class="line">  <span class="keyword">if</span> (ch === CharacterCodes._0) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberZeroStart;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberNormal;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberZeroStart:</span><br><span class="line">  <span class="keyword">if</span> (ch === CharacterCodes.dot) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberAfterDot;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberNormal:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.dot) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberDot;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.e || ch === CharacterCodes.E) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberE;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberDot:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberAfterDot;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberE:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberAfterE;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    ch === CharacterCodes.plus ||</span><br><span class="line">    ch === CharacterCodes.minus</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberESign;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberESign:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberAfterE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberAfterDot:</span><br><span class="line">  <span class="keyword">if</span> (ch === CharacterCodes.e || ch === CharacterCodes.E) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberE;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DFAState.NumberAfterE:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">initState</span>(<span class="params">ch: any</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 省略。。。。</span></span><br><span class="line">  <span class="built_in">this</span>.token = <span class="keyword">new</span> Token();</span><br><span class="line">  <span class="keyword">if</span> (ch === CharacterCodes.minus) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberMinus;</span><br><span class="line">    <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes._0) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberZeroStart;</span><br><span class="line">    <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = DFAState.NumberNormal;</span><br><span class="line">    <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">    <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">  &#125; <span class="comment">// 省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是将图中状态的转移用代码的形式表现出来，做这类工作的时候，分析的过程比编码要重要的多。</p>
<p>parser 也很简单，用递归下降的方式很容易实现。</p>
<p>完整代码如下，只是实现了基本的功能，没做什么错误处理</p>
<h4 id="lexer"><a href="#lexer" class="headerlink" title="lexer"></a>lexer</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CharacterCodes &#125; <span class="keyword">from</span> <span class="string">&quot;./CharacterCodes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Token, TokenType &#125; <span class="keyword">from</span> <span class="string">&quot;./token&quot;</span>;</span><br><span class="line"></span><br><span class="line">enum DFAState &#123;</span><br><span class="line">  Initial,</span><br><span class="line">  OpenBracket,</span><br><span class="line">  CloseBracket,</span><br><span class="line">  OpenBraces,</span><br><span class="line">  CloseBraces,</span><br><span class="line">  Colon,</span><br><span class="line">  Comma,</span><br><span class="line">  NumberMinus,</span><br><span class="line">  NumberZeroStart,</span><br><span class="line">  NumberNormal,</span><br><span class="line">  NumberDot,</span><br><span class="line">  NumberAfterDot,</span><br><span class="line">  NumberE,</span><br><span class="line">  NumberESign,</span><br><span class="line">  NumberAfterE,</span><br><span class="line">  StringNormal,</span><br><span class="line">  StringSlash,</span><br><span class="line">  StringSlashU,</span><br><span class="line">  StringInHex,</span><br><span class="line">  StringEnd,</span><br><span class="line">  NullType,</span><br><span class="line">  TrueType,</span><br><span class="line">  FalseType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nullSteps = [<span class="string">&quot;n&quot;</span>, <span class="string">&quot;nu&quot;</span>, <span class="string">&quot;nul&quot;</span>, <span class="string">&quot;null&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> trueSteps = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;tr&quot;</span>, <span class="string">&quot;tru&quot;</span>, <span class="string">&quot;true&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> falseSteps = [<span class="string">&quot;f&quot;</span>, <span class="string">&quot;fa&quot;</span>, <span class="string">&quot;fal&quot;</span>, <span class="string">&quot;fals&quot;</span>, <span class="string">&quot;false&quot;</span>];</span><br><span class="line"></span><br><span class="line">enum LexErrorType &#123;</span><br><span class="line">  EOF,</span><br><span class="line">  InvalidKeyword,</span><br><span class="line">  InvalidNumber,</span><br><span class="line">  InvalidStringCharacter,</span><br><span class="line">  UnexeceptedCharacter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wschar = [</span><br><span class="line">  CharacterCodes.space,</span><br><span class="line">  CharacterCodes.lineFeed,</span><br><span class="line">  CharacterCodes.tab,</span><br><span class="line">  CharacterCodes.formFeed,</span><br><span class="line">  CharacterCodes.backspace,</span><br><span class="line">  CharacterCodes.carriageReturn,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorObject</span> </span>&#123;</span><br><span class="line">  type!: LexErrorType;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type: LexErrorType</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span> </span>&#123;</span><br><span class="line">  <span class="attr">script</span>: string;</span><br><span class="line">  pos: number = <span class="number">0</span>;</span><br><span class="line">  state: DFAState = DFAState.Initial;</span><br><span class="line">  token: Token = <span class="keyword">new</span> Token();</span><br><span class="line">  tokenList: Token[] = [];</span><br><span class="line">  hexTemp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  isDigit(ch: number): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> ch &gt; CharacterCodes._0 &amp;&amp; ch &lt; CharacterCodes._9;</span><br><span class="line">  &#125;</span><br><span class="line">  isHex(ch: number): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">this</span>.isDigit(ch) ||</span><br><span class="line">      (ch &gt;= CharacterCodes.a &amp;&amp; ch &lt;= CharacterCodes.f) ||</span><br><span class="line">      (ch &gt;= CharacterCodes.A &amp;&amp; ch &lt;= CharacterCodes.F)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">script: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.script = script;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pos &lt; <span class="built_in">this</span>.script.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.script.charCodeAt(<span class="built_in">this</span>.pos++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> LexErrorType.EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getCh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.script.substring(<span class="built_in">this</span>.pos - <span class="number">1</span>, <span class="built_in">this</span>.pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tokenize(): Token[] &#123;</span><br><span class="line">    <span class="keyword">let</span> ch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> ((ch = <span class="built_in">this</span>.read())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> DFAState.Initial:</span><br><span class="line">            <span class="keyword">case</span> DFAState.OpenBracket:</span><br><span class="line">            <span class="keyword">case</span> DFAState.CloseBracket:</span><br><span class="line">            <span class="keyword">case</span> DFAState.OpenBraces:</span><br><span class="line">            <span class="keyword">case</span> DFAState.CloseBraces:</span><br><span class="line">            <span class="keyword">case</span> DFAState.Colon:</span><br><span class="line">            <span class="keyword">case</span> DFAState.Comma:</span><br><span class="line">            <span class="keyword">case</span> DFAState.StringEnd:</span><br><span class="line">              <span class="built_in">this</span>.initState(ch);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberMinus:</span><br><span class="line">              <span class="keyword">if</span> (ch === CharacterCodes._0) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberZeroStart;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberNormal;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberZeroStart:</span><br><span class="line">              <span class="keyword">if</span> (ch === CharacterCodes.dot) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberAfterDot;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.initState(ch);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberNormal:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.dot) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberDot;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.e || ch === CharacterCodes.E) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberE;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.initState(ch);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberDot:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberAfterDot;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberE:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberAfterE;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">                ch === CharacterCodes.plus ||</span><br><span class="line">                ch === CharacterCodes.minus</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberESign;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberESign:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberAfterE;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidNumber);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberAfterDot:</span><br><span class="line">              <span class="keyword">if</span> (ch === CharacterCodes.e || ch === CharacterCodes.E) &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.NumberE;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.initState(ch);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NumberAfterE:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.initState(ch);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.StringNormal:</span><br><span class="line">              <span class="keyword">if</span> (ch &gt;= <span class="number">0</span> &amp;&amp; ch &lt;= <span class="number">0x1f</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidStringCharacter);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.doubleQuote) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.StringEnd;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.backslash) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.StringSlash;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.StringSlash:</span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                [</span><br><span class="line">                  CharacterCodes.n,</span><br><span class="line">                  CharacterCodes.t,</span><br><span class="line">                  CharacterCodes.f,</span><br><span class="line">                  CharacterCodes.b,</span><br><span class="line">                  CharacterCodes.r,</span><br><span class="line">                  CharacterCodes.doubleQuote,</span><br><span class="line">                  CharacterCodes.slash,</span><br><span class="line">                  CharacterCodes.backslash,</span><br><span class="line">                ].includes(ch)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.StringNormal;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.u) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="built_in">this</span>.hexTemp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="built_in">this</span>.state = DFAState.StringSlashU;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidStringCharacter);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.StringSlashU:</span><br><span class="line">              <span class="keyword">const</span> character = <span class="built_in">this</span>.getCh();</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.isHex(ch)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.token.value += character;</span><br><span class="line">                <span class="built_in">this</span>.hexTemp += character;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.hexTemp.length === <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.state = DFAState.StringNormal;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidStringCharacter);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.NullType:</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">let</span> character = <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="keyword">if</span> (nullSteps.includes(<span class="built_in">this</span>.token.value + character)) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.token.value += character;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">this</span>.token.value === <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidKeyword);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.TrueType:</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">let</span> character = <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="keyword">if</span> (trueSteps.includes(<span class="built_in">this</span>.token.value + character)) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.token.value += character;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">this</span>.token.value === <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidKeyword);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DFAState.FalseType:</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">let</span> character = <span class="built_in">this</span>.getCh();</span><br><span class="line">                <span class="keyword">if</span> (falseSteps.includes(<span class="built_in">this</span>.token.value + character)) &#123;</span><br><span class="line">                  <span class="built_in">this</span>.token.value += character;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">this</span>.token.value === <span class="string">&quot;false&quot;</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.initState(ch);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.InvalidKeyword);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ErrorObject) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleError(err);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">case</span> LexErrorType.EOF:</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;解析完毕&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.tokenList.push(<span class="built_in">this</span>.token);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tokenList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">initState</span>(<span class="params">ch: any</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.token.value) &#123;</span><br><span class="line">      <span class="built_in">this</span>.tokenList.push(<span class="built_in">this</span>.token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.token = <span class="keyword">new</span> Token();</span><br><span class="line">    <span class="keyword">if</span> (ch === CharacterCodes.doubleQuote) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.StringNormal;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.StringType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.minus) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.NumberMinus;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes._0) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.NumberZeroStart;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isDigit(ch)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.NumberNormal;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.NumberType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.openBracket) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.OpenBracket;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.OpenBracket;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.closeBracket) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.CloseBracket;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.CloseBracket;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.openBrace) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.OpenBraces;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.OpenBraces;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.closeBrace) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.CloseBraces;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.CloseBraces;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.colon) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.Colon;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.Colon;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.comma) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.Comma;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.Comma;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.n) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.NullType;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.NullType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.t) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.TrueType;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.TrueType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === CharacterCodes.f) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = DFAState.FalseType;</span><br><span class="line">      <span class="built_in">this</span>.token.type = TokenType.FalseType;</span><br><span class="line">      <span class="built_in">this</span>.token.value += <span class="built_in">this</span>.getCh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wschar.includes(ch)) &#123;</span><br><span class="line">      <span class="comment">// 跳过空白字符</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ErrorObject(LexErrorType.UnexeceptedCharacter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleError</span>(<span class="params">err: ErrorObject</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`在位置<span class="subst">$&#123;<span class="built_in">this</span>.pos - <span class="number">1</span>&#125;</span>遇到错误`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`错误字符 <span class="subst">$&#123;<span class="built_in">this</span>.getCh()&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (err.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> LexErrorType.InvalidKeyword:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;非法关键字&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> LexErrorType.UnexeceptedCharacter:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;不被接受的字符: &quot;</span> + <span class="built_in">this</span>.getCh());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Lexer &#125; <span class="keyword">from</span> <span class="string">&quot;./lexer&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Token, TokenType &#125; <span class="keyword">from</span> <span class="string">&quot;./token&quot;</span>;</span><br><span class="line"></span><br><span class="line">enum AstNodeType &#123;</span><br><span class="line">  JsonObject,</span><br><span class="line">  JsonObjectProperty,</span><br><span class="line">  JsonArray,</span><br><span class="line">  JsonString,</span><br><span class="line">  JsonNumber,</span><br><span class="line">  JsonTrueType,</span><br><span class="line">  JsonFalseType,</span><br><span class="line">  JsonNullType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ParseErrorType &#123;</span><br><span class="line">  <span class="built_in">Error</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParseErrorObject</span> </span>&#123;</span><br><span class="line">  type!: ParseErrorType;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type: ParseErrorType</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstNode</span> </span>&#123;</span><br><span class="line">  <span class="attr">type</span>: AstNodeType | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  children: AstNode[] = [];</span><br><span class="line">  value: any = <span class="literal">undefined</span>;</span><br><span class="line">  parent: AstNode | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="attr">tokenList</span>: Token[];</span><br><span class="line">  pos = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tokenList[<span class="built_in">this</span>.pos];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">read</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tokenList[<span class="built_in">this</span>.pos++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">tokenList: any[]</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tokenList = tokenList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseProgram</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> parseResult = <span class="built_in">this</span>.parseValue() <span class="keyword">as</span> AstNode;</span><br><span class="line">      <span class="keyword">return</span> parseResult.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;错误位置&quot;</span>, <span class="built_in">this</span>.pos, <span class="built_in">this</span>.read());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parseResult;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseNumber();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseString();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseTrueType();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseFalseType();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseNullType();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseArray();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    parseResult = <span class="built_in">this</span>.parseObject();</span><br><span class="line">    <span class="keyword">if</span> (parseResult !== <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ParseErrorObject(ParseErrorType.Error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseObject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonObject;</span><br><span class="line">    astNode.value = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.OpenBraces) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.read();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.CloseBraces) &#123;</span><br><span class="line">        <span class="built_in">this</span>.read();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> properyAstNode = <span class="built_in">this</span>.parseObjectProperty() <span class="keyword">as</span> AstNode;</span><br><span class="line">      properyAstNode.parent = astNode;</span><br><span class="line">      astNode.children.push(properyAstNode);</span><br><span class="line">      astNode.value[properyAstNode.value[<span class="number">0</span>]] = properyAstNode.value[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.Comma) &#123;</span><br><span class="line">        <span class="built_in">this</span>.read();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.CloseBraces) &#123;</span><br><span class="line">          <span class="built_in">this</span>.read();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ParseErrorObject(ParseErrorType.Error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseArray</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonArray;</span><br><span class="line">    astNode.value = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.OpenBracket) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.CloseBracket) &#123;</span><br><span class="line">        <span class="built_in">this</span>.read();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> valueAstNode = <span class="built_in">this</span>.parseValue() <span class="keyword">as</span> AstNode;</span><br><span class="line">      valueAstNode.parent = astNode;</span><br><span class="line">      astNode.children.push(valueAstNode);</span><br><span class="line">      astNode.value.push(valueAstNode.value);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.Comma) &#123;</span><br><span class="line">        <span class="built_in">this</span>.read();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type === TokenType.CloseBracket) &#123;</span><br><span class="line">          <span class="built_in">this</span>.read();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ParseErrorObject(ParseErrorType.Error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseObjectProperty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.StringType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> propertyNameToken = <span class="built_in">this</span>.read();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.Colon) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ParseErrorObject(ParseErrorType.Error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.read();</span><br><span class="line">    <span class="keyword">const</span> valueAstNode = <span class="built_in">this</span>.parseValue() <span class="keyword">as</span> AstNode;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonObjectProperty;</span><br><span class="line">    valueAstNode.parent = astNode;</span><br><span class="line">    astNode.children.push(valueAstNode);</span><br><span class="line">    astNode.value = [<span class="built_in">JSON</span>.parse(propertyNameToken.value), valueAstNode.value];</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.NumberType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonNumber;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">this</span>.read();</span><br><span class="line">    astNode.value = <span class="built_in">JSON</span>.parse(token.value);</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.StringType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonString;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">this</span>.read();</span><br><span class="line">    astNode.value = <span class="built_in">JSON</span>.parse(token.value);</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseTrueType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.TrueType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonTrueType;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">this</span>.read();</span><br><span class="line">    astNode.value = <span class="built_in">JSON</span>.parse(token.value);</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseFalseType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.FalseType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonFalseType;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">this</span>.read();</span><br><span class="line">    astNode.value = <span class="built_in">JSON</span>.parse(token.value);</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parseNullType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.peek().type !== TokenType.NullType) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> astNode = <span class="keyword">new</span> AstNode();</span><br><span class="line">    astNode.type = AstNodeType.JsonNullType;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">this</span>.read();</span><br><span class="line">    astNode.value = <span class="built_in">JSON</span>.parse(token.value);</span><br><span class="line">    <span class="keyword">return</span> astNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lexer = <span class="keyword">new</span> Lexer(</span><br><span class="line">  <span class="string">`&#123;&quot;name&quot;:&quot;\\n\\uaaaatest project&quot;,\n\n&quot;number&quot;:1.5E5,  &quot;array&quot;:[1,2,true],      &quot;description&quot;:&quot;test project&quot;,&quot;private&quot;:true,&quot;workspaces&quot;:&#123;&quot;shell&quot;:&quot;shell&quot;&#125;&#125;`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tokenList = lexer.tokenize();</span><br><span class="line"></span><br><span class="line">tokenList.forEach(<span class="function">(<span class="params">token, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    index,</span><br><span class="line">    token.value.padEnd(<span class="number">20</span>, <span class="string">&quot; &quot;</span>),</span><br><span class="line">    TokenType[token.type <span class="keyword">as</span> TokenType]</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="keyword">new</span> Parser(tokenList);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parser.parseProgram());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记之数据链路层</title>
    <url>/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>数据链路层属于计算机网络的底层，使用的信道主要有以下两种类型:</p>
<ul>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播信道。这种信道使用一对多的广播通信方式,因此过程比较复杂。广播信道上连接的主机很多,因此必须使用专用的共享信道协议来协调这些主机的数据发送。<br>本章主要内容是</li>
<li>数据链路层点对点和广播信道的特点，以及这两种信道使用的协议（PPP，CSMA/CD）的特点</li>
<li>数据链路层的三个基本问题：封装成帧，透明传输和差错检测</li>
<li>以太网 mac 层的硬件地址</li>
<li>适配器，转发器，集线器，王巧，以太网交换机的作用和使用场合</li>
</ul>
<h3 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><ul>
<li>链路(link)是一条无源的点到点的物理线路段,中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li>
<li>数据链路(data link) 除了物理线路外,还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上,就构成了数据链路。现在最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/传送帧.png" alt="传送帧"></li>
<li>点对点通信在数据链路层的主要步骤<br><em> 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧
</em> 结点 A 把封装好的帧发给结点 B 的数据链路层 * 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层，否则丢弃该帧<br>数据链路层不考虑物理层之间如何实现比特传输的细节</li>
</ul>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部,然后就构成了一个帧。确定帧的界限。</li>
<li>首部和尾部的一个重要作用就是进行帧定界。</li>
<li>MTU Maximum Transfer Unit 最大传输单元</li>
<li>当数据是可打印的 ASCII 码组成的文本文件时，可以用特殊的帧定界符。控制字符 SOH（start of header）和 EOT （end of transmission），十六进制编码分别为 01 和 04</li>
</ul>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><ul>
<li>由于帧开始和结束使用了专门制定的控制字符，因此，所传输的数据中任何 8 比特的组合一定不允许和帧定界的控制字符的比特编码一样当传输的帧是用文本文件组成的帧时，这种方式没有问题，不用管传送的是什么字符，这种传输就是透明传输。但是当传送的是非 ASCII 的文本文件时，数据中可能会出现恰好和 SOH 和 EOT 一样的二进制数据。</li>
<li>如何解决<ul>
<li>字节填充法<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现数据当中,那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时,就删除其中前面的一个。</li>
<li>字符计数法<br>这种方法是在帧头部中使用一个字符计数字段来标明帧内字符数。例如,发送序列“5 A B C D E 4 U V W X 7 1 2 3 4 4 5 8”表示一共有三个帧,三个帧的长度分别为 5 字节、4 字节和 7 字节。但是这种方法很容易出现定界错误。假如计数值出现传输差错,接收端收到的序列为“5 A B C D E 6 U V W X 7 1 2 3 4 4 5 8”时,则接收端会将第二帧解释为“6 U V W X 7 1”,从而导致因发收双方对帧大小和内容理解不一致而出错。</li>
<li>带字符填充的首尾界符法<br>这种方法是在每一帧的开头加上 ASCII 字符“DLESTX” ,在帧末尾加上 ASCII 字符“DLE ETX” 。例如,假设待发送的数据是 ADLECB ,则在数据链路层封装的帧为:DLE STX ADLECB DLE ETX 如果发送方在数据帧中遇到帧头或者帧尾字符,就采用字符填充法来处理。例如,数据帧有 DLE 字符,就在其前面加一个 DLE。<br>DLE STX A DLE DLE CB DLE ETX</li>
<li>带位填充的首尾标志法(零比特填充法)<br>这种方法是用一个特殊的位模式“01111110”作为帧边界。数据中可能包含“01111110”数据,如何判断?采用零比特填充法使一帧中两个边界字段之间的数据不会出现 6 个连续 1。在发送端,当一串比特流数据中有 5 个连续 1 时,就立即填入一个 0。如此保证数据部分不会出现 6 个连续的 1 在接收帧时,先找到边界字段以确定帧的边界。接着再对比特流进行扫描。每当发现 5 个连续 1 时,就将其后的一个 0 删除,以还原成原来的比特流。</li>
<li>物理层编码违例法<br>物理层编码违例法就是利用物理层信息编码中未用的电信号来作为帧的边界。例如,用曼彻斯特编码,在传输之前,将数据位 1 编码成高-低电平对,数据位 0 编码成低-高电平对。那么高-高电平、低-低电平就可以用作帧的边界。</li>
</ul>
</li>
</ul>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><ul>
<li>误码率 传输错误比特占传输总比特数的比率称为误码率</li>
</ul>
<h5 id="循环冗余检测-CRC"><a href="#循环冗余检测-CRC" class="headerlink" title="循环冗余检测 CRC"></a>循环冗余检测 CRC</h5><ul>
<li>在数据链路层传送的帧中,广泛使用了循环冗余检验 CRC 的检错技术。 在发送端,先把数据划分为组。假定每组 k 个比特。假设待传送的一组数据 M = 101001(现在 k = 6)。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</li>
<li>用二进制的模 2 运算进行 2n 乘 M 的运算,这相当于在 M 后面添加 n 个 0。</li>
<li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P,得出商是 Q 而余数是 R,余数 R 比除数 P 少 1 位,即 R 是 n 位。</li>
<li>模 2 运算是不进位也不借位的运算，在这里等同于异或运算，即有当前位就可以得到该位运算的结果</li>
<li>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。循环冗余检验 CRC 和帧检验序列 FCS 并不等同。CRC 是一种常用的检错方法,而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出,但 CRC 并非用来获得 FCS 的唯一方法。</li>
<li>若得出的余数 R = 0,则判定这个帧没有差错,就接受(accept)。 若余数 R != 0,则判定这个帧有差错,就丢弃。但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。只要经过严格的挑选,并使用位数足够多的除数 P,那么出现检测不到的差错的概率就很小很小。</li>
</ul>
<h5 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h5><p><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/汉明码原理.png" alt="汉明码原理"><br>汉明码(Hamming Code)编码的关键是使用多余的奇偶校验位来识别一位错误。假设信息码共有 n 位,海明码共有 h 位,那么总共的码长为 n + h 位。为能检测出 n + h 位编码，中其中一位的错误,海明码必须能够表示至少 n + h + 1 种状态,其中 n + h 种表示 n + h 位编码中有一位错误,另外还需要 1 种来表示整个编码正确无误。则海明码的长度需要满足下列关系:</p>
<script type="math/tex; mode=display">2^h >= n + h + 1</script><p>把所有 2 的幂次方的数据位标记为奇偶校验位(编号为 1, 2, 4, 8, 16, 32, 64 等的位置)<br>其他数据位用于待编码数据. (编号为 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17 等的位置)<br>每个奇偶校验位的值代表了码字中部分数据位的奇偶性,其所在位置决定了要校验的比特位。<br>位置 1，校验所有二进制最后一位是 1 的位置<br>位置 2，校验所有二进制倒数第二位是 1 的位置<br>位置 4，校验所有二进制倒数第三位是 1 的位置<br>配偶是该位置的数值加上是其要效验的位置和为偶数，可以用异或运算计算。<br>配奇则正好相反。<br>如何得到是哪一位出错了呢？以配偶方式为例，求冗余码的效验和，假设 分别为 1 1 0 0 。正常效验和应当为 0，为 1 说明该位置效验的比特位有一位出现了错误。因此倒数第一位和倒数第二位为 1 的都为 1 的位置出现了错误，这可以唯一确定一个位置，即数据的第三位。</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>在不可靠的信道上实现可靠的数据传输为上层提供一条可靠的逻辑通道。CRC 循环冗余检测只能保证无比特差错，但是可能会出现帧丢失，帧失序等，无法做到无传输差错。</p>
<h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><ul>
<li>在发送完一个帧后,必须暂时保留已发送的帧的副本。数据帧和确认帧都必须进行编号。只要超过了一段时间还没有收到确认,就认为已发送的帧出错或丢失了,因而重传已发送过的帧。这就叫做超时重传。<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
<li>使用上述的确认和重传机制,我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li>
<li>RTT (Round Trip)</li>
<li>停止等待协议不适合发送时延远远小于往返时延的情况</li>
<li>停止等待协议的优点是简单,但缺点是信道利用率低。发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送,这种传输方式可获得很高的信道利用率,<br>这种方式是<strong>流水线传输</strong></li>
</ul>
<h5 id="回退-N-帧"><a href="#回退-N-帧" class="headerlink" title="回退 N 帧"></a>回退 N 帧</h5><ul>
<li>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N(回退 N),表示需要再退回来重传已发送过的 N 个分组。</li>
<li>GBN 协议的接受窗口大小为 1，当收到序号错误的分组，接收方除了丢弃他们，还对最近按序接受的分组进行确认</li>
<li>接收方采用累积确认的方式，对分组 n 的确认，表明接收方已经正确收到分组 n 和之前所有的分组</li>
<li>GBN 协议存在一个缺点:一个分组的差错可能引起大量分组的重传,这些分组可能已经被接收方正确接收了,但由于未按序到达而被丢弃。可设法只重传出现差错的分组。但必须加大接收窗口,以便先收下<br>失序到达但仍然处在接收窗口中的哪些分组,等到所缺分组收齐后再一并送交上层。这就是选择重传 SR(Selective Repeat)协议。</li>
</ul>
<h5 id="数据链路层的可靠传输"><a href="#数据链路层的可靠传输" class="headerlink" title="数据链路层的可靠传输"></a>数据链路层的可靠传输</h5><ul>
<li>实现可靠传输需要付出代价(例如会降低传输效率)。因此,应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。当链路误码率非常低时,在数据链路层可不实现可靠传输,而是由上层协议(例如,<br>运输层的 TCP 协议)来完成。但是在使用无线信道传输数据时,由于信道质量较差,在数据链路层仍需要实现可靠传输(例如使用停止等待协议)。</li>
</ul>
<h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><ul>
<li>现在全世界使用得最多的点对点数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。用户使用拨号电话线接入因特网时,一般都是使用 PPP 协议。</li>
<li>PPP 协议的特点<ul>
<li>简单——这是首要的要求</li>
<li>封装成帧</li>
<li>透明性</li>
<li>多种网络层协议</li>
<li>多种类型链路</li>
<li>差错检测</li>
<li>检测连接状态</li>
</ul>
</li>
<li>PPP 协议的组成<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP (Link Control Protocol)。</li>
<li>网络控制协议 NCP (Network Control Protocol)。</li>
</ul>
</li>
<li>PPP 协议的帧格式<br>标志字段 F = 0x7E (符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110)。地址字段 A 只置为 0xFF。地址字段实际上并不起作用。控制字段 C 通常置为 0x03。PPP 是面向字节的,所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP 协议字段<br>当协议字段为 0x0021 时,PPP 帧的信息字段就是 IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021,则表示这是网络控制数据。</li>
<li>透明传输问题<br>当 PPP 用在同步传输链路时,协议规定采用硬件来完成比特填充(和 HDLC 的做法一样)。当 PPP 用在异步传输时,就使用一种特殊的字符填充法。</li>
<li>PPP 的工作状态<br>当用户拨号接入 ISP 时,路由器的调制解调器对拨号做出确认,并建立一条物理连接。PC 机向路由器发送一系列的 LCP 分组(封装成多个 PPP 帧)。这些分组及其响应选择一些 PPP 参数,和进行网络层配置,NCP 给新接入的 PC 机分配一个临时的 IP 地址,使 PC 机成为因特网上的一个主机。通信完毕时,NCP 释放网络层连接,收回原来分配出去的 IP 地址。接着,LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul>
<li>广播信道可以进行一对多的通信,能很方便且廉价地连接多个邻近的计算机,因此曾经被广泛应用于局域网之中。由于用广播信道连接的计算机共享同一传输媒体,因此使用广播信道的局域网被称为共享式局域网。<br>虽然交换式局域网在有线领域已完全取代了共享式局域网,但无线局域网仍然使用的是共享媒体技术。</li>
</ul>
<h4 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h4><p>媒体访问/接入控制(MAC) Medium Access Control 多点接入、多址访问(Multiple Access)</p>
<ul>
<li>静态划分信道<br>频分多址，码分多址和时分多址，这种固定划分信道的方法很不灵活，对于突发性信道的传输利用率很低，通常在无线网络的物理层使用，而不是在数据链路层中使用。</li>
<li>动态接入控制<br>各站点动态占用信道发送数据，而不是使用预先固定分配好的信道<ul>
<li>随机接入<br>通过所有站点之间的竞争，随机地在信道上发送数据，如果恰巧有两个或者更多的站点在同意时刻发送数据，那么信号在共享媒体上就要发生碰撞，使得这些站点的发送都失败，因此这类协议要解决的关键问题是如何避免冲突以及在发生冲突后如何尽快恢复通信。共享式以太网采用的就是随机接入。</li>
<li>受控接入<br>不能随机的发送信息而必须服从一定的控制，典型代表有集中控制的多点轮询协议和分散的令牌传递协议。集中控制的多点轮训协议有一个主站以循环方式轮询每个站点有无数据发送，只有被轮询到的站点才能发送数据，分散控制的令牌传递协议中各站点是平等的，并连接成一个唤醒网络，令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据。</li>
</ul>
</li>
</ul>
<h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul>
<li>局域网的拓扑有星形网，环形网，总线网，树形网。总线网和树形网用总线两端的匹配电阻消除总线上传播的电磁波信号的能量</li>
</ul>
<h5 id="局域网体系结构"><a href="#局域网体系结构" class="headerlink" title="局域网体系结构"></a>局域网体系结构</h5><ul>
<li>IEEE 802 委员会将局域网的数据链路层拆成了两个子层，即逻辑链路控制 (Logical Link Control) 和 媒体接入控制 (Medium Access Control MAC) 子层。与接入到传输媒体有关的内容都放在 MAC 子层，而 LLC 子层与传输媒体无关，不管采用何种传输媒体和 MAC 子层的局域网，对 LLC 子层来说都是透明的。然而由于以太网在局域网中已经取得了垄断地位，LLC(802.2 标准)已经不再重要。</li>
</ul>
<h5 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h5><ul>
<li>网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (NetworkInterface Card),或“网卡”。</li>
<li>适配器的重要功能:<ul>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。</li>
</ul>
</li>
</ul>
<h5 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h5><ul>
<li>在局域网中,硬件地址又称为物理地址,或 MAC 地址。802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。但鉴于大家都早已习惯了将这种 48 位的“名字”称为“地址”,所以本书也采用这种习惯用法,尽管这种说法并不太严格。</li>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24 位)由厂家自行指派,称为扩展标识符,必须保证生产出的适配器没有重复地址。一个地址块可以生成$2^24$个不同的地址。这种 48 位地址称为 MAC-48,它的通用名称是 EUI-48。“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</li>
<li>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.<br>如果是发往本站的帧则收下,然后再进行其他的处理。<br>否则就将此帧丢弃,不再进行其他的处理。</li>
<li>“发往本站的帧”包括以下三种帧:<br>单播(unicast)帧(一对一)<br>广播(broadcast)帧(一对全体)<br>多播(multicast)帧(一对多)</li>
</ul>
<h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><ul>
<li>以太网的两个标准<br>DIX Ethernet V2。<br>IEEE 的 802.3 标准。<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别,因此可以将 802.3 局域网简称为“以太网”。严格说来,“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</li>
</ul>
<h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA CD 协议"></a>CSMA CD 协议</h4><ul>
<li>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致,因此只有 D 才接收这个数据帧。其他所有的计算机(A, C 和 E)都检测到不是发送给它们的数据帧,因此就丢弃这个数据帧而不能够收下来。具有广播特性的总线上实现了一对一的通信。</li>
<li>采用较为灵活的无连接的工作方式,即不必先建立连接就可以直接发送数据。以太网对发送的数据帧不进行编号,也不要求对方发回确认。 这样做的理由是局域网信道的质量很好,因信道质量产生差错的概率是很<br>小的。</li>
<li>以太网提供的服务是不可靠的交付,即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧,其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传,但以太网并不知道这是一个重传的帧,而是当作一个新的数据帧来发送。</li>
<li>以太网发送数据都使用曼彻斯特编码</li>
<li>CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。<ul>
<li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据,如果有,则暂时不要发送数据,以免发生碰撞。</li>
<li>总线上并没有什么“载波”。因此, “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时,总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。在发生碰撞时,总线上传输的信号产生了严重的失真,无法从中恢复出有用的信息来。每一个正在发送数据的站,一旦发现总线上出现了碰撞,就要立即停止发送,免得继续浪费网络资源,然后等待一段随机时间后再次发送。</li>
<li>关于如何检测信道空闲，站点会持续监听到达该站的信号，如果检测到信号包含数据，则说明在这一段时间内信道不是空闲的</li>
<li>当某个站监听到总线是空闲时,也可能总线并非真正是空闲的。A 向 B 发出的信息,要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息),则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</li>
<li>最先发送数据帧的站,在发送数据帧后至多经过时间 2r (两倍的端到端往返时延)就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2r 称为争用期,或碰撞窗口。经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞。</li>
</ul>
</li>
<li>以太网取 51.2 us 为争用期的长度。对于 10 Mb/s 以太网,在争用期内可发送 512 bit,即 64 字节。以太网在发送数据时,若前 64 字节没有发生冲突,则后续的数据就不会发生冲突。</li>
<li>为保证发送方能检测到所有碰撞,以太网规定了最短有效帧长为 64 字节。如果发生冲突,就一定是在发送的前 64 字节之内,立即中止发送,这时已经发送出去的数据一定小于 64 字节。因此将长度小于 64 字节的帧都视为是由于冲突而异常中止的无效帧。</li>
<li>当发送数据的站一旦发现发生了碰撞时: 立即停止发送数据;再继续发送若干比特的人为干扰信号(jamming signal),以便让所有站点都知道现在已经发生了碰撞。</li>
<li>帧间最小间隔 96 比特时间，站点在发送数据帧之前要等待信道空闲 96 比特时间，这样用于接收方检测一个帧的结束，同时也使得其他所有站点都能有机会争用信道并发送数据</li>
<li>CSMA/CD 的要点如下<ul>
<li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送</li>
<li>若适配器检测到信道空闲 96 比特时间，就发送这个帧。若检测到信道忙，则继续检测并等待信道转换为空闲 96 比特时间，然后发送这个帧</li>
<li>在发送过程中继续检测，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则终止数据的发送，并认为发送干扰信号</li>
<li>在终止发送后，适配器就执行指数退避算法，随机等待 r 倍的 512 比特时间后，返回到步骤 2</li>
</ul>
</li>
</ul>
<h5 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h5><p>go 语言的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRandomRate</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    <span class="keyword">return</span> random.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resend</span><span class="params">(k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    index := k</span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">10</span> &#123;</span><br><span class="line">        index = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    source := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    random := rand.New(source)</span><br><span class="line">    upperBound := <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(index)</span><br><span class="line">    r := random.Intn(upperBound)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第%d次重传 本次退避 51.2 * %d us\n&quot;</span>, k, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tbeb</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> failRate <span class="keyword">int</span></span><br><span class="line">    k := <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;请输入碰撞几率 0-100&quot;</span>)</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;failRate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> getRandomRate() &lt; failRate &#123;</span><br><span class="line">            k++</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">16</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;重传已经达到16次，丢弃该帧，向上层报告&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;发生碰撞，准备重传&quot;</span>)</span><br><span class="line">            resend(k)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;传送成功，共传输%d次\n&quot;</span>, k)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tbeb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第ｋ次重传，选择 $[0,2^k-1]$中的一个随机数作为倍数，将 2r 乘以该倍数作为退避时间</p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><script type="math/tex; mode=display">a = \frac{r}{t_0}</script><p>其中 2r 是争用期长，即端到端传播时延的两倍，帧长为 L，数据发送速率为 C，$t_0=\frac{L}{C}$是帧发送时间，当 a 趋近于 0 时，表示一发生碰撞就可以检测出来，a 越大，信道利用率越低。</p>
<ul>
<li>当网络覆盖范围越大,既端到端时延越大,信道极限利用率越低,即网络性能越差。另外,端到端时延越大或连接的站点越多,都会导致发生冲突的概率变大,网络性能还会进一步降低。可见,共享式以太网只能作为一种局域网技术。</li>
</ul>
<h4 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h4><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><ul>
<li>集线器是使用电子器件来模拟实际电缆线的工作,因此整个系统仍然像一个传统的以太网那样运行。</li>
<li>使用集线器的以太网在逻辑上仍是一个总线网,各工作站使用的还是 CSMA/CD 协议,并共享逻辑上的总线。</li>
<li>集线器很像一个多接口的转发器,工作在物理层。</li>
</ul>
<h4 id="以太网的帧格式"><a href="#以太网的帧格式" class="headerlink" title="以太网的帧格式"></a>以太网的帧格式</h4><ul>
<li>常用的以太网 MAC 帧格式有两种标准 :<ul>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ul>
</li>
<li>最常用的 MAC 帧是以太网 V2 的格式。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/以太网的帧格式.png" alt="以太网的帧格式"><br><em> 源地址和目的地址的地址指的是 MAC 地址
</em> 类型字段用来表示上层协议的类型<br><em> FCS 是帧检验学列
</em> 如果数据字段的长度小于 46 字节，MAC 子层就会在数据字段的最后加入一个整数字节的填充字段</li>
<li>因为以太网在传输帧的时候，各个帧之间必须有一定的间隙，因此不需要使用帧结束定界符</li>
<li>无效的 MAC 帧<ul>
<li>数据字段的长度与长度字段的值不一致;</li>
<li>帧的长度不是整数个字节;</li>
<li>用收到的帧检验序列 FCS 查出有差错;</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
<li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</li>
</ul>
</li>
</ul>
<h3 id="网桥和以太网交换机"><a href="#网桥和以太网交换机" class="headerlink" title="网桥和以太网交换机"></a>网桥和以太网交换机</h3><h4 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h4><ul>
<li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了局域网覆盖的地理范围。</li>
<li>碰撞域增大了,但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率,那么就不能用集线器将它们互连起<br>来。</li>
<li>由于争用期的限制,并不能无限扩大地理覆盖范围</li>
</ul>
<h4 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h4><ul>
<li>在数据链路层扩展以太网要使用网桥。</li>
<li>网桥工作在数据链路层,它根据 MAC 帧的目的地址对收到的帧进行转发。</li>
<li>网桥具有过滤帧的功能。当网桥收到一个帧时,并不是向所有的接口转发此帧,而是先检查此帧的目的 MAC 地址,然后再确定将该帧转发到哪一个接口</li>
</ul>
<h5 id="使用网桥的好处"><a href="#使用网桥的好处" class="headerlink" title="使用网桥的好处"></a>使用网桥的好处</h5><ul>
<li>过滤通信量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>(由于采用存储转发方式)可互连不同物理层、不同 MAC 子层和不同速率(如 10 Mb/s 和<br>100 Mb/s 以太网)的局域网。</li>
</ul>
<h5 id="使用网桥的缺点"><a href="#使用网桥的缺点" class="headerlink" title="使用网桥的缺点"></a>使用网桥的缺点</h5><ul>
<li>存储转发增加了时延。</li>
<li>在 MAC 子层并没有流量控制功能。</li>
<li>具有不同 MAC 子层的网段桥接在一起时时延更大。</li>
<li>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网,</li>
<li>否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的</li>
<li>广播风暴。</li>
</ul>
<h5 id="网桥和集线器-或转发器-不同"><a href="#网桥和集线器-或转发器-不同" class="headerlink" title="网桥和集线器(或转发器)不同"></a>网桥和集线器(或转发器)不同</h5><ul>
<li>集线器在转发帧时,不对传输媒体进行检测。</li>
<li>网桥在转发帧之前必须执行 CSMA/CD 算法。若在发送过程中出现碰撞,就必须停止发送和进行退避。</li>
</ul>
<h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><ul>
<li>目前使用得最多的网桥是透明网桥(transparent bridge)。“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥,因为网<br>桥对各站来说是看不见的。</li>
<li>透明网桥是一种即插即用设备,其标准是 IEEE 802.1D。</li>
</ul>
<h5 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h5><p>go 语言实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">    port    <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Iptable <span class="keyword">struct</span> &#123;</span><br><span class="line">    records []Record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iptable Iptable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTable</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        <span class="keyword">if</span> record.address == address &#123;</span><br><span class="line">            <span class="keyword">return</span> record.port, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err := errors.New(<span class="string">&quot;没找到记录&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeRecord</span><span class="params">(address <span class="keyword">string</span>, port <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    iptable.records = <span class="built_in">append</span>(iptable.records, Record&#123;port, address&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id  address               port\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, record := <span class="keyword">range</span> iptable.records &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%-3d %-20s %-5d\n&quot;</span>, index, record.address, record.port)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;**********iptable**********\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> srcAddress, destAddress <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> srcPort <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入源地址和端口号&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>, &amp;srcAddress, &amp;srcPort)</span><br><span class="line">        fmt.Println(<span class="string">&quot;请输入目的地址&quot;</span>)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;destAddress)</span><br><span class="line">        destPort, err := findTable(destAddress)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中未找到记录&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;从其他端口将此帧转发给别的网桥&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;转发表中找到记录&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> srcPort == destPort &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;目的地址和源地址在同一网段，目的主机已经收到&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;将此帧从查找到的端口发出 %d\n&quot;</span>, destPort)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> _, err := findTable(srcAddress); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                storeRecord(srcAddress, srcPort)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printTable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有,就在转发表中增加一个项目(源地址、进入的接口和时间)。如有,则把原有的项目进行更新。</li>
<li>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<ul>
<li>如没有,则通过所有其他接口(但进入网桥的接口除外)按进行转发。</li>
<li>如有,则按转发表中给出的接口进行转发。</li>
<li>若转发表中给出的接口就是该帧进入网桥的接口,则应丢弃这个帧(因为这时不需要经过网桥进行转发)。</li>
</ul>
</li>
</ul>
<h5 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h5><ul>
<li>互连在一起的网桥在进行彼此通信后,就能找出原来的网络拓扑的一个子集。在这个子集里,整个连通的网络中不存在回路,即在任何两个站之间只有一条路径。</li>
<li>网桥会关闭不在生成树上的那些接口,以确保不存在环路。</li>
<li>为了得出能够反映网络拓扑发生变化时的生成树,在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</li>
</ul>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><ul>
<li>透明网桥容易安装,但网络资源的利用不充分。</li>
<li>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。源站以广播方式向欲通信的目的站发送一个发现帧,每个发现帧都记录所经过的路由。</li>
<li>发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后,从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部,都必须携带源站所确定的这一路由信息。</li>
</ul>
<h5 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h5><ul>
<li>1990 年问世的交换式集线器(switching hub),可明显地提高局域网的性能。</li>
<li>交换式集线器常称为以太网交换机(switch)或第二层交换机(表明此交换机工作在数据链路层)。</li>
<li>以太网交换机通常都有十几个接口。因此,以太网交换机实质上就是一个多接口的网桥,可见交换机工作在数据链路层。</li>
</ul>
<h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><ul>
<li>以太网交换机的每个接口都直接与主机相连,并且一般都工作在全双工方式。</li>
<li>交换机能同时连通许多对的接口,使每一对相互通信的主机都能像独占通信媒体那样,进行无碰撞地传输数据。</li>
<li>以太网交换机由于使用了专用的交换结构芯片,其交换速率较高。</li>
</ul>
<h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><h4 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h4><ul>
<li>无线局域网不能简单地搬用 CSMA/CD 协议。这里主要有两个原因。对于无线信道,接收信号强度往往会远远小于发送信号强度。如要在无线局域网的适配器上实现碰撞检测,对硬件的要求非常高。。</li>
<li>即使我们能够实现碰撞检测的功能,并且当我们在发送数据时检测到信道是空闲的,在接收端仍然有可能发生碰撞(隐蔽站问题)。</li>
<li>无线局域网不能使用 CSMA/CD,而只能使用改进的 CSMA 协议。</li>
<li>改进的办法是把 CSMA 增加一个碰撞避免(Collision Avoidance)功能。</li>
<li>802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时,还增加使用停止等待协议。</li>
<li>下面先介绍 802.11 的 MAC 层。</li>
<li>所有的站在完成发送后,必须再等待一段很短的时间(继续监听)才能发送下一帧。这段时间的通称是帧间间隔 IFS (InterFrame Space)。</li>
<li>帧间间隔长度取决于该站欲发送的帧的类型。高优先级帧需要等待的时间较短,因此可优先获得发送权。</li>
<li>若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</li>
</ul>
<h5 id="三种帧间间隔"><a href="#三种帧间间隔" class="headerlink" title="三种帧间间隔"></a>三种帧间间隔</h5><ul>
<li>SIFS,即短(Short)帧间间隔,是最短的帧间间隔,用来分隔开属于一次对话的各帧。一个站应当能够在这段时间内从发送方式切换到接收方式。</li>
<li>使用 SIFS 的帧类型有:ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧,以及所有回答 AP 探询的帧<br>和在 PCF 方式中接入点 AP 发送出的任何帧。</li>
<li>PIFS,即点协调功能帧间间隔,它比 SIFS 长,是为了在开始使用 PCF 方式时(在 PCF 方式下使用,没有争用)优先获得接入到媒体中。PIFS 的长度是 SIFS 加一个时隙(slot)长度。</li>
<li>时隙的长度是这样确定的:在一个基本服务集 BSS 内当某个站在一个时隙开始时接入到媒体时,那么在下一个时隙开始时,其他站就都能检测出信道已转变为忙态。</li>
<li>DIFS,即分布协调功能帧间间隔(最长的 IFS),在 DCF 方式中用来发送数据帧和管理帧。DIFS 的长度比 PIFS 再增加一个时隙长度。</li>
<li>欲发送数据的站先检测信道。在 802.11 标准中规定了在物理层的空中接口进行物理层的载波监听。</li>
<li>通过收到的相对信号强度是否超过一定的门限数值就可判定是否有其他的移动站在信道上发送数据。</li>
<li>当源站发送它的第一个 MAC 帧时,若检测到信道空闲,则在等待一段时间 DIFS 后就可发送。</li>
<li>为什么信道空闲还要再等待？这是考虑到可能有其他的站有高优先级的帧要发送。如有,就要让高优先级帧先发送。</li>
</ul>
<h5 id="高优先级帧发送"><a href="#高优先级帧发送" class="headerlink" title="高优先级帧发送"></a>高优先级帧发送</h5><ul>
<li>源站发送了自己的数据帧。</li>
<li>目的站若正确收到此帧,则经过时间间隔 SIFS 后,向源站发送确认帧 ACK。</li>
<li>若源站在规定时间内没有收到确认帧 ACK(可能是发生碰撞),就必须重传此帧,直到收到确认为止,或者经过若干次的重传失败后放弃发送。</li>
<li>确认机制可以认为是一种间接碰撞检测 。</li>
</ul>
<h6 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h6><ul>
<li>为避免碰撞,如果要发送数据的站发现信道忙, 在信道恢复空闲时并不是立即发送数据,而是要退避一段随机的时间(大于 DIFS)若信道仍然空闲才能发送数据</li>
<li>若发送方接收到确认要立即发送下一帧时,为公平竞争,也要执行退避</li>
<li>当发送方没有接收到确认,重传帧时,要将随机选择退避时间的范围扩大一倍。</li>
</ul>
<h5 id="退避计时器"><a href="#退避计时器" class="headerlink" title="退避计时器"></a>退避计时器</h5><ul>
<li>站点每经历一个时隙的时间就检测一次信道。这可能发生两种情况。</li>
<li>若检测到信道空闲,退避计时器就继续倒计时。</li>
<li>若检测到信道忙,就冻结退避计时器的剩余时间,重新等待信道变为空闲并再经过时间 DIFS 后,从剩余时间开始继续倒计时。如果退避计时器的时间减小到零时,就开始发送整个数据帧。</li>
</ul>
<h5 id="退避算法的使用"><a href="#退避算法的使用" class="headerlink" title="退避算法的使用"></a>退避算法的使用</h5><ul>
<li>仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是要发送的第一个数据帧。<br>除此以外的所有情况,都必须使用退避算法。即:<ul>
<li>在发送第一个帧之前检测到信道处于忙态。</li>
<li>在每一次的重传后。</li>
<li>在每一次的成功发送后。<br><img src="/2019/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11退避机制.png" alt="802.11退避机制"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
